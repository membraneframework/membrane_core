Excluding tags: [:long_running]

...........................................

  1) test handling :child_notification action when parent pid is set (Membrane.Core.Element.ActionHandlerTest)
     test/membrane/core/element/action_handler_test.exs:442
     Assertion failed, no matching message after 0ms
     Showing 1 of 1 message in the mailbox
     code: assert_received Message.new(:child_notification, [:elem_name, @mock_notification])
     mailbox:
       pattern: Membrane.Core.Message.new(:child_notification, [:elem_name, :hello_test])
       value:   {Membrane.Core.Message, :parent_notification, [:elem_name, :hello_test], []}
     stacktrace:
       test/membrane/core/element/action_handler_test.exs:453: (test)

.....................................

  2) test Not linked element DOWN message should be delivered to handle_other if it's not coming from parent (Membrane.Core.ElementTest)
     test/membrane/core/element_test.exs:315
     Assertion failed, no matching message after 500ms
     The following variables were pinned:
       ref = #Reference<0.3642608924.1448083462.156809>
       monitored_proc = #PID<0.754.0>
     Showing 1 of 1 message in the mailbox
     code: assert_receive Message.new(:child_notification, [:name, {:DOWN, ^ref, :process, ^monitored_proc, :normal}])
     mailbox:
       pattern: Membrane.Core.Message.new(:child_notification, [
                  :name,
                  {:DOWN, ^ref, :process, ^monitored_proc, :normal}
                ])
       value:   {Membrane.Core.Message, :parent_notification,
                 [:name, {:DOWN, #Reference<0.3642608924.1448083462.156809>, :process, #PID<0.754.0>, :normal}], []}
     stacktrace:
       test/membrane/core/element_test.exs:327: (test)

     The following output was logged:
     
     11:17:21.998 [debug] Element start: :name
     node: ,
     module: Membrane.Core.ElementTest.SomeElement,
     element options: %{},
     
     
     11:17:21.998 [debug] [:name] Initializing element: Membrane.Core.ElementTest.SomeElement, options: %{}
     
     11:17:21.998 [debug] [:name] Element initialized: Membrane.Core.ElementTest.SomeElement
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: nil, terminating?: false}]
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.025 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.025 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>},
     
     
     11:17:22.025 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}
     
     11:17:22.025 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.025 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.025 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter3, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}]
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Starting child: name: :endpoint, module: Membrane.Testing.Endpoint
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Element start: :endpoint
     node: ,
     module: Membrane.Testing.Endpoint,
     element options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.025 [debug] [:endpoint] Initializing element: Membrane.Testing.Endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.025 [debug] [:endpoint] Element initialized: Membrane.Testing.Endpoint
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.026 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.026 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.026 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.026 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Starting child: name: :filter3, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Element start: :filter3
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.026 [debug] [:filter3] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.026 [debug] [:filter3] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.086 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.086 [debug] [:endpoint] Element handle link on pad :output with pad :input of child :filter1
     
     11:17:22.086 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.086 [debug] [:filter1] Element handle link on pad :input with pad :output of child :endpoint
     
     11:17:22.086 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.086 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.086 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.086 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.086 [debug] [:filter2] Element handle link on pad :output with pad :input of child :filter3
     
     11:17:22.086 [debug] [:filter3] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.087 [debug] [:filter3] Element handle link on pad :output with pad :input of child :endpoint
     
     11:17:22.087 [debug] [:endpoint] Element handle link on pad :input with pad :output of child :filter3
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Spec #Reference<0.3642608924.1448083457.157826> linked internally
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Spec #Reference<0.3642608924.1448083457.157840> linked internally
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Spec playback init #Reference<0.3642608924.1448083457.157826> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, pid: #PID<0.763.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.762.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.764.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, pid: #PID<0.763.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Spec playback init #Reference<0.3642608924.1448083457.157840> %{endpoint: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.765.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}, filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.766.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.767.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter3, options: nil, pid: #PID<0.768.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.762.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.765.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.766.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.764.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.767.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter3, options: nil, pid: #PID<0.768.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Changing playback state from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.702.0>] Changing playback state from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Playback state changed from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Changing playback state from prepared to playing
     
     11:17:22.106 [debug] [pipeline@<0.702.0>] Playback state changed from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.702.0>] Changing playback state from prepared to playing
     
     11:17:22.106 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.106 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.106 [debug] [:source] Evaluating playback buffer
     
     11:17:22.106 [debug] [:endpoint] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.106 [debug] [:endpoint] Evaluating playback buffer
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Playback state changed from prepared to playing
     
     11:17:22.106 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter3] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [pipeline@<0.702.0>] Playback state changed from prepared to playing
     
     11:17:22.107 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter3] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter3] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:endpoint] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.127 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.127 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.127 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.128 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.788.0>},
     process options: []
     
     
     11:17:22.128 [debug] [pipeline@<0.789.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.129 [debug] [pipeline@<0.789.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: nil, terminating?: false}]
     
     11:17:22.129 [debug] [pipeline@<0.789.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.129 [debug] [pipeline@<0.789.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.130 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.130 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>},
     
     
     11:17:22.130 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}
     
     11:17:22.130 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.130 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.130 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.130 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.130 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.130 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.130 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Spec #Reference<0.3642608924.1448083457.157903> linked internally
     
     11:17:22.131 [debug] [pipeline@<0.789.0>] Spec playback init #Reference<0.3642608924.1448083457.157903> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, pid: #PID<0.793.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.792.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.794.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.131 [debug] [pipeline@<0.789.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, pid: #PID<0.793.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.792.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.794.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Changing playback state from stopped to prepared
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Playback state changed from stopped to prepared
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Changing playback state from prepared to playing
     
     11:17:22.132 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.132 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.132 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:source] Evaluating playback buffer
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Playback state changed from prepared to playing
     
     11:17:22.132 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.132 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.132 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.133 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.798.0>},
     process options: []
     
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: nil, terminating?: false}]
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.134 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.134 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>},
     
     
     11:17:22.134 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}
     
     11:17:22.134 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.134 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.134 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.134 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.134 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.134 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.134 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Spec #Reference<0.3642608924.1448083457.158014> linked internally
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Spec playback init #Reference<0.3642608924.1448083457.158014> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, pid: #PID<0.802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.801.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, pid: #PID<0.802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.801.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Changing playback state from stopped to prepared
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Playback state changed from stopped to prepared
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Changing playback state from prepared to playing
     
     11:17:22.135 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.135 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.135 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:source] Evaluating playback buffer
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Playback state changed from prepared to playing
     
     11:17:22.135 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.135 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.135 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.136 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.807.0>},
     process options: []
     
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: nil, terminating?: false}]
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.136 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.136 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>},
     
     
     11:17:22.136 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}
     
     11:17:22.137 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.137 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.137 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.137 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.137 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.137 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.137 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Spec #Reference<0.3642608924.1448083457.158072> linked internally
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Spec playback init #Reference<0.3642608924.1448083457.158072> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, pid: #PID<0.811.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.810.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.813.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, pid: #PID<0.811.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.810.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.813.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Changing playback state from stopped to prepared
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Playback state changed from stopped to prepared
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Changing playback state from prepared to playing
     
     11:17:22.137 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.137 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.137 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.137 [debug] [:source] Evaluating playback buffer
     
     11:17:22.137 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.137 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Playback state changed from prepared to playing
     
     11:17:22.137 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.138 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.138 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.138 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.138 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.817.0>},
     process options: []
     
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: nil, terminating?: false}]
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.138 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.138 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>},
     
     
     11:17:22.139 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}
     
     11:17:22.139 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.139 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.139 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.139 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.139 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.139 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.139 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Spec #Reference<0.3642608924.1448083463.155418> linked internally
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Spec playback init #Reference<0.3642608924.1448083463.155418> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, pid: #PID<0.821.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.820.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.822.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, pid: #PID<0.821.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.820.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.822.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Changing playback state from stopped to prepared
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Playback state changed from stopped to prepared
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Changing playback state from prepared to playing
     
     11:17:22.139 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.139 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.140 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.140 [debug] [:source] Evaluating playback buffer
     
     11:17:22.140 [debug] [pipeline@<0.818.0>] Playback state changed from prepared to playing
     
     11:17:22.140 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.140 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.140 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.216 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.763.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.700.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.708.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.216 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.793.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.789.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.790.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.216 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.763.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.700.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.708.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.216 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.802.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.799.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.800.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.216 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.803.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.801.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.799.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.800.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.216 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.764.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.762.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.700.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.708.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.217 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.793.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.789.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.790.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.217 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.794.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.792.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.789.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.790.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.217 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.802.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.799.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.800.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.217 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.219 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.811.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.808.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.809.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.219 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.811.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.808.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.809.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.219 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.219 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.219 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.813.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.810.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.808.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.809.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.219 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.229 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.833.0>},
     process options: []
     
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: nil, terminating?: false}]
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:22.229 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:22.229 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting child: name: :filter, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Element start: :filter
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:22.229 [debug] [:filter] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:22.229 [debug] [:filter] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting child: name: :source, module: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Element start: :source
     node: ,
     module: Membrane.Integration.AutoDemandsTest.PushSource,
     element options: nil,
     
     
     11:17:22.229 [debug] [:source] Initializing element: Membrane.Integration.AutoDemandsTest.PushSource, options: nil
     
     11:17:22.229 [debug] [:source] Element initialized: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:22.229 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.229 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.229 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.229 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Spec #Reference<0.3642608924.1448083459.156072> linked internally
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Spec playback init #Reference<0.3642608924.1448083459.156072> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.837.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.836.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.838.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.837.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.836.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.838.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Changing playback state from stopped to prepared
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Playback state changed from stopped to prepared
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Changing playback state from prepared to playing
     
     11:17:22.230 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.230 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.230 [debug] [:source] Sending caps through pad :output
     Caps: :any
     
     
     11:17:22.230 [debug] [:source] Evaluating playback buffer
     
     11:17:22.231 [debug] [pipeline@<0.834.0>] Playback state changed from prepared to playing
     
     11:17:22.231 [debug] [:filter] Received caps on pad :input
     Caps: :any
     
     
     11:17:22.231 [debug] [:filter] Sending caps through pad :output
     Caps: :any
     
     
     11:17:22.231 [debug] [:sink] Received caps on pad :input
     Caps: :any
     
     
     11:17:22.241 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.241 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.241 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.241 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.821.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.818.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.819.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.241 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.241 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.821.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.818.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.819.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.241 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.241 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.822.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.820.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.818.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.819.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.241 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.243 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.849.0>},
     process options: []
     
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: nil, terminating?: false}]
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.243 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.243 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>},
     
     
     11:17:22.243 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}
     
     11:17:22.243 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.244 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.244 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.244 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.244 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.244 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.244 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Spec #Reference<0.3642608924.1448083459.156107> linked internally
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Spec playback init #Reference<0.3642608924.1448083459.156107> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, pid: #PID<0.853.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.852.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.854.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, pid: #PID<0.853.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.852.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.854.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Changing playback state from stopped to prepared
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Playback state changed from stopped to prepared
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Changing playback state from prepared to playing
     
     11:17:22.244 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.244 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.244 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.244 [debug] [:source] Evaluating playback buffer
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Playback state changed from prepared to playing
     
     11:17:22.244 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.244 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.244 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.312 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.862.0>},
     process options: []
     
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}]
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.312 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.312 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:22.327 [debug] [pipeline@<0.863.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:22.336 [error] [:source] Toilet overflow.
     
     Reached the size of 96000, which is above toilet capacity (200)
     when storing data from output working in push mode. It means that some element in the pipeline
     processes the stream too slow or doesn't process it at all.
     To have control over amount of buffers being produced, consider using output in pull mode
     (see `Membrane.Pad.mode_t`).
     You can also try changing the `toilet_capacity` in `Membrane.ParentSpec.via_in/3`.
     
     
     11:17:22.350 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.853.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.350 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.351 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.853.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.351 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.351 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.854.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.852.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.351 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.372 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.372 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: nil, terminating?: false}]
     
     11:17:22.372 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.372 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.372 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.372 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.373 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.373 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.373 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.373 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.381 [debug] [pipeline@<0.834.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:22.381 [debug] [pipeline@<0.834.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:22.382 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:22.382 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:22.382 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.382 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:22.382 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:22.382 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.384 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.883.0>},
     process options: []
     
     
     11:17:22.384 [debug] [pipeline@<0.884.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}]
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :tee, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :tee
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
     element options: nil,
     
     
     11:17:22.385 [debug] [:tee] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandTee, options: nil
     
     11:17:22.385 [debug] [:tee] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:22.385 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:22.385 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :left_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :left_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.385 [debug] [:left_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.385 [debug] [:left_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :right_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :right_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:22.385 [debug] [:right_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:22.385 [debug] [:right_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [:source] Element handle link on pad :output with pad :input of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} with pad :input of child :left_sink
     
     11:17:22.385 [debug] [:left_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} with pad :input of child :right_sink
     
     11:17:22.385 [debug] [:right_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} of child :tee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec #Reference<0.3642608924.1448083463.155490> linked internally
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec playback init #Reference<0.3642608924.1448083463.155490> %{left_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, right_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, tee: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Playback state changed from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from prepared to playing
     
     11:17:22.386 [debug] [:right_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:left_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:source] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:right_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:left_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.394 [debug] [pipeline@<0.884.0>] Playback state changed from prepared to playing
     
     11:17:22.399 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: #PID<0.898.0>, module: Membrane.Integration.TimerTest.Pipeline, test_process: #PID<0.898.0>},
     process options: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing spec
     children: [element: Membrane.Integration.TimerTest.Element, bin: Membrane.Integration.TimerTest.Bin]
     links: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}]
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :element, module: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Element start: :element
     node: ,
     module: Membrane.Integration.TimerTest.Element,
     element options: nil,
     
     
     11:17:22.399 [debug] [:element] Initializing element: Membrane.Integration.TimerTest.Element, options: nil
     
     11:17:22.399 [debug] [:element] Element initialized: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :bin, module: Membrane.Integration.TimerTest.Bin
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Bin start: :bin
     node: ,
     module: Membrane.Integration.TimerTest.Bin,
     bin options: nil
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec #Reference<0.3642608924.1448083464.156227> linked internally
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec playback init #Reference<0.3642608924.1448083464.156227> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}, element: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from prepared to playing
     
     11:17:22.400 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:22.422 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.422 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.422 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked internally
     
     11:17:22.422 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156195> externally
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.422 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.422 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:22.434 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:22.434 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.435 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.435 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.435 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked externally
     
     11:17:22.435 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156195> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec #Reference<0.3642608924.1448083462.156962> linked internally
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec playback init #Reference<0.3642608924.1448083462.156962> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.435 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.435 [debug] [:source] Evaluating playback buffer
     
     11:17:22.435 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.436 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [pipeline@<0.863.0>] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.465 [debug] [:element] Evaluating playback buffer
     
     11:17:22.465 [debug] [:bin bin] Playback state changed from prepared to playing
     
     11:17:22.465 [debug] [pipeline@<0.899.0>] Playback state changed from prepared to playing
     
     11:17:22.499 [debug] [:name] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
.............

  3) test Starting and transmitting buffers with one endpoint and many filters in between (Membrane.Core.EndpointTest)
     test/membrane/integration/endpoint_test.exs:31
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 10 of 13 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:endpoint, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>, {:handle_element_end_of_stream, {:filter1, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>, {:handle_element_end_of_stream, {:filter2, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>, {:handle_element_end_of_stream, {:filter3, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:endpoint, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.702.0>, {:handle_element_end_of_stream, {:endpoint, :input}}}
     stacktrace:
       test/membrane/integration/endpoint_test.exs:62: anonymous fn/3 in Membrane.Core.EndpointTest.assert_data_flows_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/endpoint_test.exs:61: Membrane.Core.EndpointTest.assert_data_flows_through/3
       test/membrane/integration/endpoint_test.exs:50: (test)

     The following output was logged:
     
     11:17:21.876 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.689.0>},
     process options: []
     
     
     11:17:21.880 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter, filter3: Membrane.Support.Bin.TestBins.TestFilter], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: :filter3, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter3, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.672.0>},
     process options: []
     
     
     11:17:21.896 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:21.896 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:21.896 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:21.896 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:21.942 [debug] [:some_element] Evaluating playback buffer
     
     11:17:21.942 [debug] [:some_element] Received caps on pad :input
     Caps: :caps
     
     
     11:17:21.942 [debug] [:some_element] Sending caps through pad :output
     Caps: :caps
     
     
     11:17:21.942 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:21.942 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:21.942 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:21.942 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:21.942 [debug] [:some_element] Evaluating playback buffer
     
     11:17:21.945 [debug] [pipeline@<0.700.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:21.945 [debug] [pipeline@<0.702.0>] Initializing spec
     children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter, filter3: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: :filter3, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter3, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:21.976 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:21.976 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:21.976 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:21.976 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:21.976 [debug] [:some_element] Evaluating playback buffer
     
     11:17:21.998 [debug] Element start: :name
     node: ,
     module: Membrane.Core.ElementTest.SomeElement,
     element options: %{},
     
     
     11:17:21.998 [debug] [:name] Initializing element: Membrane.Core.ElementTest.SomeElement, options: %{}
     
     11:17:21.998 [debug] [:name] Element initialized: Membrane.Core.ElementTest.SomeElement
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: nil, terminating?: false}]
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.025 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.025 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>},
     
     
     11:17:22.025 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}
     
     11:17:22.025 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.025 [debug] [pipeline@<0.700.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.025 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.025 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter3, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: nil, terminating?: false}]
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Starting child: name: :endpoint, module: Membrane.Testing.Endpoint
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Element start: :endpoint
     node: ,
     module: Membrane.Testing.Endpoint,
     element options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.025 [debug] [:endpoint] Initializing element: Membrane.Testing.Endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.025 [debug] [:endpoint] Element initialized: Membrane.Testing.Endpoint
     
     11:17:22.025 [debug] [pipeline@<0.702.0>] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.026 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.026 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.026 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.026 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Starting child: name: :filter3, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.026 [debug] [pipeline@<0.702.0>] Element start: :filter3
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.026 [debug] [:filter3] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.026 [debug] [:filter3] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.086 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.086 [debug] [:endpoint] Element handle link on pad :output with pad :input of child :filter1
     
     11:17:22.086 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.086 [debug] [:filter1] Element handle link on pad :input with pad :output of child :endpoint
     
     11:17:22.086 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.086 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.086 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.086 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.086 [debug] [:filter2] Element handle link on pad :output with pad :input of child :filter3
     
     11:17:22.086 [debug] [:filter3] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.087 [debug] [:filter3] Element handle link on pad :output with pad :input of child :endpoint
     
     11:17:22.087 [debug] [:endpoint] Element handle link on pad :input with pad :output of child :filter3
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Spec #Reference<0.3642608924.1448083457.157826> linked internally
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Spec #Reference<0.3642608924.1448083457.157840> linked internally
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Spec playback init #Reference<0.3642608924.1448083457.157826> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, pid: #PID<0.763.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.762.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.764.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>}, pid: #PID<0.763.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Spec playback init #Reference<0.3642608924.1448083457.157840> %{endpoint: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.765.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}, filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.766.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.767.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter3, options: nil, pid: #PID<0.768.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.762.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.765.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.766.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.700.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.764.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.767.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.087 [debug] [pipeline@<0.702.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter3, options: nil, pid: #PID<0.768.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157840>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Changing playback state from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.702.0>] Changing playback state from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Playback state changed from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Changing playback state from prepared to playing
     
     11:17:22.106 [debug] [pipeline@<0.702.0>] Playback state changed from stopped to prepared
     
     11:17:22.106 [debug] [pipeline@<0.702.0>] Changing playback state from prepared to playing
     
     11:17:22.106 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.106 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.106 [debug] [:source] Evaluating playback buffer
     
     11:17:22.106 [debug] [:endpoint] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.106 [debug] [:endpoint] Evaluating playback buffer
     
     11:17:22.106 [debug] [pipeline@<0.700.0>] Playback state changed from prepared to playing
     
     11:17:22.106 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter3] Evaluating playback buffer
     
     11:17:22.106 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [pipeline@<0.702.0>] Playback state changed from prepared to playing
     
     11:17:22.107 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter3] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:filter3] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.107 [debug] [:endpoint] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.127 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.127 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.127 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.128 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.788.0>},
     process options: []
     
     
     11:17:22.128 [debug] [pipeline@<0.789.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.129 [debug] [pipeline@<0.789.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: nil, terminating?: false}]
     
     11:17:22.129 [debug] [pipeline@<0.789.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.129 [debug] [pipeline@<0.789.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.130 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.130 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>},
     
     
     11:17:22.130 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}
     
     11:17:22.130 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.130 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.130 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.130 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.130 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.130 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.130 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.130 [debug] [pipeline@<0.789.0>] Spec #Reference<0.3642608924.1448083457.157903> linked internally
     
     11:17:22.131 [debug] [pipeline@<0.789.0>] Spec playback init #Reference<0.3642608924.1448083457.157903> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, pid: #PID<0.793.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.792.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.794.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.131 [debug] [pipeline@<0.789.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>}, pid: #PID<0.793.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.792.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.794.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.157903>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Changing playback state from stopped to prepared
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Playback state changed from stopped to prepared
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Changing playback state from prepared to playing
     
     11:17:22.132 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.132 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.132 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:source] Evaluating playback buffer
     
     11:17:22.132 [debug] [pipeline@<0.789.0>] Playback state changed from prepared to playing
     
     11:17:22.132 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.132 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.132 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.132 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.133 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.798.0>},
     process options: []
     
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: nil, terminating?: false}]
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.133 [debug] [pipeline@<0.799.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.134 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.134 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>},
     
     
     11:17:22.134 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}
     
     11:17:22.134 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.134 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.134 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.134 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.134 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.134 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.134 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Spec #Reference<0.3642608924.1448083457.158014> linked internally
     
     11:17:22.134 [debug] [pipeline@<0.799.0>] Spec playback init #Reference<0.3642608924.1448083457.158014> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, pid: #PID<0.802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.801.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>}, pid: #PID<0.802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.801.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158014>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Changing playback state from stopped to prepared
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Playback state changed from stopped to prepared
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Changing playback state from prepared to playing
     
     11:17:22.135 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.135 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.135 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:source] Evaluating playback buffer
     
     11:17:22.135 [debug] [pipeline@<0.799.0>] Playback state changed from prepared to playing
     
     11:17:22.135 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.135 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.135 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.135 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.136 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.807.0>},
     process options: []
     
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: nil, terminating?: false}]
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.136 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.136 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.136 [debug] [pipeline@<0.808.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>},
     
     
     11:17:22.136 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}
     
     11:17:22.137 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.137 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.137 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.137 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.137 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.137 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.137 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Spec #Reference<0.3642608924.1448083457.158072> linked internally
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Spec playback init #Reference<0.3642608924.1448083457.158072> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, pid: #PID<0.811.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.810.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.813.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>}, pid: #PID<0.811.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.810.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.813.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Changing playback state from stopped to prepared
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Playback state changed from stopped to prepared
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Changing playback state from prepared to playing
     
     11:17:22.137 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.137 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.137 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.137 [debug] [:source] Evaluating playback buffer
     
     11:17:22.137 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.137 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.137 [debug] [pipeline@<0.808.0>] Playback state changed from prepared to playing
     
     11:17:22.137 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.138 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.138 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.138 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.138 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.817.0>},
     process options: []
     
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: nil, terminating?: false}]
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.138 [debug] [pipeline@<0.818.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.138 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.138 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>},
     
     
     11:17:22.139 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}
     
     11:17:22.139 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.139 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.139 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.139 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.139 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.139 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.139 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Spec #Reference<0.3642608924.1448083463.155418> linked internally
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Spec playback init #Reference<0.3642608924.1448083463.155418> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, pid: #PID<0.821.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.820.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.822.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>}, pid: #PID<0.821.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.820.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.822.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155418>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Changing playback state from stopped to prepared
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Playback state changed from stopped to prepared
     
     11:17:22.139 [debug] [pipeline@<0.818.0>] Changing playback state from prepared to playing
     
     11:17:22.139 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.139 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.140 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.140 [debug] [:source] Evaluating playback buffer
     
     11:17:22.140 [debug] [pipeline@<0.818.0>] Playback state changed from prepared to playing
     
     11:17:22.140 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.140 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.140 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.216 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.763.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.700.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.708.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.216 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.793.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.789.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.790.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.216 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.763.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.700.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.708.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.216 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.802.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.799.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.800.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.216 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.216 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.798.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.803.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.801.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.799.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.800.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.216 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.689.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.764.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.762.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.700.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.708.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.217 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.793.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.789.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.790.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.217 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.788.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.794.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.792.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.789.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.790.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.217 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.217 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.802.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.799.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.800.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.217 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.219 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.811.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.808.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.809.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.219 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.811.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.808.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.809.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.219 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.219 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.219 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.807.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.813.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.810.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.808.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.809.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.219 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.229 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.833.0>},
     process options: []
     
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: nil, terminating?: false}]
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:22.229 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:22.229 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting child: name: :filter, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Element start: :filter
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:22.229 [debug] [:filter] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:22.229 [debug] [:filter] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Starting child: name: :source, module: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Element start: :source
     node: ,
     module: Membrane.Integration.AutoDemandsTest.PushSource,
     element options: nil,
     
     
     11:17:22.229 [debug] [:source] Initializing element: Membrane.Integration.AutoDemandsTest.PushSource, options: nil
     
     11:17:22.229 [debug] [:source] Element initialized: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:22.229 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.229 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.229 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.229 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.229 [debug] [pipeline@<0.834.0>] Spec #Reference<0.3642608924.1448083459.156072> linked internally
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Spec playback init #Reference<0.3642608924.1448083459.156072> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.837.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.836.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.838.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.837.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.836.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.838.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156072>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Changing playback state from stopped to prepared
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Playback state changed from stopped to prepared
     
     11:17:22.230 [debug] [pipeline@<0.834.0>] Changing playback state from prepared to playing
     
     11:17:22.230 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.230 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.230 [debug] [:source] Sending caps through pad :output
     Caps: :any
     
     
     11:17:22.230 [debug] [:source] Evaluating playback buffer
     
     11:17:22.231 [debug] [pipeline@<0.834.0>] Playback state changed from prepared to playing
     
     11:17:22.231 [debug] [:filter] Received caps on pad :input
     Caps: :any
     
     
     11:17:22.231 [debug] [:filter] Sending caps through pad :output
     Caps: :any
     
     
     11:17:22.231 [debug] [:sink] Received caps on pad :input
     Caps: :any
     
     
     11:17:22.241 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.241 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.241 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.241 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.821.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.818.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.819.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.241 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.241 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.821.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.818.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.819.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.241 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.241 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.817.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.822.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.820.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.818.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.819.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.241 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.243 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.849.0>},
     process options: []
     
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: nil, terminating?: false}]
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.243 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.243 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting child: name: :filter, module: Membrane.ElementTest.TestFilter
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Element start: :filter
     node: ,
     module: Membrane.ElementTest.TestFilter,
     element options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>},
     
     
     11:17:22.243 [debug] [:filter] Initializing element: Membrane.ElementTest.TestFilter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}
     
     11:17:22.243 [debug] [:filter] Element initialized: Membrane.ElementTest.TestFilter
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.243 [debug] [pipeline@<0.850.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.244 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.244 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.244 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:22.244 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.244 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.244 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Spec #Reference<0.3642608924.1448083459.156107> linked internally
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Spec playback init #Reference<0.3642608924.1448083459.156107> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, pid: #PID<0.853.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.852.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.854.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.ElementTest.TestFilter, name: :filter, options: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>}, pid: #PID<0.853.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.852.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.854.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156107>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Changing playback state from stopped to prepared
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Playback state changed from stopped to prepared
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Changing playback state from prepared to playing
     
     11:17:22.244 [debug] [:filter] Evaluating playback buffer
     
     11:17:22.244 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.244 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.244 [debug] [:source] Evaluating playback buffer
     
     11:17:22.244 [debug] [pipeline@<0.850.0>] Playback state changed from prepared to playing
     
     11:17:22.244 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.244 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.244 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.312 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.862.0>},
     process options: []
     
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}]
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.312 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.312 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:22.327 [debug] [pipeline@<0.863.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:22.336 [error] [:source] Toilet overflow.
     
     Reached the size of 96000, which is above toilet capacity (200)
     when storing data from output working in push mode. It means that some element in the pipeline
     processes the stream too slow or doesn't process it at all.
     To have control over amount of buffers being produced, consider using output in pull mode
     (see `Membrane.Pad.mode_t`).
     You can also try changing the `toilet_capacity` in `Membrane.ParentSpec.via_in/3`.
     
     
     11:17:22.350 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.853.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.350 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.351 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.853.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.351 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.351 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.854.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.852.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.351 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.372 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.372 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: nil, terminating?: false}]
     
     11:17:22.372 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.372 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.372 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.372 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.373 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.373 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.373 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.373 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.381 [debug] [pipeline@<0.834.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:22.381 [debug] [pipeline@<0.834.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:22.382 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:22.382 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:22.382 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.382 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:22.382 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:22.382 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.384 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.883.0>},
     process options: []
     
     
     11:17:22.384 [debug] [pipeline@<0.884.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}]
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :tee, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :tee
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
     element options: nil,
     
     
     11:17:22.385 [debug] [:tee] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandTee, options: nil
     
     11:17:22.385 [debug] [:tee] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:22.385 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:22.385 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :left_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :left_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.385 [debug] [:left_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.385 [debug] [:left_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :right_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :right_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:22.385 [debug] [:right_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:22.385 [debug] [:right_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [:source] Element handle link on pad :output with pad :input of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} with pad :input of child :left_sink
     
     11:17:22.385 [debug] [:left_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} with pad :input of child :right_sink
     
     11:17:22.385 [debug] [:right_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} of child :tee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec #Reference<0.3642608924.1448083463.155490> linked internally
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec playback init #Reference<0.3642608924.1448083463.155490> %{left_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, right_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, tee: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Playback state changed from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from prepared to playing
     
     11:17:22.386 [debug] [:right_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:left_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:source] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:right_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:left_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.394 [debug] [pipeline@<0.884.0>] Playback state changed from prepared to playing
     
     11:17:22.399 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: #PID<0.898.0>, module: Membrane.Integration.TimerTest.Pipeline, test_process: #PID<0.898.0>},
     process options: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing spec
     children: [element: Membrane.Integration.TimerTest.Element, bin: Membrane.Integration.TimerTest.Bin]
     links: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}]
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :element, module: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Element start: :element
     node: ,
     module: Membrane.Integration.TimerTest.Element,
     element options: nil,
     
     
     11:17:22.399 [debug] [:element] Initializing element: Membrane.Integration.TimerTest.Element, options: nil
     
     11:17:22.399 [debug] [:element] Element initialized: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :bin, module: Membrane.Integration.TimerTest.Bin
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Bin start: :bin
     node: ,
     module: Membrane.Integration.TimerTest.Bin,
     bin options: nil
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec #Reference<0.3642608924.1448083464.156227> linked internally
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec playback init #Reference<0.3642608924.1448083464.156227> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}, element: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from prepared to playing
     
     11:17:22.400 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:22.422 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.422 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.422 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked internally
     
     11:17:22.422 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156195> externally
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.422 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.422 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:22.434 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:22.434 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.435 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.435 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.435 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked externally
     
     11:17:22.435 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156195> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec #Reference<0.3642608924.1448083462.156962> linked internally
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec playback init #Reference<0.3642608924.1448083462.156962> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.435 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.435 [debug] [:source] Evaluating playback buffer
     
     11:17:22.435 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.436 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [pipeline@<0.863.0>] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.465 [debug] [:element] Evaluating playback buffer
     
     11:17:22.465 [debug] [:bin bin] Playback state changed from prepared to playing
     
     11:17:22.465 [debug] [pipeline@<0.899.0>] Playback state changed from prepared to playing
     
     11:17:22.499 [debug] [:name] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.499 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.748.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.499 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.499 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.499 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] [:some_element] Ignoring end of stream as start of stream hasn't arrived yet
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] Element start: :name
     node: ,
     module: Membrane.Core.ElementTest.SomeElement,
     element options: %{},
     
     
     11:17:22.504 [debug] [:name] Initializing element: Membrane.Core.ElementTest.SomeElement, options: %{}
     
     11:17:22.504 [debug] [:name] Element initialized: Membrane.Core.ElementTest.SomeElement
     
     11:17:22.504 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :normal,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.969.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.504 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.505 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.505 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:24.108 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     


  4) test buffers pass through auto-demand tee (Membrane.Integration.AutoDemandsTest)
     test/membrane/integration/auto_demands_test.exs:93
     Assertion failed, no matching message after 2000ms
     Showing 10 of 9008 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7991, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7992, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7993, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7994, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7995, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7996, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7997, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7998, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7999, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.884.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 8000, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/auto_demands_test.exs:109: anonymous fn/2 in Membrane.Integration.AutoDemandsTest."test buffers pass through auto-demand tee"/1
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/auto_demands_test.exs:108: (test)

     The following output was logged:
     
     11:17:22.384 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.883.0>},
     process options: []
     
     
     11:17:22.384 [debug] [pipeline@<0.884.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}]
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :tee, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :tee
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
     element options: nil,
     
     
     11:17:22.385 [debug] [:tee] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandTee, options: nil
     
     11:17:22.385 [debug] [:tee] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:22.385 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:22.385 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :left_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :left_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.385 [debug] [:left_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.385 [debug] [:left_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :right_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :right_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:22.385 [debug] [:right_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:22.385 [debug] [:right_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [:source] Element handle link on pad :output with pad :input of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} with pad :input of child :left_sink
     
     11:17:22.385 [debug] [:left_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} with pad :input of child :right_sink
     
     11:17:22.385 [debug] [:right_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} of child :tee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec #Reference<0.3642608924.1448083463.155490> linked internally
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec playback init #Reference<0.3642608924.1448083463.155490> %{left_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, right_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, tee: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Playback state changed from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from prepared to playing
     
     11:17:22.386 [debug] [:right_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:left_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:source] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:right_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:left_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.394 [debug] [pipeline@<0.884.0>] Playback state changed from prepared to playing
     
     11:17:22.399 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: #PID<0.898.0>, module: Membrane.Integration.TimerTest.Pipeline, test_process: #PID<0.898.0>},
     process options: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing spec
     children: [element: Membrane.Integration.TimerTest.Element, bin: Membrane.Integration.TimerTest.Bin]
     links: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}]
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :element, module: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Element start: :element
     node: ,
     module: Membrane.Integration.TimerTest.Element,
     element options: nil,
     
     
     11:17:22.399 [debug] [:element] Initializing element: Membrane.Integration.TimerTest.Element, options: nil
     
     11:17:22.399 [debug] [:element] Element initialized: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :bin, module: Membrane.Integration.TimerTest.Bin
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Bin start: :bin
     node: ,
     module: Membrane.Integration.TimerTest.Bin,
     bin options: nil
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec #Reference<0.3642608924.1448083464.156227> linked internally
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec playback init #Reference<0.3642608924.1448083464.156227> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}, element: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from prepared to playing
     
     11:17:22.400 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:22.422 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.422 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.422 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked internally
     
     11:17:22.422 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156195> externally
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.422 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.422 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:22.434 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:22.434 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.435 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.435 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.435 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked externally
     
     11:17:22.435 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156195> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec #Reference<0.3642608924.1448083462.156962> linked internally
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec playback init #Reference<0.3642608924.1448083462.156962> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.435 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.435 [debug] [:source] Evaluating playback buffer
     
     11:17:22.435 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.436 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [pipeline@<0.863.0>] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.465 [debug] [:element] Evaluating playback buffer
     
     11:17:22.465 [debug] [:bin bin] Playback state changed from prepared to playing
     
     11:17:22.465 [debug] [pipeline@<0.899.0>] Playback state changed from prepared to playing
     
     11:17:22.499 [debug] [:name] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.499 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.748.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.499 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.499 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.499 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] [:some_element] Ignoring end of stream as start of stream hasn't arrived yet
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] Element start: :name
     node: ,
     module: Membrane.Core.ElementTest.SomeElement,
     element options: %{},
     
     
     11:17:22.504 [debug] [:name] Initializing element: Membrane.Core.ElementTest.SomeElement, options: %{}
     
     11:17:22.504 [debug] [:name] Element initialized: Membrane.Core.ElementTest.SomeElement
     
     11:17:22.504 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :normal,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.969.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.504 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.505 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.505 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:24.108 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.108 [debug] [:filter3] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.108 [debug] [:endpoint] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.109 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.109 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.766.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.768.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.109 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter3,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.767.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.765.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.110 [debug] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         autodemand: true,
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Endpoint,
       name: :endpoint,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.768.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.766.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :endpoint
     }
     
     
     11:17:24.110 [debug] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter1,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.765.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.767.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.110 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.111 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.983.0>},
     process options: []
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Initializing spec
     children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}]
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :endpoint, module: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :endpoint
     node: ,
     module: Membrane.Testing.Endpoint,
     element options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.112 [debug] [:endpoint] Initializing element: Membrane.Testing.Endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.112 [debug] [:endpoint] Element initialized: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.112 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.112 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [:endpoint] Element handle link on pad :output with pad :input of child :filter
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :input with pad :output of child :endpoint
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :output with pad :input of child :endpoint
     
     11:17:24.113 [debug] [:endpoint] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec #Reference<0.3642608924.1448083457.158561> linked internally
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec playback init #Reference<0.3642608924.1448083457.158561> %{endpoint: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}, filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Playback state changed from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from prepared to playing
     
     11:17:24.113 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.113 [debug] [:endpoint] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.113 [debug] [:endpoint] Evaluating playback buffer
     
     11:17:24.113 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [pipeline@<0.984.0>] Playback state changed from prepared to playing
     
     11:17:24.114 [debug] [:endpoint] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.417 [debug] [:left_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:right_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:tee] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [warning] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :left_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155509>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.417 [debug] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     


  5) test Starting and transmitting buffers in simple, flat use case (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:15
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 7 of 7 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.863.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/bin_test.exs:326: anonymous fn/3 in Membrane.Core.BinTest.assert_buffers_flow_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/bin_test.exs:317: Membrane.Core.BinTest.assert_data_flows_through/3
       test/membrane/integration/bin_test.exs:30: (test)

     The following output was logged:
     
     11:17:22.312 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.862.0>},
     process options: []
     
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: nil, terminating?: false}]
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.312 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.312 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.312 [debug] [pipeline@<0.863.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:22.327 [debug] [pipeline@<0.863.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:22.336 [error] [:source] Toilet overflow.
     
     Reached the size of 96000, which is above toilet capacity (200)
     when storing data from output working in push mode. It means that some element in the pipeline
     processes the stream too slow or doesn't process it at all.
     To have control over amount of buffers being produced, consider using output in pull mode
     (see `Membrane.Pad.mode_t`).
     You can also try changing the `toilet_capacity` in `Membrane.ParentSpec.via_in/3`.
     
     
     11:17:22.350 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.350 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.853.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.350 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.351 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.853.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:22.351 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.351 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.ElementTest.TestFilter{target: #PID<0.849.0>},
       module: Membrane.ElementTest.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.854.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.852.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.850.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.851.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:22.351 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.372 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.372 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: nil, terminating?: false}]
     
     11:17:22.372 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.372 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.372 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.372 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.373 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.373 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:22.373 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:22.373 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:22.381 [debug] [pipeline@<0.834.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:22.381 [debug] [pipeline@<0.834.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:22.382 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:22.382 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:22.382 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.382 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:22.382 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:22.382 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.384 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.883.0>},
     process options: []
     
     
     11:17:22.384 [debug] [pipeline@<0.884.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: nil, terminating?: false}]
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :tee, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :tee
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
     element options: nil,
     
     
     11:17:22.385 [debug] [:tee] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandTee, options: nil
     
     11:17:22.385 [debug] [:tee] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:22.385 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:22.385 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :left_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :left_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:22.385 [debug] [:left_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:22.385 [debug] [:left_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Starting child: name: :right_sink, module: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Element start: :right_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:22.385 [debug] [:right_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:22.385 [debug] [:right_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:22.385 [debug] [:source] Element handle link on pad :output with pad :input of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} with pad :input of child :left_sink
     
     11:17:22.385 [debug] [:left_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} of child :tee
     
     11:17:22.385 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} with pad :input of child :right_sink
     
     11:17:22.385 [debug] [:right_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} of child :tee
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec #Reference<0.3642608924.1448083463.155490> linked internally
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Spec playback init #Reference<0.3642608924.1448083463.155490> %{left_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, right_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}, tee: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.890.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.891.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.889.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.385 [debug] [pipeline@<0.884.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.888.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155490>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Playback state changed from stopped to prepared
     
     11:17:22.386 [debug] [pipeline@<0.884.0>] Changing playback state from prepared to playing
     
     11:17:22.386 [debug] [:right_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:left_sink] Evaluating playback buffer
     
     11:17:22.386 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:source] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Evaluating playback buffer
     
     11:17:22.386 [debug] [:tee] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:right_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.386 [debug] [:left_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.394 [debug] [pipeline@<0.884.0>] Playback state changed from prepared to playing
     
     11:17:22.399 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: #PID<0.898.0>, module: Membrane.Integration.TimerTest.Pipeline, test_process: #PID<0.898.0>},
     process options: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing spec
     children: [element: Membrane.Integration.TimerTest.Element, bin: Membrane.Integration.TimerTest.Bin]
     links: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}]
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :element, module: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Element start: :element
     node: ,
     module: Membrane.Integration.TimerTest.Element,
     element options: nil,
     
     
     11:17:22.399 [debug] [:element] Initializing element: Membrane.Integration.TimerTest.Element, options: nil
     
     11:17:22.399 [debug] [:element] Element initialized: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :bin, module: Membrane.Integration.TimerTest.Bin
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Bin start: :bin
     node: ,
     module: Membrane.Integration.TimerTest.Bin,
     bin options: nil
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec #Reference<0.3642608924.1448083464.156227> linked internally
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec playback init #Reference<0.3642608924.1448083464.156227> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}, element: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from prepared to playing
     
     11:17:22.400 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:22.422 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.422 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.422 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked internally
     
     11:17:22.422 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156195> externally
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.422 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.422 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:22.434 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:22.434 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.435 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.435 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.435 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked externally
     
     11:17:22.435 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156195> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec #Reference<0.3642608924.1448083462.156962> linked internally
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec playback init #Reference<0.3642608924.1448083462.156962> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.435 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.435 [debug] [:source] Evaluating playback buffer
     
     11:17:22.435 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.436 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [pipeline@<0.863.0>] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.465 [debug] [:element] Evaluating playback buffer
     
     11:17:22.465 [debug] [:bin bin] Playback state changed from prepared to playing
     
     11:17:22.465 [debug] [pipeline@<0.899.0>] Playback state changed from prepared to playing
     
     11:17:22.499 [debug] [:name] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.499 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.748.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.499 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.499 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.499 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] [:some_element] Ignoring end of stream as start of stream hasn't arrived yet
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] Element start: :name
     node: ,
     module: Membrane.Core.ElementTest.SomeElement,
     element options: %{},
     
     
     11:17:22.504 [debug] [:name] Initializing element: Membrane.Core.ElementTest.SomeElement, options: %{}
     
     11:17:22.504 [debug] [:name] Element initialized: Membrane.Core.ElementTest.SomeElement
     
     11:17:22.504 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :normal,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.969.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.504 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.505 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.505 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:24.108 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.108 [debug] [:filter3] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.108 [debug] [:endpoint] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.109 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.109 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.766.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.768.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.109 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter3,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.767.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.765.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.110 [debug] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         autodemand: true,
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Endpoint,
       name: :endpoint,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.768.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.766.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :endpoint
     }
     
     
     11:17:24.110 [debug] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter1,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.765.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.767.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.110 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.111 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.983.0>},
     process options: []
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Initializing spec
     children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}]
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :endpoint, module: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :endpoint
     node: ,
     module: Membrane.Testing.Endpoint,
     element options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.112 [debug] [:endpoint] Initializing element: Membrane.Testing.Endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.112 [debug] [:endpoint] Element initialized: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.112 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.112 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [:endpoint] Element handle link on pad :output with pad :input of child :filter
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :input with pad :output of child :endpoint
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :output with pad :input of child :endpoint
     
     11:17:24.113 [debug] [:endpoint] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec #Reference<0.3642608924.1448083457.158561> linked internally
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec playback init #Reference<0.3642608924.1448083457.158561> %{endpoint: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}, filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Playback state changed from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from prepared to playing
     
     11:17:24.113 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.113 [debug] [:endpoint] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.113 [debug] [:endpoint] Evaluating playback buffer
     
     11:17:24.113 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [pipeline@<0.984.0>] Playback state changed from prepared to playing
     
     11:17:24.114 [debug] [:endpoint] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.417 [debug] [:left_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:right_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:tee] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [warning] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :left_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155509>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.417 [debug] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.417 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: [8001, 8002, 8003, 8004, 8005, 8006, 8007, 8008, 8009, 8010, 8011,
          8012, 8013, 8014, 8015, 8016, 8017, 8018, 8019, 8020, 8021, 8022, 8023,
          8024, 8025, 8026, 8027, 8028, 8029, 8030, 8031, 8032, 8033, 8034, 8035,
          8036, 8037, 8038, 8039, 8040, 8041, 8042, 8043, 8044, 8045, ...]
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.888.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.417 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.417 [warning] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
       name: :tee,
       pads_data: %{
         :input => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
           ],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.889.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.890.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -6960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.891.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.417 [debug] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.418 [warning] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :right_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1001, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1002, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1003, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1004, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1005, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1006, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1007, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1008, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1009, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1010, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1011, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1012, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1013, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1014, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1015, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1016, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1017, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1018, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1019, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1020, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1021, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 7000,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155511>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.418 [debug] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     


  6) test Integration with clocks handle_parent_notification/3 works for Bin (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:288
     ** (EXIT from #PID<0.993.0>) shutdown: :child_crash

     The following output was logged:
     
     11:17:24.437 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.993.0>},
     process options: []
     
     
     11:17:24.438 [debug] [pipeline@<0.994.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}]
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.439 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.439 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentBin,
     bin options: nil
     
     
     11:17:24.439 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.NotifyingParentElement, filter2: Membrane.Support.Bin.TestBins.NotifyingParentElement]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.440 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}]
     
     11:17:24.440 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.440 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.440 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.440 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.441 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.441 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.441 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.441 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083461.156051> linked internally
     
     11:17:24.441 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083461.156051> externally
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.441 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.441 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:24.441 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.441 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.990.0>},
     process options: []
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}]
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.442 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.442 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 10}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 10}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 10}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 10}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 9}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 9}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 9}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 9}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 8}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 8}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 8}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 8}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 7}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 7}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 7}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 7}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 6}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 6}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 6}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 6}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:24.443 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:24.443 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.443 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:24.443 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:24.444 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :output with pad :input of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :input with pad :output of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :output with pad :input of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :input with pad :output of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :output with pad :input of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :input with pad :output of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :output with pad :input of child {:filter, 10}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :input with pad :output of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.444 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 10}
     
     11:17:24.444 [debug] [pipeline@<0.1002.0>] Spec #Reference<0.3642608924.1448083459.156599> linked internally
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Spec playback init #Reference<0.3642608924.1448083459.156599> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 6} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 7} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 8} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 9} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 10} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Playback state changed from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from prepared to playing
     
     11:17:24.446 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 6}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 7}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 8}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 10}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.441 [error] GenServer #PID<0.997.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification(:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter1, {"filter1", "Some notification"}], []}
     State: %Membrane.Core.Bin.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.994.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1000.0>}}], module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, output: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}}, parent_pid: #PID<0.994.0>, pending_specs: %{#Reference<0.3642608924.1448083461.156051> => %{links: %{{#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156065>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: {Membrane.Bin, :itself}, pad_info: %{}, pad_props: %{}, pad_ref: :input, pad_spec: :input, pid: #PID<0.997.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}}}, {#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156066>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_sp (truncated)
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec #Reference<0.3642608924.1448083461.156043> linked internally
     
     11:17:24.450 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec playback init #Reference<0.3642608924.1448083461.156043> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Changing playback state from stopped to prepared
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
.

  7) test Starting and transmitting buffers when pipeline has only one element being a padless bin (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:104
     ** (EXIT from #PID<0.1027.0>) shutdown: :child_crash

     The following output was logged:
     
     11:17:24.451 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}], links: [], module: :default, test_process: #PID<0.1027.0>},
     process options: []
     
     
     11:17:24.451 [debug] [pipeline@<0.1028.0>] Initializing spec
     children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}]
     links: []
     
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestPadlessBin,
     bin options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}
     
     
     11:17:24.452 [debug] [:test_bin bin] Initializing spec
     children: [source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.452 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.452 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.452 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.452 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.452 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:source] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.452 [debug] [:sink] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked internally
     
     11:17:24.452 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083459.156826> externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083459.156826> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec #Reference<0.3642608924.1448083459.156823> linked internally
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec playback init #Reference<0.3642608924.1448083459.156823> %{test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Changing playback state from stopped to prepared
     
     11:17:24.452 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.453 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.453 [debug] [:source] Evaluating playback buffer
     
     11:17:24.453 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [pipeline@<0.1002.0>] Playback state changed from prepared to playing
     
     11:17:24.453 [error] GenServer #PID<0.1030.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1028.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1032.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1033.0>}}], module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, pads_data: %{}, pads_info: %{}, parent_pid: #PID<0.1028.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1029.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1031.0>, latency: 0, parent_clock: #PID<0.1029.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.454 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.454 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1033.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.454 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.454 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     


  8) test Starting and transmitting buffers when bin is a sink bin (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:126
     ** (EXIT from #PID<0.1036.0>) shutdown: :child_crash

     The following output was logged:
     
     11:17:24.456 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1032.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.456 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.457 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1036.0>},
     process options: []
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}]
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestSinkBin
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestSinkBin,
     bin options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}
     
     
     11:17:24.457 [debug] [:test_bin bin] Initializing spec
     children: [filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.458 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}]
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.458 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.458 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.458 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.458 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.458 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked internally
     
     11:17:24.458 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156610> externally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.458 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.458 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.458 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.458 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.458 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked externally
     
     11:17:24.458 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156610> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec #Reference<0.3642608924.1448083464.156607> linked internally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec playback init #Reference<0.3642608924.1448083464.156607> %{source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:source] Evaluating playback buffer
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from prepared to playing
     
     11:17:24.459 [error] GenServer #PID<0.1039.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1037.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1041.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1042.0>}}], module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}}, parent_pid: #PID<0.1037.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1038.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1040.0>, latency: 0, parent_clock: #PID<0.1038.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.460 [debug] [:filter] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.460 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     


  9) test Stopping timer from handle_tick (Membrane.Integration.TimerTest)
     test/membrane/integration/timer_test.exs:58
     Assertion failed, no matching message after 2000ms
     Showing 4 of 4 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {:tick, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {:tick, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.899.0>, {:playback_state_changed, :stopped, :prepared}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {:tick, ^element_name_value}}}
       value:   :pipeline_tick

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {:tick, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.899.0>,
                 {:handle_other, {Membrane.Core.Message, :parent_notification, [:element, :tick], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {:tick, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.899.0>, {:handle_child_notification, {:tick, :bin}}}
     stacktrace:
       test/membrane/integration/timer_test.exs:66: (test)

     The following output was logged:
     
     11:17:22.399 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: #PID<0.898.0>, module: Membrane.Integration.TimerTest.Pipeline, test_process: #PID<0.898.0>},
     process options: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing spec
     children: [element: Membrane.Integration.TimerTest.Element, bin: Membrane.Integration.TimerTest.Bin]
     links: []
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: nil, terminating?: false}]
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :element, module: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Element start: :element
     node: ,
     module: Membrane.Integration.TimerTest.Element,
     element options: nil,
     
     
     11:17:22.399 [debug] [:element] Initializing element: Membrane.Integration.TimerTest.Element, options: nil
     
     11:17:22.399 [debug] [:element] Element initialized: Membrane.Integration.TimerTest.Element
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Starting child: name: :bin, module: Membrane.Integration.TimerTest.Bin
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Bin start: :bin
     node: ,
     module: Membrane.Integration.TimerTest.Bin,
     bin options: nil
     
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec #Reference<0.3642608924.1448083464.156227> linked internally
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Spec playback init #Reference<0.3642608924.1448083464.156227> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}, element: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.TimerTest.Bin, name: :bin, options: nil, pid: #PID<0.902.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.TimerTest.Element, name: :element, options: nil, pid: #PID<0.901.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156227>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:22.399 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Playback state changed from stopped to prepared
     
     11:17:22.399 [debug] [pipeline@<0.899.0>] Changing playback state from prepared to playing
     
     11:17:22.400 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:22.422 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:22.422 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:22.422 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked internally
     
     11:17:22.422 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156195> externally
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:22.422 [debug] [pipeline@<0.863.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:22.422 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:22.422 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:22.434 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:22.434 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:22.434 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:22.434 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:22.435 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:22.435 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:22.435 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156195> linked externally
     
     11:17:22.435 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156195> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.879.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.880.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156195>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec #Reference<0.3642608924.1448083462.156962> linked internally
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Spec playback init #Reference<0.3642608924.1448083462.156962> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.865.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.905.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.870.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.156962>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:22.435 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Playback state changed from stopped to prepared
     
     11:17:22.435 [debug] [pipeline@<0.863.0>] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:sink] Evaluating playback buffer
     
     11:17:22.435 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:22.435 [debug] [:filter1] Evaluating playback buffer
     
     11:17:22.435 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.435 [debug] [:source] Evaluating playback buffer
     
     11:17:22.435 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Evaluating playback buffer
     
     11:17:22.436 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.436 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [pipeline@<0.863.0>] Playback state changed from prepared to playing
     
     11:17:22.436 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:22.465 [debug] [:element] Evaluating playback buffer
     
     11:17:22.465 [debug] [:bin bin] Playback state changed from prepared to playing
     
     11:17:22.465 [debug] [pipeline@<0.899.0>] Playback state changed from prepared to playing
     
     11:17:22.499 [debug] [:name] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:22.499 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.748.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.499 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.499 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.499 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.500 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.500 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.502 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.502 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.502 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.503 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.503 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] [:some_element] Ignoring end of stream as start of stream hasn't arrived yet
     
     11:17:22.503 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.503 [debug] Element start: :name
     node: ,
     module: Membrane.Core.ElementTest.SomeElement,
     element options: %{},
     
     
     11:17:22.504 [debug] [:name] Initializing element: Membrane.Core.ElementTest.SomeElement, options: %{}
     
     11:17:22.504 [debug] [:name] Element initialized: Membrane.Core.ElementTest.SomeElement
     
     11:17:22.504 [warning] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :normal,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Core.ElementTest.SomeElement,
       name: :name,
       pads_data: %{},
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.969.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: nil,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:22.504 [debug] [:name] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.504 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.504 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.504 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:22.504 [debug] [:some_element] Evaluating playback buffer
     
     11:17:22.505 [debug] [:some_element] Initializing element: Membrane.Core.ElementTest.Filter, options: nil
     
     11:17:22.505 [debug] [:some_element] Element initialized: Membrane.Core.ElementTest.Filter
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :output with pad :input of child :other
     
     11:17:22.505 [debug] [:some_element] Element handle link on pad :input with pad :output of child :other
     
     11:17:24.108 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.108 [debug] [:filter3] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.108 [debug] [:endpoint] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.109 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.109 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.766.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.768.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.109 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter3,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.767.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.765.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.110 [debug] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         autodemand: true,
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Endpoint,
       name: :endpoint,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.768.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.766.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :endpoint
     }
     
     
     11:17:24.110 [debug] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.110 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter1,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.765.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.767.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.702.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.722.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.110 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.111 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.983.0>},
     process options: []
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Initializing spec
     children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}]
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :endpoint, module: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :endpoint
     node: ,
     module: Membrane.Testing.Endpoint,
     element options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.112 [debug] [:endpoint] Initializing element: Membrane.Testing.Endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.112 [debug] [:endpoint] Element initialized: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.112 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.112 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [:endpoint] Element handle link on pad :output with pad :input of child :filter
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :input with pad :output of child :endpoint
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :output with pad :input of child :endpoint
     
     11:17:24.113 [debug] [:endpoint] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec #Reference<0.3642608924.1448083457.158561> linked internally
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec playback init #Reference<0.3642608924.1448083457.158561> %{endpoint: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}, filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Playback state changed from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from prepared to playing
     
     11:17:24.113 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.113 [debug] [:endpoint] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.113 [debug] [:endpoint] Evaluating playback buffer
     
     11:17:24.113 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [pipeline@<0.984.0>] Playback state changed from prepared to playing
     
     11:17:24.114 [debug] [:endpoint] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.417 [debug] [:left_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:right_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:tee] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [warning] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :left_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155509>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.417 [debug] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.417 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: [8001, 8002, 8003, 8004, 8005, 8006, 8007, 8008, 8009, 8010, 8011,
          8012, 8013, 8014, 8015, 8016, 8017, 8018, 8019, 8020, 8021, 8022, 8023,
          8024, 8025, 8026, 8027, 8028, 8029, 8030, 8031, 8032, 8033, 8034, 8035,
          8036, 8037, 8038, 8039, 8040, 8041, 8042, 8043, 8044, 8045, ...]
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.888.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.417 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.417 [warning] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
       name: :tee,
       pads_data: %{
         :input => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
           ],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.889.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.890.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -6960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.891.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.417 [debug] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.418 [warning] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :right_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1001, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1002, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1003, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1004, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1005, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1006, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1007, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1008, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1009, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1010, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1011, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1012, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1013, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1014, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1015, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1016, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1017, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1018, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1019, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1020, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1021, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 7000,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155511>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.418 [debug] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.880.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.863.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.864.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.437 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.879.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.863.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.864.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.437 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.993.0>},
     process options: []
     
     
     11:17:24.438 [debug] [pipeline@<0.994.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}]
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.439 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.439 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentBin,
     bin options: nil
     
     
     11:17:24.439 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.NotifyingParentElement, filter2: Membrane.Support.Bin.TestBins.NotifyingParentElement]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.440 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}]
     
     11:17:24.440 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.440 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.440 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.440 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.441 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.441 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.441 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.441 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083461.156051> linked internally
     
     11:17:24.441 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083461.156051> externally
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.441 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.441 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:24.441 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.441 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.990.0>},
     process options: []
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}]
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.442 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.442 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 10}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 10}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 10}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 10}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 9}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 9}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 9}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 9}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 8}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 8}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 8}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 8}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 7}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 7}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 7}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 7}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 6}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 6}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 6}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 6}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:24.443 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:24.443 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.443 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:24.443 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:24.444 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :output with pad :input of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :input with pad :output of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :output with pad :input of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :input with pad :output of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :output with pad :input of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :input with pad :output of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :output with pad :input of child {:filter, 10}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :input with pad :output of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.444 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 10}
     
     11:17:24.444 [debug] [pipeline@<0.1002.0>] Spec #Reference<0.3642608924.1448083459.156599> linked internally
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Spec playback init #Reference<0.3642608924.1448083459.156599> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 6} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 7} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 8} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 9} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 10} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Playback state changed from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from prepared to playing
     
     11:17:24.446 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 6}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 7}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 8}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 10}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.441 [error] GenServer #PID<0.997.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification(:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter1, {"filter1", "Some notification"}], []}
     State: %Membrane.Core.Bin.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.994.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1000.0>}}], module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, output: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}}, parent_pid: #PID<0.994.0>, pending_specs: %{#Reference<0.3642608924.1448083461.156051> => %{links: %{{#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156065>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: {Membrane.Bin, :itself}, pad_info: %{}, pad_props: %{}, pad_ref: :input, pad_spec: :input, pid: #PID<0.997.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}}}, {#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156066>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_sp (truncated)
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec #Reference<0.3642608924.1448083461.156043> linked internally
     
     11:17:24.450 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec playback init #Reference<0.3642608924.1448083461.156043> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Changing playback state from stopped to prepared
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
       name: :filter2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: nil,
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.999.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.997.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.998.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.450 [debug] Bin start: :name
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:24.450 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
       name: :filter1,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: nil,
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1000.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.997.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
         q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
       },
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.998.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:name bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.451 [debug] [:name bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156793>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156793>, sync: nil, terminating?: false}]
     
     11:17:24.451 [debug] [:name bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.451 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.451 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.451 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.451 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.451 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.451 [debug] [:name bin] Spec #Reference<0.3642608924.1448083459.156793> linked internally
     
     11:17:24.451 [debug] [:name bin] Linking spec #Reference<0.3642608924.1448083459.156793> externally
     
     11:17:24.451 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.451 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.451 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}], links: [], module: :default, test_process: #PID<0.1027.0>},
     process options: []
     
     
     11:17:24.451 [debug] [pipeline@<0.1028.0>] Initializing spec
     children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}]
     links: []
     
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestPadlessBin,
     bin options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}
     
     
     11:17:24.452 [debug] [:test_bin bin] Initializing spec
     children: [source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.452 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.452 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.452 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.452 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.452 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:source] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.452 [debug] [:sink] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked internally
     
     11:17:24.452 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083459.156826> externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083459.156826> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec #Reference<0.3642608924.1448083459.156823> linked internally
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec playback init #Reference<0.3642608924.1448083459.156823> %{test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Changing playback state from stopped to prepared
     
     11:17:24.452 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.453 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.453 [debug] [:source] Evaluating playback buffer
     
     11:17:24.453 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [pipeline@<0.1002.0>] Playback state changed from prepared to playing
     
     11:17:24.453 [error] GenServer #PID<0.1030.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1028.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1032.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1033.0>}}], module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, pads_data: %{}, pads_info: %{}, parent_pid: #PID<0.1028.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1029.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1031.0>, latency: 0, parent_clock: #PID<0.1029.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.454 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.454 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1033.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.454 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.454 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.456 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1032.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.456 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.457 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1036.0>},
     process options: []
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}]
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestSinkBin
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestSinkBin,
     bin options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}
     
     
     11:17:24.457 [debug] [:test_bin bin] Initializing spec
     children: [filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.458 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}]
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.458 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.458 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.458 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.458 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.458 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked internally
     
     11:17:24.458 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156610> externally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.458 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.458 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.458 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.458 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.458 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked externally
     
     11:17:24.458 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156610> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec #Reference<0.3642608924.1448083464.156607> linked internally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec playback init #Reference<0.3642608924.1448083464.156607> %{source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:source] Evaluating playback buffer
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from prepared to playing
     
     11:17:24.459 [error] GenServer #PID<0.1039.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1037.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1041.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1042.0>}}], module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}}, parent_pid: #PID<0.1037.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1038.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1040.0>, latency: 0, parent_clock: #PID<0.1038.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.460 [debug] [:filter] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.460 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.461 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1043.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1042.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1039.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1040.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.461 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.461 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1041.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1039.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1040.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.461 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.463 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1046.0>},
     process options: []
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.464 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.464 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}
     
     
     11:17:24.464 [debug] [:test_bin bin] Initializing spec
     children: [filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [:test_bin bin] Bin start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.464 [debug] [:filter1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.467 [debug] [:filter1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}]
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} of child :filter2
     
     11:17:24.467 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} of child :filter1
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked internally
     
     11:17:24.467 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156076> externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156076> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.468 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}]
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} of child :filter2
     
     11:17:24.468 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} of child :filter1
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked internally
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156096> externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156096> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}
     
     11:17:24.468 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked internally
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156120> externally
     
     11:17:24.468 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked internally
     
     11:17:24.468 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156121> externally
     
     11:17:24.468 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.468 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.469 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>} of child :filter2
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} of child :filter2
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked externally
     
     11:17:24.469 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156120> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked externally
     
     11:17:24.469 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156121> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083460.156071> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083460.156071> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}
     
     11:17:24.469 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}
     
     11:17:24.469 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked internally
     
     11:17:24.469 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083458.156392> externally
     
     11:17:24.469 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}
     
     11:17:24.469 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156388> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156393> externally
     
     11:17:24.469 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083458.156400> externally
     
     11:17:24.469 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>} of child :test_bin
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>} with pad :output of child :source
     
     11:17:24.470 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked externally
     
     11:17:24.470 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083458.156392> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156388> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} with pad :input of child :sink
     
     11:17:24.470 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} of child :filter2
     
     11:17:24.470 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked externally
     
     11:17:24.470 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083458.156400> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156393> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec #Reference<0.3642608924.1448083460.156065> linked internally
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec playback init #Reference<0.3642608924.1448083460.156065> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter1 bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:24.472 [debug] [:filter1 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.472 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:source] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [:filter1 bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [pipeline@<0.1047.0>] Playback state changed from prepared to playing
     


 10) test Starting and transmitting buffers with one endpoint and filter (Membrane.Core.EndpointTest)
     test/membrane/integration/endpoint_test.exs:13
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 9 of 9 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>, {:handle_element_start_of_stream, {:filter, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>, {:handle_element_end_of_stream, {:filter, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:endpoint, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :endpoint,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:endpoint, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.984.0>, {:handle_element_end_of_stream, {:endpoint, :input}}}
     stacktrace:
       test/membrane/integration/endpoint_test.exs:62: anonymous fn/3 in Membrane.Core.EndpointTest.assert_data_flows_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/endpoint_test.exs:61: Membrane.Core.EndpointTest.assert_data_flows_through/3
       test/membrane/integration/endpoint_test.exs:28: (test)

     The following output was logged:
     
     11:17:24.111 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.983.0>},
     process options: []
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Initializing spec
     children: [endpoint: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, filter: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :endpoint, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :endpoint, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.111 [debug] [pipeline@<0.984.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: nil, terminating?: false}]
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :endpoint, module: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :endpoint
     node: ,
     module: Membrane.Testing.Endpoint,
     element options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.112 [debug] [:endpoint] Initializing element: Membrane.Testing.Endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.112 [debug] [:endpoint] Element initialized: Membrane.Testing.Endpoint
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [pipeline@<0.984.0>] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.112 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.112 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.112 [debug] [:endpoint] Element handle link on pad :output with pad :input of child :filter
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :input with pad :output of child :endpoint
     
     11:17:24.112 [debug] [:filter] Element handle link on pad :output with pad :input of child :endpoint
     
     11:17:24.113 [debug] [:endpoint] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec #Reference<0.3642608924.1448083457.158561> linked internally
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Spec playback init #Reference<0.3642608924.1448083457.158561> %{endpoint: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}, filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Endpoint, name: :endpoint, options: %Membrane.Testing.Endpoint{autodemand: true, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.986.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.987.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158561>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Playback state changed from stopped to prepared
     
     11:17:24.113 [debug] [pipeline@<0.984.0>] Changing playback state from prepared to playing
     
     11:17:24.113 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.113 [debug] [:endpoint] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.113 [debug] [:endpoint] Evaluating playback buffer
     
     11:17:24.113 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.114 [debug] [pipeline@<0.984.0>] Playback state changed from prepared to playing
     
     11:17:24.114 [debug] [:endpoint] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.417 [debug] [:left_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:right_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:tee] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.417 [warning] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :left_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155509>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.417 [debug] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.417 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: [8001, 8002, 8003, 8004, 8005, 8006, 8007, 8008, 8009, 8010, 8011,
          8012, 8013, 8014, 8015, 8016, 8017, 8018, 8019, 8020, 8021, 8022, 8023,
          8024, 8025, 8026, 8027, 8028, 8029, 8030, 8031, 8032, 8033, 8034, 8035,
          8036, 8037, 8038, 8039, 8040, 8041, 8042, 8043, 8044, 8045, ...]
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.888.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.417 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.417 [warning] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
       name: :tee,
       pads_data: %{
         :input => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
           ],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.889.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.890.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -6960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.891.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.417 [debug] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.418 [warning] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :right_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1001, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1002, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1003, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1004, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1005, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1006, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1007, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1008, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1009, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1010, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1011, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1012, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1013, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1014, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1015, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1016, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1017, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1018, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1019, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1020, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1021, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 7000,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155511>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.418 [debug] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.880.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.863.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.864.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.437 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.879.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.863.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.864.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.437 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.993.0>},
     process options: []
     
     
     11:17:24.438 [debug] [pipeline@<0.994.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}]
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.439 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.439 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentBin,
     bin options: nil
     
     
     11:17:24.439 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.NotifyingParentElement, filter2: Membrane.Support.Bin.TestBins.NotifyingParentElement]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.440 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}]
     
     11:17:24.440 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.440 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.440 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.440 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.441 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.441 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.441 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.441 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083461.156051> linked internally
     
     11:17:24.441 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083461.156051> externally
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.441 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.441 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:24.441 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.441 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.990.0>},
     process options: []
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}]
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.442 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.442 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 10}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 10}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 10}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 10}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 9}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 9}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 9}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 9}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 8}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 8}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 8}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 8}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 7}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 7}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 7}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 7}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 6}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 6}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 6}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 6}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:24.443 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:24.443 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.443 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:24.443 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:24.444 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :output with pad :input of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :input with pad :output of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :output with pad :input of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :input with pad :output of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :output with pad :input of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :input with pad :output of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :output with pad :input of child {:filter, 10}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :input with pad :output of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.444 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 10}
     
     11:17:24.444 [debug] [pipeline@<0.1002.0>] Spec #Reference<0.3642608924.1448083459.156599> linked internally
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Spec playback init #Reference<0.3642608924.1448083459.156599> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 6} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 7} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 8} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 9} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 10} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Playback state changed from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from prepared to playing
     
     11:17:24.446 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 6}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 7}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 8}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 10}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.441 [error] GenServer #PID<0.997.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification(:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter1, {"filter1", "Some notification"}], []}
     State: %Membrane.Core.Bin.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.994.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1000.0>}}], module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, output: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}}, parent_pid: #PID<0.994.0>, pending_specs: %{#Reference<0.3642608924.1448083461.156051> => %{links: %{{#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156065>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: {Membrane.Bin, :itself}, pad_info: %{}, pad_props: %{}, pad_ref: :input, pad_spec: :input, pid: #PID<0.997.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}}}, {#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156066>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_sp (truncated)
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec #Reference<0.3642608924.1448083461.156043> linked internally
     
     11:17:24.450 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec playback init #Reference<0.3642608924.1448083461.156043> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Changing playback state from stopped to prepared
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
       name: :filter2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: nil,
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.999.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.997.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.998.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.450 [debug] Bin start: :name
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:24.450 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
       name: :filter1,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: nil,
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1000.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.997.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
         q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
       },
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.998.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:name bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.451 [debug] [:name bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156793>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156793>, sync: nil, terminating?: false}]
     
     11:17:24.451 [debug] [:name bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.451 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.451 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.451 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.451 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.451 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.451 [debug] [:name bin] Spec #Reference<0.3642608924.1448083459.156793> linked internally
     
     11:17:24.451 [debug] [:name bin] Linking spec #Reference<0.3642608924.1448083459.156793> externally
     
     11:17:24.451 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.451 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.451 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}], links: [], module: :default, test_process: #PID<0.1027.0>},
     process options: []
     
     
     11:17:24.451 [debug] [pipeline@<0.1028.0>] Initializing spec
     children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}]
     links: []
     
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestPadlessBin,
     bin options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}
     
     
     11:17:24.452 [debug] [:test_bin bin] Initializing spec
     children: [source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.452 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.452 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.452 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.452 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.452 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:source] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.452 [debug] [:sink] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked internally
     
     11:17:24.452 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083459.156826> externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083459.156826> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec #Reference<0.3642608924.1448083459.156823> linked internally
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec playback init #Reference<0.3642608924.1448083459.156823> %{test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Changing playback state from stopped to prepared
     
     11:17:24.452 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.453 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.453 [debug] [:source] Evaluating playback buffer
     
     11:17:24.453 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [pipeline@<0.1002.0>] Playback state changed from prepared to playing
     
     11:17:24.453 [error] GenServer #PID<0.1030.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1028.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1032.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1033.0>}}], module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, pads_data: %{}, pads_info: %{}, parent_pid: #PID<0.1028.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1029.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1031.0>, latency: 0, parent_clock: #PID<0.1029.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.454 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.454 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1033.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.454 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.454 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.456 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1032.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.456 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.457 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1036.0>},
     process options: []
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}]
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestSinkBin
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestSinkBin,
     bin options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}
     
     
     11:17:24.457 [debug] [:test_bin bin] Initializing spec
     children: [filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.458 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}]
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.458 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.458 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.458 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.458 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.458 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked internally
     
     11:17:24.458 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156610> externally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.458 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.458 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.458 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.458 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.458 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked externally
     
     11:17:24.458 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156610> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec #Reference<0.3642608924.1448083464.156607> linked internally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec playback init #Reference<0.3642608924.1448083464.156607> %{source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:source] Evaluating playback buffer
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from prepared to playing
     
     11:17:24.459 [error] GenServer #PID<0.1039.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1037.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1041.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1042.0>}}], module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}}, parent_pid: #PID<0.1037.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1038.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1040.0>, latency: 0, parent_clock: #PID<0.1038.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.460 [debug] [:filter] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.460 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.461 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1043.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1042.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1039.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1040.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.461 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.461 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1041.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1039.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1040.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.461 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.463 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1046.0>},
     process options: []
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.464 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.464 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}
     
     
     11:17:24.464 [debug] [:test_bin bin] Initializing spec
     children: [filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [:test_bin bin] Bin start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.464 [debug] [:filter1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.467 [debug] [:filter1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}]
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} of child :filter2
     
     11:17:24.467 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} of child :filter1
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked internally
     
     11:17:24.467 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156076> externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156076> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.468 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}]
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} of child :filter2
     
     11:17:24.468 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} of child :filter1
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked internally
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156096> externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156096> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}
     
     11:17:24.468 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked internally
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156120> externally
     
     11:17:24.468 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked internally
     
     11:17:24.468 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156121> externally
     
     11:17:24.468 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.468 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.469 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>} of child :filter2
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} of child :filter2
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked externally
     
     11:17:24.469 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156120> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked externally
     
     11:17:24.469 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156121> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083460.156071> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083460.156071> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}
     
     11:17:24.469 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}
     
     11:17:24.469 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked internally
     
     11:17:24.469 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083458.156392> externally
     
     11:17:24.469 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}
     
     11:17:24.469 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156388> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156393> externally
     
     11:17:24.469 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083458.156400> externally
     
     11:17:24.469 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>} of child :test_bin
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>} with pad :output of child :source
     
     11:17:24.470 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked externally
     
     11:17:24.470 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083458.156392> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156388> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} with pad :input of child :sink
     
     11:17:24.470 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} of child :filter2
     
     11:17:24.470 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked externally
     
     11:17:24.470 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083458.156400> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156393> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec #Reference<0.3642608924.1448083460.156065> linked internally
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec playback init #Reference<0.3642608924.1448083460.156065> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter1 bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:24.472 [debug] [:filter1 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.472 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:source] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [:filter1 bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [pipeline@<0.1047.0>] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:element] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.474 [warning] [:element] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.TimerTest.Element,
       name: :element,
       pads_data: %{},
       pads_info: %{},
       parent_pid: #PID<0.899.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.900.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.474 [debug] [:element] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     


 11) test buffers pass through auto-demand filters; setup: %{direction: :up, factor: 1, filters: 10, payloads: 1..100000} (Membrane.Integration.AutoDemandsTest)
     test/membrane/integration/auto_demands_test.exs:53
     Assertion failed, no matching message after 2000ms
     Showing 10 of 99974 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99941, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99942, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99943, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99944, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99945, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99946, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99947, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99948, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99949, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1002.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99950, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/auto_demands_test.exs:82: anonymous fn/2 in Membrane.Integration.AutoDemandsTest."test buffers pass through auto-demand filters; setup: %{direction: :up, factor: 1, filters: 10, payloads: 1..100000}"/1
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/auto_demands_test.exs:81: (test)

     The following output was logged:
     
     11:17:24.417 [warning] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
       name: :tee,
       pads_data: %{
         :input => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
             {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>}
           ],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.889.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.890.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155509>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -6960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.891.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155511>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.417 [debug] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.418 [warning] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :right_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1001, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1002, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1003, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1004, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1005, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1006, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1007, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1008, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1009, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1010, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1011, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1012, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1013, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1014, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1015, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1016, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1017, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1018, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1019, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1020, pts: nil}],
                1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: 1021, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 7000,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155511>},
           pid: #PID<0.888.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.884.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.886.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.418 [debug] [:right_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.437 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.880.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.863.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.864.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.437 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.879.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.863.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.864.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.437 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.437 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.993.0>},
     process options: []
     
     
     11:17:24.438 [debug] [pipeline@<0.994.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: Membrane.Support.Bin.TestBins.NotifyingParentBin, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: nil, terminating?: false}]
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.439 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.439 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin
     
     11:17:24.439 [debug] [pipeline@<0.994.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentBin,
     bin options: nil
     
     
     11:17:24.439 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.NotifyingParentElement, filter2: Membrane.Support.Bin.TestBins.NotifyingParentElement]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.440 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: nil, terminating?: false}]
     
     11:17:24.440 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.440 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.440 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.440 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:test_bin bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
     element options: nil,
     
     
     11:17:24.441 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.NotifyingParentElement, options: nil
     
     11:17:24.441 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.NotifyingParentElement
     
     11:17:24.441 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.441 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.441 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083461.156051> linked internally
     
     11:17:24.441 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083461.156051> externally
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.441 [debug] [pipeline@<0.994.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.441 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.441 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.441 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:24.441 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:24.441 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.441 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.990.0>},
     process options: []
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 10}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 9}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 8}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 7}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 6}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}}], links: [%{from: {:filter, 10}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 9}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 10}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 8}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 9}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 7}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 8}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 6}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 7}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 6}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: nil, terminating?: false}]
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.442 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.442 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 10}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 10}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 10}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 10}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 9}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 9}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 9}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 9}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 8}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 8}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 8}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 8}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 7}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 7}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 7}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 7}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 6}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 6}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.442 [debug] [{:filter, 6}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.442 [debug] [{:filter, 6}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.442 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:24.443 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.443 [debug] [pipeline@<0.1002.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:24.443 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:24.443 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.443 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.443 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:24.443 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:24.443 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:24.443 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:24.444 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:24.444 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:24.444 [debug] [{:filter, 6}] Element handle link on pad :output with pad :input of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :input with pad :output of child {:filter, 6}
     
     11:17:24.444 [debug] [{:filter, 7}] Element handle link on pad :output with pad :input of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :input with pad :output of child {:filter, 7}
     
     11:17:24.444 [debug] [{:filter, 8}] Element handle link on pad :output with pad :input of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :input with pad :output of child {:filter, 8}
     
     11:17:24.444 [debug] [{:filter, 9}] Element handle link on pad :output with pad :input of child {:filter, 10}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :input with pad :output of child {:filter, 9}
     
     11:17:24.444 [debug] [{:filter, 10}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.444 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 10}
     
     11:17:24.444 [debug] [pipeline@<0.1002.0>] Spec #Reference<0.3642608924.1448083459.156599> linked internally
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Spec playback init #Reference<0.3642608924.1448083459.156599> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 6} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 7} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 8} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 9} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}, {:filter, 10} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1004.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1015.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1014.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1013.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1012.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1011.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1010.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 6}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1009.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 7}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1008.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 8}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1007.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 9}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1006.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 10}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1005.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156599>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Playback state changed from stopped to prepared
     
     11:17:24.445 [debug] [pipeline@<0.1002.0>] Changing playback state from prepared to playing
     
     11:17:24.446 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 6}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 7}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 8}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Evaluating playback buffer
     
     11:17:24.446 [debug] [:source] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 10}] Evaluating playback buffer
     
     11:17:24.446 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 6}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 7}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 8}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 9}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [{:filter, 10}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.446 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.441 [error] GenServer #PID<0.997.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.NotifyingParentBin.handle_parent_notification(:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter1, {"filter1", "Some notification"}], []}
     State: %Membrane.Core.Bin.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.994.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1000.0>}}], module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, output: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}}, parent_pid: #PID<0.994.0>, pending_specs: %{#Reference<0.3642608924.1448083461.156051> => %{links: %{{#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156065>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: {Membrane.Bin, :itself}, pad_info: %{}, pad_props: %{}, pad_ref: :input, pad_spec: :input, pid: #PID<0.997.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}}}, {#Reference<0.3642608924.1448083461.156051>, #Reference<0.3642608924.1448083461.156066>} => %{awaiting_responses: 0, link: %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.999.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_sp (truncated)
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec #Reference<0.3642608924.1448083461.156043> linked internally
     
     11:17:24.450 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Spec playback init #Reference<0.3642608924.1448083461.156043> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.996.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1001.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.NotifyingParentBin, name: :test_bin, options: nil, pid: #PID<0.997.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156043>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.450 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Changing playback state from stopped to prepared
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [debug] [pipeline@<0.994.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.450 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
       name: :filter2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: nil,
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.999.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.997.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.998.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.450 [debug] Bin start: :name
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:24.450 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.NotifyingParentBin, :handle_parent_notification, [:filter1, {"filter1", "Some notification"}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter1, options: nil, pid: #PID<0.999.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.NotifyingParentElement, name: :filter2, options: nil, pid: #PID<0.1000.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156051>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.999.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156077>}, linked?: false, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}, output: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :output, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1000.0>}, link_id: {#Reference<0.3642608924.1448083461.156043>, #Reference<0.3642608924.1448083461.156078>}, linked?: false, mode: :pull, name: :output, options: %{}, ref: :output, response_received?: true, spec_ref: #Reference<0.3642608924.1448083461.156051>}}, parent_clock: #PID<0.995.0>, playback_state: :stopped}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.Bin.TestBins.NotifyingParentElement,
       name: :filter1,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: nil,
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1000.0>,
           ref: :output,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.997.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
         q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
       },
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.998.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:name bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.451 [debug] [:name bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156793>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156793>, sync: nil, terminating?: false}]
     
     11:17:24.451 [debug] [:name bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.451 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.451 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:name bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.451 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.451 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.451 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:24.451 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:24.451 [debug] [:name bin] Spec #Reference<0.3642608924.1448083459.156793> linked internally
     
     11:17:24.451 [debug] [:name bin] Linking spec #Reference<0.3642608924.1448083459.156793> externally
     
     11:17:24.451 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.451 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:24.451 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.451 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}], links: [], module: :default, test_process: #PID<0.1027.0>},
     process options: []
     
     
     11:17:24.451 [debug] [pipeline@<0.1028.0>] Initializing spec
     children: [test_bin: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}]
     links: []
     
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestPadlessBin,
     bin options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}
     
     
     11:17:24.452 [debug] [:test_bin bin] Initializing spec
     children: [source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.452 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: nil, terminating?: false}]
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.452 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.452 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.452 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.452 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.452 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.452 [debug] [:source] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.452 [debug] [:sink] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked internally
     
     11:17:24.452 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083459.156826> externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083459.156826> linked externally
     
     11:17:24.452 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083459.156826> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec #Reference<0.3642608924.1448083459.156823> linked internally
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Spec playback init #Reference<0.3642608924.1448083459.156823> %{test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestPadlessBin{sink: Membrane.Testing.Sink, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1030.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156823>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.452 [debug] [pipeline@<0.1028.0>] Changing playback state from stopped to prepared
     
     11:17:24.452 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.453 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Playback state changed from stopped to prepared
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.453 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.453 [debug] [:source] Evaluating playback buffer
     
     11:17:24.453 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.453 [debug] [pipeline@<0.1002.0>] Playback state changed from prepared to playing
     
     11:17:24.453 [error] GenServer #PID<0.1030.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestPadlessBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1028.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1032.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1033.0>}}], module: Membrane.Support.Bin.TestBins.TestPadlessBin, name: :test_bin, pads_data: %{}, pads_info: %{}, parent_pid: #PID<0.1028.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1029.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1031.0>, latency: 0, parent_clock: #PID<0.1029.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.453 [debug] [pipeline@<0.1028.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.454 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.454 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1033.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.454 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.454 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.456 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestPadlessBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1033.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1032.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.156826>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{}, parent_clock: #PID<0.1029.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1032.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1030.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1031.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.456 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.457 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1036.0>},
     process options: []
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [test_bin: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: nil, terminating?: false}]
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestSinkBin
     
     11:17:24.457 [debug] [pipeline@<0.1037.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestSinkBin,
     bin options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}
     
     
     11:17:24.457 [debug] [:test_bin bin] Initializing spec
     children: [filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.458 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: nil, terminating?: false}]
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :filter, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :filter
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:24.458 [debug] [:filter] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:24.458 [debug] [:filter] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:24.458 [debug] [:test_bin bin] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:test_bin bin] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.458 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.458 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:24.458 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked internally
     
     11:17:24.458 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083464.156610> externally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.458 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.458 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.458 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:24.458 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:24.458 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:24.458 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:24.458 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083464.156610> linked externally
     
     11:17:24.458 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083464.156610> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec #Reference<0.3642608924.1448083464.156607> linked internally
     
     11:17:24.458 [debug] [pipeline@<0.1037.0>] Spec playback init #Reference<0.3642608924.1448083464.156607> %{source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1043.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestSinkBin{filter: Membrane.Support.Bin.TestBins.TestFilter, sink: Membrane.Testing.Sink}, pid: #PID<0.1039.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156607>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from stopped to prepared
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:source] Evaluating playback buffer
     
     11:17:24.459 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.459 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Evaluating playback buffer
     
     11:17:24.459 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.459 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.459 [debug] [pipeline@<0.1037.0>] Playback state changed from prepared to playing
     
     11:17:24.459 [error] GenServer #PID<0.1039.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Bin.TestBins.TestSinkBin.handle_parent_notification(:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1037.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1041.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1042.0>}}], module: Membrane.Support.Bin.TestBins.TestSinkBin, name: :test_bin, pads_data: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}}, parent_pid: #PID<0.1037.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1038.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1040.0>, latency: 0, parent_clock: #PID<0.1038.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [pipeline@<0.1037.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:24.460 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :child_crash}
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :child_crash}"
     
     
     11:17:24.460 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.460 [debug] [:filter] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.460 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:24.461 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1043.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1042.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1039.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1040.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:24.461 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.461 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Bin.TestBins.TestSinkBin, :handle_parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter, options: nil, pid: #PID<0.1041.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1042.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156610>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :test_bin, pads: %{input: %Membrane.Bin.PadData{accepted_caps: :any, availability: :always, demand_unit: :buffers, direction: :input, endpoint: %Membrane.Core.Parent.Link.Endpoint{child: :filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1041.0>}, link_id: {#Reference<0.3642608924.1448083464.156607>, #Reference<0.3642608924.1448083461.156240>}, linked?: true, mode: :pull, name: :input, options: %{}, ref: :input, response_received?: true, spec_ref: #Reference<0.3642608924.1448083464.156610>}}, parent_clock: #PID<0.1038.0>, playback_state: :playing}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1041.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1039.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1040.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:24.461 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:24.463 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1046.0>},
     process options: []
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.464 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.464 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}
     
     
     11:17:24.464 [debug] [:test_bin bin] Initializing spec
     children: [filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [:test_bin bin] Bin start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.464 [debug] [:filter1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.467 [debug] [:filter1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}]
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} of child :filter2
     
     11:17:24.467 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} of child :filter1
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked internally
     
     11:17:24.467 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156076> externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156076> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.468 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}]
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} of child :filter2
     
     11:17:24.468 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} of child :filter1
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked internally
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156096> externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156096> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}
     
     11:17:24.468 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked internally
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156120> externally
     
     11:17:24.468 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked internally
     
     11:17:24.468 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156121> externally
     
     11:17:24.468 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.468 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.469 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>} of child :filter2
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} of child :filter2
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked externally
     
     11:17:24.469 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156120> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked externally
     
     11:17:24.469 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156121> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083460.156071> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083460.156071> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}
     
     11:17:24.469 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}
     
     11:17:24.469 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked internally
     
     11:17:24.469 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083458.156392> externally
     
     11:17:24.469 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}
     
     11:17:24.469 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156388> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156393> externally
     
     11:17:24.469 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083458.156400> externally
     
     11:17:24.469 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>} of child :test_bin
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>} with pad :output of child :source
     
     11:17:24.470 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked externally
     
     11:17:24.470 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083458.156392> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156388> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} with pad :input of child :sink
     
     11:17:24.470 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} of child :filter2
     
     11:17:24.470 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked externally
     
     11:17:24.470 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083458.156400> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156393> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec #Reference<0.3642608924.1448083460.156065> linked internally
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec playback init #Reference<0.3642608924.1448083460.156065> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter1 bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:24.472 [debug] [:filter1 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.472 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:source] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [:filter1 bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [pipeline@<0.1047.0>] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:element] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.474 [warning] [:element] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.TimerTest.Element,
       name: :element,
       pads_data: %{},
       pads_info: %{},
       parent_pid: #PID<0.899.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.900.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.474 [debug] [:element] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.125 [debug] [:endpoint] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.126 [warning] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         autodemand: true,
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Endpoint,
       name: :endpoint,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.987.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.987.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.984.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.985.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :endpoint
     }
     
     
     11:17:26.126 [debug] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.133 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.133 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.986.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.986.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.984.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.985.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.133 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [debug] [{:filter, 6}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 7}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 3}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 5}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 1}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 2}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 4}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [warning] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 1},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1015.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1013.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [{:filter, 7}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 7},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1009.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1007.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 7}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 3},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1013.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1011.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1014.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:26.568 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 2},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1014.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1012.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [warning] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 4},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1012.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1010.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [warning] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 5},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1011.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1009.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [debug] [{:filter, 9}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.569 [debug] [{:filter, 10}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.569 [debug] [{:filter, 8}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.569 [warning] [{:filter, 6}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 6},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1010.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1008.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1005.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     


 12) test Dynamic pads handle_pad_added is called for dynamic pads (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:195
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 9 of 9 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_child_notification,
                  {{:handle_pad_added, {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}}, :test_bin}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_child_notification,
                  {{:handle_pad_added, {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}}, :test_bin}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1047.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/bin_test.exs:326: anonymous fn/3 in Membrane.Core.BinTest.assert_buffers_flow_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/bin_test.exs:317: Membrane.Core.BinTest.assert_data_flows_through/3
       test/membrane/integration/bin_test.exs:219: (test)

     The following output was logged:
     
     11:17:24.463 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1046.0>},
     process options: []
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:24.464 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:24.464 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [pipeline@<0.1047.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}
     
     
     11:17:24.464 [debug] [:test_bin bin] Initializing spec
     children: [filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.464 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: nil, terminating?: false}]
     
     11:17:24.464 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.464 [debug] [:test_bin bin] Bin start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.464 [debug] [:filter1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.467 [debug] [:filter1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: nil, terminating?: false}]
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.467 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.467 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.467 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} of child :filter2
     
     11:17:24.467 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>} of child :filter1
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked internally
     
     11:17:24.467 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156076> externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156076> linked externally
     
     11:17:24.467 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156076> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.467 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin
     
     11:17:24.468 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadBin,
     bin options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}
     
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: nil, terminating?: false}]
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter,
     element options: nil,
     
     
     11:17:24.468 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, options: nil
     
     11:17:24.468 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestDynamicPadFilter
     
     11:17:24.468 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} of child :filter2
     
     11:17:24.468 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>} of child :filter1
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked internally
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156096> externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156096> linked externally
     
     11:17:24.468 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156096> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.468 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}
     
     11:17:24.468 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}
     
     11:17:24.468 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156117>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.468 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:24.468 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.468 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked internally
     
     11:17:24.468 [debug] [pipeline@<0.1047.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:24.468 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083460.156120> externally
     
     11:17:24.468 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked internally
     
     11:17:24.468 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083460.156121> externally
     
     11:17:24.468 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:24.468 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:24.469 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156118>} of child :filter2
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>} of child :filter2
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083460.156120> linked externally
     
     11:17:24.469 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083460.156120> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083460.156121> linked externally
     
     11:17:24.469 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083460.156121> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083460.156071> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083460.156071> linked externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083460.156071> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}
     
     11:17:24.469 [debug] [:filter1 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}
     
     11:17:24.469 [debug] [:filter1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156390>}, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter1 bin] Starting children: []
     
     11:17:24.469 [debug] [:test_bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156382>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:test_bin bin] Starting children: []
     
     11:17:24.469 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked internally
     
     11:17:24.469 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083458.156392> externally
     
     11:17:24.469 [debug] [:filter2 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}
     
     11:17:24.469 [debug] [:filter2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156395>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:24.469 [debug] [:filter2 bin] Starting children: []
     
     11:17:24.469 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156388> externally
     
     11:17:24.469 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked internally
     
     11:17:24.469 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156393> externally
     
     11:17:24.469 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083458.156400> externally
     
     11:17:24.469 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156380>} of child :test_bin
     
     11:17:24.469 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>} with pad :output of child :source
     
     11:17:24.470 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156392> linked externally
     
     11:17:24.470 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083458.156392> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1054.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1055.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156076>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156388> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156388> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} with pad :input of child :sink
     
     11:17:24.470 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>} of child :filter2
     
     11:17:24.470 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156400> linked externally
     
     11:17:24.470 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083458.156400> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter1, options: nil, pid: #PID<0.1058.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, name: :filter2, options: nil, pid: #PID<0.1059.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156096>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.470 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156393> linked externally
     
     11:17:24.470 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156393> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1052.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, pid: #PID<0.1056.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156071>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec #Reference<0.3642608924.1448083460.156065> linked internally
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Spec playback init #Reference<0.3642608924.1448083460.156065> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1049.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1060.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.TestDynamicPadBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}, filter2: %Membrane.Support.Bin.TestBins.TestDynamicPadBin{filter1: Membrane.Support.Bin.TestBins.TestDynamicPadFilter, filter2: Membrane.Support.Bin.TestBins.TestDynamicPadFilter}}, pid: #PID<0.1050.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156065>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:24.471 [debug] [pipeline@<0.1047.0>] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter1 bin] Changing playback state from stopped to prepared
     
     11:17:24.471 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:24.472 [debug] [:filter1 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Playback state changed from stopped to prepared
     
     11:17:24.472 [debug] [pipeline@<0.1047.0>] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:sink] Evaluating playback buffer
     
     11:17:24.472 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:source] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.156398>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156086>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156087>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156123>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Evaluating playback buffer
     
     11:17:24.472 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156126>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.156106>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083460.156107>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.472 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:24.472 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.156402>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [:filter1 bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:24.473 [debug] [pipeline@<0.1047.0>] Playback state changed from prepared to playing
     
     11:17:24.473 [debug] [:element] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:24.474 [warning] [:element] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.TimerTest.Element,
       name: :element,
       pads_data: %{},
       pads_info: %{},
       parent_pid: #PID<0.899.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.900.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:24.474 [debug] [:element] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.125 [debug] [:endpoint] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.126 [warning] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         autodemand: true,
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Endpoint,
       name: :endpoint,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.987.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.987.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.984.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.985.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :endpoint
     }
     
     
     11:17:26.126 [debug] [:endpoint] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.133 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.133 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Support.Bin.TestBins.TestFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 37,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.986.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.986.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.984.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.985.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.133 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [debug] [{:filter, 6}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 7}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 3}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 5}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 1}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 2}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [debug] [{:filter, 4}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.568 [warning] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 1},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1015.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1013.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [{:filter, 7}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 7},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1009.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1007.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 7}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 3},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1013.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1011.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1014.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:26.568 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.568 [warning] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 2},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1014.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1012.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.568 [debug] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [warning] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 4},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1012.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1010.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [warning] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 5},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1011.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1009.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [debug] [{:filter, 9}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.569 [debug] [{:filter, 10}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.569 [debug] [{:filter, 8}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:26.569 [warning] [{:filter, 6}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 6},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1010.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1008.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1005.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:26.569 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [debug] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [debug] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [warning] [{:filter, 10}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 10},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1553,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1006.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1004.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [warning] [{:filter, 9}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 9},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1007.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1553,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1005.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [debug] [{:filter, 9}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [debug] [{:filter, 10}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [debug] [{:filter, 6}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.569 [warning] [{:filter, 8}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 8},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1008.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1006.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1002.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1003.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:26.569 [debug] [{:filter, 8}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:26.596 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1063.0>},
     process options: []
     
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}]
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:26.597 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:26.597 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.597 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.597 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.597 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.597 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.597 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.597 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.598 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.598 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.598 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.598 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4},
     
     
     11:17:26.598 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}
     
     11:17:26.598 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:26.598 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:26.598 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:26.598 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:26.598 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:26.598 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:26.598 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:26.598 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:26.598 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:26.598 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:26.598 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:26.598 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:26.598 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Spec #Reference<0.3642608924.1448083460.156162> linked internally
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Spec playback init #Reference<0.3642608924.1448083460.156162> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1066.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}, pid: #PID<0.1072.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1071.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1070.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1069.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1068.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1067.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1066.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}, pid: #PID<0.1072.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1071.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1070.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1069.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1068.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1067.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Changing playback state from stopped to prepared
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Playback state changed from stopped to prepared
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Changing playback state from prepared to playing
     
     11:17:26.599 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:26.599 [debug] [:sink] Evaluating playback buffer
     
     11:17:26.599 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:26.599 [debug] [:source] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Playback state changed from prepared to playing
     
     11:17:26.599 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.472 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.472 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     


 13) test buffers pass through auto-demand filters; setup: %{direction: :up, factor: 10, filters: 5, payloads: 1..4} (Membrane.Integration.AutoDemandsTest)
     test/membrane/integration/auto_demands_test.exs:53
     Assertion failed, no matching message after 2000ms
     Showing 10 of 224253 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1064.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/auto_demands_test.exs:82: anonymous fn/2 in Membrane.Integration.AutoDemandsTest."test buffers pass through auto-demand filters; setup: %{direction: :up, factor: 10, filters: 5, payloads: 1..4}"/1
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/auto_demands_test.exs:81: (test)

     The following output was logged:
     
     11:17:26.596 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1063.0>},
     process options: []
     
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: nil, terminating?: false}]
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:26.597 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:26.597 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.597 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.597 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.597 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.597 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.597 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.597 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.597 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.598 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.598 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10},
     
     
     11:17:26.598 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}
     
     11:17:26.598 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4},
     
     
     11:17:26.598 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}
     
     11:17:26.598 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:26.598 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:26.598 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:26.598 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:26.598 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:26.598 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:26.598 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:26.598 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:26.598 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:26.598 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:26.598 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:26.598 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:26.598 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:26.598 [debug] [pipeline@<0.1064.0>] Spec #Reference<0.3642608924.1448083460.156162> linked internally
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Spec playback init #Reference<0.3642608924.1448083460.156162> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1066.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}, pid: #PID<0.1072.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1071.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1070.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1069.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1068.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1067.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1066.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..4}, pid: #PID<0.1072.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1071.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1070.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1069.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1068.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 10}, pid: #PID<0.1067.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Changing playback state from stopped to prepared
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Playback state changed from stopped to prepared
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Changing playback state from prepared to playing
     
     11:17:26.599 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:26.599 [debug] [:sink] Evaluating playback buffer
     
     11:17:26.599 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:26.599 [debug] [:source] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:26.599 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [pipeline@<0.1064.0>] Playback state changed from prepared to playing
     
     11:17:26.599 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:26.599 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.472 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.472 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.472 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:28.472 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:28.472 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:28.472 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:28.472 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083458.156402>},
           pid: #PID<0.1059.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1047.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1048.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:28.472 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input,
            #Reference<0.3642608924.1448083458.156398>},
           pid: #PID<0.1054.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1047.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1048.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:28.472 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.472 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1075.0>},
     process options: []
     
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: nil, terminating?: false}]
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:28.473 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:28.473 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}
     
     
     11:17:28.473 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.473 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: nil, terminating?: false}]
     
     11:17:28.473 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.473 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:28.473 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:28.473 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.473 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:28.473 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:28.474 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.474 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: nil, terminating?: false}]
     
     11:17:28.474 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:28.474 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:28.474 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:28.474 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:28.474 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:28.474 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:28.474 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083457.158798> linked internally
     
     11:17:28.474 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083457.158798> externally
     
     11:17:28.474 [debug] [pipeline@<0.1076.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:28.474 [debug] [:filter2 bin] Received link request on pad :input
     
     11:17:28.474 [debug] [:filter2 bin] Sending link response, :input
     
     11:17:28.474 [debug] [pipeline@<0.1076.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:28.474 [debug] [:filter2 bin] Received link request on pad :output
     
     11:17:28.474 [debug] [:filter2 bin] Sending link response, :output
     
     11:17:28.474 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:28.474 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:28.474 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083457.158793> linked internally
     
     11:17:28.474 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083457.158793> externally
     
     11:17:28.474 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:28.474 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:28.474 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:28.474 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:28.474 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:28.474 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:28.474 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:28.475 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083457.158798> linked externally
     
     11:17:28.475 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083457.158798> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1084.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1085.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.475 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1084.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1085.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083457.158793> linked externally
     
     11:17:28.475 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083457.158793> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1081.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1082.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.475 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1081.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1082.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Spec #Reference<0.3642608924.1448083457.158787> linked internally
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Spec playback init #Reference<0.3642608924.1448083457.158787> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1078.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1086.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1079.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1078.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1086.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1079.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Changing playback state from stopped to prepared
     
     11:17:28.475 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:28.475 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:28.475 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:28.475 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Playback state changed from stopped to prepared
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Changing playback state from prepared to playing
     
     11:17:28.475 [debug] [:sink] Evaluating playback buffer
     
     11:17:28.475 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.475 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:28.475 [debug] [:source] Evaluating playback buffer
     
     11:17:28.475 [debug] [:filter1] Evaluating playback buffer
     
     11:17:28.475 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:28.475 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter1] Evaluating playback buffer
     
     11:17:28.476 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter2] Evaluating playback buffer
     
     11:17:28.476 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:28.476 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:28.476 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [pipeline@<0.1076.0>] Playback state changed from prepared to playing
     
     11:17:28.476 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.881 [debug] [{:filter, 1}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.881 [debug] [{:filter, 4}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.881 [debug] [{:filter, 3}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [warning] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 4},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1069.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -36000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1067.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [debug] [{:filter, 2}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [warning] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 1},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3996,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1072.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1070.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [warning] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 3},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3600,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1070.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1068.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [warning] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 2},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1071.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3600,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1069.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     


 14) test Starting and transmitting buffers when bins are nested (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:57
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 7 of 7 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1076.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/bin_test.exs:326: anonymous fn/3 in Membrane.Core.BinTest.assert_buffers_flow_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/bin_test.exs:317: Membrane.Core.BinTest.assert_data_flows_through/3
       test/membrane/integration/bin_test.exs:75: (test)

     The following output was logged:
     
     11:17:28.472 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1075.0>},
     process options: []
     
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: nil, terminating?: false}]
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:28.473 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:28.473 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:28.473 [debug] [pipeline@<0.1076.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}
     
     
     11:17:28.473 [debug] [:test_bin bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.473 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: nil, terminating?: false}]
     
     11:17:28.473 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.473 [debug] [:test_bin bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:28.473 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:28.473 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.473 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:28.473 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:28.474 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.474 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: nil, terminating?: false}]
     
     11:17:28.474 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:28.474 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:28.474 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:28.474 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:28.474 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:28.474 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:28.474 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083457.158798> linked internally
     
     11:17:28.474 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083457.158798> externally
     
     11:17:28.474 [debug] [pipeline@<0.1076.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:28.474 [debug] [:filter2 bin] Received link request on pad :input
     
     11:17:28.474 [debug] [:filter2 bin] Sending link response, :input
     
     11:17:28.474 [debug] [pipeline@<0.1076.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:28.474 [debug] [:filter2 bin] Received link request on pad :output
     
     11:17:28.474 [debug] [:filter2 bin] Sending link response, :output
     
     11:17:28.474 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:28.474 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:28.474 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083457.158793> linked internally
     
     11:17:28.474 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083457.158793> externally
     
     11:17:28.474 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:28.474 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:28.474 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:28.474 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:28.474 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:28.474 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:28.474 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:28.474 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:28.475 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083457.158798> linked externally
     
     11:17:28.475 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083457.158798> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1084.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1085.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.475 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1084.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1085.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158798>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083457.158793> linked externally
     
     11:17:28.475 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083457.158793> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1081.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1082.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.475 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1081.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1082.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158793>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Spec #Reference<0.3642608924.1448083457.158787> linked internally
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Spec playback init #Reference<0.3642608924.1448083457.158787> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1078.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1086.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1079.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1078.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1086.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1079.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158787>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Changing playback state from stopped to prepared
     
     11:17:28.475 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:28.475 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:28.475 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:28.475 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Playback state changed from stopped to prepared
     
     11:17:28.475 [debug] [pipeline@<0.1076.0>] Changing playback state from prepared to playing
     
     11:17:28.475 [debug] [:sink] Evaluating playback buffer
     
     11:17:28.475 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.475 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:28.475 [debug] [:source] Evaluating playback buffer
     
     11:17:28.475 [debug] [:filter1] Evaluating playback buffer
     
     11:17:28.475 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:28.475 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter1] Evaluating playback buffer
     
     11:17:28.476 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter2] Evaluating playback buffer
     
     11:17:28.476 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:28.476 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:28.476 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [pipeline@<0.1076.0>] Playback state changed from prepared to playing
     
     11:17:28.476 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.476 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.881 [debug] [{:filter, 1}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.881 [debug] [{:filter, 4}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.881 [debug] [{:filter, 3}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [warning] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 4},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1069.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -36000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1067.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [debug] [{:filter, 2}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [warning] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 1},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3996,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1072.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1070.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [warning] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 3},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3600,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1070.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1068.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [warning] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 2},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1071.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3600,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1069.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3996,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1071.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:28.882 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.882 [debug] [{:filter, 5}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:28.882 [warning] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 5},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -36000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1068.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -147290,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1066.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.883 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1089.0>},
     process options: []
     
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}]
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :tee, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :tee
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
     element options: nil,
     
     
     11:17:28.883 [debug] [:tee] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandTee, options: nil
     
     11:17:28.883 [debug] [:tee] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:28.883 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:28.883 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :left_sink, module: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :left_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:28.883 [debug] [:left_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:28.883 [debug] [:left_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :right_sink, module: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :right_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:28.883 [debug] [:right_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:28.883 [debug] [:right_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [:source] Element handle link on pad :output with pad :input of child :tee
     
     11:17:28.883 [debug] [:tee] Element handle link on pad :input with pad :output of child :source
     
     11:17:28.883 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>} with pad :input of child :left_sink
     
     11:17:28.883 [debug] [:left_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>} of child :tee
     
     11:17:28.883 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157394>} with pad :input of child :right_sink
     
     11:17:28.883 [debug] [:right_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157394>} of child :tee
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Spec #Reference<0.3642608924.1448083462.157373> linked internally
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Spec playback init #Reference<0.3642608924.1448083462.157373> %{left_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1094.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}, right_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1095.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1093.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}, tee: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.1092.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1094.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1095.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1093.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.1092.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Changing playback state from stopped to prepared
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Playback state changed from stopped to prepared
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Changing playback state from prepared to playing
     
     11:17:28.884 [debug] [:left_sink] Evaluating playback buffer
     
     11:17:28.884 [debug] [:right_sink] Evaluating playback buffer
     
     11:17:28.884 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:source] Evaluating playback buffer
     
     11:17:28.884 [debug] [:tee] Evaluating playback buffer
     
     11:17:28.884 [debug] [:tee] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157394>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:left_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:right_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.889 [debug] [pipeline@<0.1090.0>] Playback state changed from prepared to playing
     
     11:17:29.749 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:29.749 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1067.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:29.749 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.477 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:30.477 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:30.477 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.478 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1085.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1076.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1077.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
..

 15) test handle removed branch (Membrane.Integration.AutoDemandsTest)
     test/membrane/integration/auto_demands_test.exs:119
     Assertion failed, no matching message after 2000ms
     Showing 10 of 100013 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99993, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99994, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99995, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99996, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99997, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99998, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 99999, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :left_sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 100000, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:left_sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1090.0>, {:handle_element_end_of_stream, {:left_sink, :input}}}
     stacktrace:
       test/membrane/integration/auto_demands_test.exs:136: anonymous fn/2 in Membrane.Integration.AutoDemandsTest."test handle removed branch"/1
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/auto_demands_test.exs:135: (test)

     The following output was logged:
     
     11:17:28.882 [warning] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 5},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -36000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1068.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: -147290,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1066.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:28.882 [debug] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:28.883 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1089.0>},
     process options: []
     
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [tee: Membrane.Integration.AutoDemandsTest.AutoDemandTee, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :tee, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [left_sink: Membrane.Testing.Sink], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :left_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [right_sink: %Membrane.Testing.Sink{autodemand: false}], links: [%{from: :tee, from_pad: :output, from_pad_props: %{options: []}, to: :right_sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: nil, terminating?: false}]
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :tee, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :tee
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
     element options: nil,
     
     
     11:17:28.883 [debug] [:tee] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandTee, options: nil
     
     11:17:28.883 [debug] [:tee] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandTee
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000},
     
     
     11:17:28.883 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}
     
     11:17:28.883 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :left_sink, module: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :left_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:28.883 [debug] [:left_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:28.883 [debug] [:left_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Starting child: name: :right_sink, module: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Element start: :right_sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:28.883 [debug] [:right_sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:28.883 [debug] [:right_sink] Element initialized: Membrane.Testing.Sink
     
     11:17:28.883 [debug] [:source] Element handle link on pad :output with pad :input of child :tee
     
     11:17:28.883 [debug] [:tee] Element handle link on pad :input with pad :output of child :source
     
     11:17:28.883 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>} with pad :input of child :left_sink
     
     11:17:28.883 [debug] [:left_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>} of child :tee
     
     11:17:28.883 [debug] [:tee] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157394>} with pad :input of child :right_sink
     
     11:17:28.883 [debug] [:right_sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157394>} of child :tee
     
     11:17:28.883 [debug] [pipeline@<0.1090.0>] Spec #Reference<0.3642608924.1448083462.157373> linked internally
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Spec playback init #Reference<0.3642608924.1448083462.157373> %{left_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1094.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}, right_sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1095.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1093.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}, tee: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.1092.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :left_sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1094.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :right_sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1095.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: 1..100000}, pid: #PID<0.1093.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandTee, name: :tee, options: nil, pid: #PID<0.1092.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157373>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Changing playback state from stopped to prepared
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Playback state changed from stopped to prepared
     
     11:17:28.884 [debug] [pipeline@<0.1090.0>] Changing playback state from prepared to playing
     
     11:17:28.884 [debug] [:left_sink] Evaluating playback buffer
     
     11:17:28.884 [debug] [:right_sink] Evaluating playback buffer
     
     11:17:28.884 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:source] Evaluating playback buffer
     
     11:17:28.884 [debug] [:tee] Evaluating playback buffer
     
     11:17:28.884 [debug] [:tee] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:tee] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157394>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:left_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.884 [debug] [:right_sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:28.889 [debug] [pipeline@<0.1090.0>] Playback state changed from prepared to playing
     
     11:17:29.749 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:29.749 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1067.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1064.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1065.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:29.749 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.477 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:30.477 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:30.477 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.478 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1085.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1076.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1077.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:30.478 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.478 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1081.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1076.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1077.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:30.478 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.481 [debug] Pipeline start link: module: Membrane.Core.BinTest.ClockPipeline,
     pipeline options: nil,
     process options: []
     
     
     11:17:30.481 [debug] [pipeline@<0.1099.0>] Initializing spec
     children: [bin_child: Membrane.Core.BinTest.ClockBin]
     links: []
     
     
     11:17:30.481 [debug] [pipeline@<0.1099.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Core.BinTest.ClockBin, name: :bin_child, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156978>, sync: nil, terminating?: false}]
     
     11:17:30.482 [debug] [pipeline@<0.1099.0>] Starting child: name: :bin_child, module: Membrane.Core.BinTest.ClockBin
     
     11:17:30.482 [debug] [pipeline@<0.1099.0>] Bin start: :bin_child
     node: ,
     module: Membrane.Core.BinTest.ClockBin,
     bin options: nil
     
     
     11:17:30.482 [debug] [:bin_child bin] Initializing spec
     children: [element_child: Membrane.Core.BinTest.ClockElement]
     links: []
     
     
     11:17:30.482 [debug] [:bin_child bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Core.BinTest.ClockElement, name: :element_child, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156981>, sync: nil, terminating?: false}]
     
     11:17:30.482 [debug] [:bin_child bin] Starting child: name: :element_child, module: Membrane.Core.BinTest.ClockElement
     
     11:17:30.482 [debug] [:bin_child bin] Element start: :element_child
     node: ,
     module: Membrane.Core.BinTest.ClockElement,
     element options: nil,
     
     
     11:17:30.482 [debug] [:element_child] Initializing element: Membrane.Core.BinTest.ClockElement, options: nil
     
     11:17:30.482 [debug] [:element_child] Element initialized: Membrane.Core.BinTest.ClockElement
     
     11:17:30.482 [debug] [:bin_child bin] Spec #Reference<0.3642608924.1448083459.156981> linked internally
     
     11:17:30.482 [debug] [:bin_child bin] Linking spec #Reference<0.3642608924.1448083459.156981> externally
     
     11:17:30.482 [debug] [:bin_child bin] Spec #Reference<0.3642608924.1448083459.156981> linked externally
     
     11:17:30.482 [debug] [:bin_child bin] Spec playback init #Reference<0.3642608924.1448083459.156981> %{element_child: %Membrane.ChildEntry{clock: #PID<0.1104.0>, component_type: :element, module: Membrane.Core.BinTest.ClockElement, name: :element_child, options: nil, pid: #PID<0.1103.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156981>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.482 [debug] [:bin_child bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: #PID<0.1104.0>, component_type: :element, module: Membrane.Core.BinTest.ClockElement, name: :element_child, options: nil, pid: #PID<0.1103.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156981>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.482 [debug] [pipeline@<0.1099.0>] Spec #Reference<0.3642608924.1448083459.156978> linked internally
     
     11:17:30.483 [debug] [pipeline@<0.1099.0>] Spec playback init #Reference<0.3642608924.1448083459.156978> %{bin_child: %Membrane.ChildEntry{clock: #PID<0.1102.0>, component_type: :bin, module: Membrane.Core.BinTest.ClockBin, name: :bin_child, options: nil, pid: #PID<0.1101.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156978>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.483 [debug] [pipeline@<0.1099.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: #PID<0.1102.0>, component_type: :bin, module: Membrane.Core.BinTest.ClockBin, name: :bin_child, options: nil, pid: #PID<0.1101.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.156978>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.483 [debug] [pipeline@<0.1099.0>] Changing playback state from stopped to terminating
     
     11:17:30.483 [debug] [:bin_child bin] Changing playback state from stopped to terminating
     
     11:17:30.483 [debug] [:bin_child bin] Playback state changed from stopped to terminating
     
     11:17:30.483 [debug] [pipeline@<0.1099.0>] Playback state changed from stopped to terminating
     
     11:17:30.484 [debug] Bin start: :name
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:30.484 [debug] [:name bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.484 [debug] [:name bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156232>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156232>, sync: nil, terminating?: false}]
     
     11:17:30.484 [debug] [:name bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.484 [debug] [:name bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.484 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.485 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.485 [debug] [:name bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.485 [debug] [:name bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.485 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.485 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.485 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:30.485 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:30.485 [debug] [:name bin] Spec #Reference<0.3642608924.1448083460.156232> linked internally
     
     11:17:30.485 [debug] [:name bin] Linking spec #Reference<0.3642608924.1448083460.156232> externally
     
     11:17:30.485 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.485 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:30.485 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.485 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.485 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.485 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:30.486 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, test_bin1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin2, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :test_bin1, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1115.0>},
     process options: []
     
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, test_bin1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin2, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :test_bin1, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}]
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:30.487 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:30.487 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Starting child: name: :test_bin2, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:30.488 [debug] [pipeline@<0.1116.0>] Bin start: :test_bin2
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:30.488 [debug] [:test_bin2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.488 [debug] [:test_bin2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: nil, terminating?: false}]
     
     11:17:30.488 [debug] [:test_bin2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.488 [debug] [:test_bin2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.488 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.488 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.488 [debug] [:test_bin2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.488 [debug] [:test_bin2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.488 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.489 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.489 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:30.489 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:30.489 [debug] [:test_bin2 bin] Spec #Reference<0.3642608924.1448083457.158997> linked internally
     
     11:17:30.489 [debug] [:test_bin2 bin] Linking spec #Reference<0.3642608924.1448083457.158997> externally
     
     11:17:30.489 [debug] [pipeline@<0.1116.0>] Starting child: name: :test_bin1, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:30.489 [debug] [pipeline@<0.1116.0>] Bin start: :test_bin1
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:30.489 [debug] [:test_bin1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.490 [debug] [:test_bin1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: nil, terminating?: false}]
     
     11:17:30.490 [debug] [:test_bin1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:test_bin1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.490 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.490 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:test_bin1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:test_bin1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.490 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.490 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:30.490 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:30.490 [debug] [:test_bin1 bin] Spec #Reference<0.3642608924.1448083460.156281> linked internally
     
     11:17:30.490 [debug] [:test_bin1 bin] Linking spec #Reference<0.3642608924.1448083460.156281> externally
     
     11:17:30.490 [debug] [pipeline@<0.1116.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:30.490 [debug] [pipeline@<0.1116.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:30.490 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:30.490 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:30.490 [debug] [:test_bin1 bin] Received link request on pad :input
     
     11:17:30.490 [debug] [:test_bin2 bin] Received link request on pad :input
     
     11:17:30.490 [debug] [:test_bin1 bin] Sending link response, :input
     
     11:17:30.490 [debug] [:test_bin1 bin] Received link request on pad :output
     
     11:17:30.490 [debug] [:test_bin2 bin] Sending link response, :input
     
     11:17:30.490 [debug] [:test_bin1 bin] Sending link response, :output
     
     11:17:30.491 [debug] [:test_bin2 bin] Received link request on pad :output
     
     11:17:30.491 [debug] [:test_bin2 bin] Sending link response, :output
     
     11:17:30.491 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin1
     
     11:17:30.491 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:30.491 [debug] [:filter2] Element handle link on pad :output with pad :input of child :test_bin2
     
     11:17:30.491 [debug] [:filter1] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:30.491 [debug] [:test_bin1 bin] Spec #Reference<0.3642608924.1448083460.156281> linked externally
     
     11:17:30.491 [debug] [:test_bin1 bin] Spec playback init #Reference<0.3642608924.1448083460.156281> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1125.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1126.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.491 [debug] [:test_bin1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1125.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.491 [debug] [:test_bin1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1126.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.491 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:30.491 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:30.491 [debug] [:test_bin2 bin] Spec #Reference<0.3642608924.1448083457.158997> linked externally
     
     11:17:30.492 [debug] [:test_bin2 bin] Spec playback init #Reference<0.3642608924.1448083457.158997> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1121.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1122.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.492 [debug] [:test_bin2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1121.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [:test_bin2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1122.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Spec #Reference<0.3642608924.1448083460.156264> linked internally
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Spec playback init #Reference<0.3642608924.1448083460.156264> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1118.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1127.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}, test_bin1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1123.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}, test_bin2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1119.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1118.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1127.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1123.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1119.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Changing playback state from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin1 bin] Changing playback state from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin2 bin] Changing playback state from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin1 bin] Playback state changed from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin2 bin] Playback state changed from stopped to prepared
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Playback state changed from stopped to prepared
     
     11:17:30.493 [debug] [pipeline@<0.1116.0>] Changing playback state from prepared to playing
     
     11:17:30.493 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:sink] Evaluating playback buffer
     
     11:17:30.493 [debug] [:test_bin2 bin] Changing playback state from prepared to playing
     
     11:17:30.493 [debug] [:source] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter2] Evaluating playback buffer
     
     11:17:30.493 [debug] [:test_bin1 bin] Changing playback state from prepared to playing
     
     11:17:30.493 [debug] [:filter1] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter1] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter2] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:test_bin2 bin] Playback state changed from prepared to playing
     
     11:17:30.493 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:test_bin1 bin] Playback state changed from prepared to playing
     
     11:17:30.493 [debug] [pipeline@<0.1116.0>] Playback state changed from prepared to playing
     
     11:17:30.493 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:31.496 [debug] [:tee] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:31.496 [debug] [:left_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:31.496 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:31.497 [warning] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :left_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083462.157392>},
           pid: #PID<0.1092.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1090.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1091.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:31.497 [debug] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:31.497 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1092.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1090.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1091.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:31.497 [warning] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
       name: :tee,
       pads_data: %{
         :input => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1093.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1094.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1090.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1091.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:31.497 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:31.497 [debug] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     


 16) test Starting and transmitting buffers when bin is next to a bin (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:34
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 7 of 7 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1116.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/bin_test.exs:326: anonymous fn/3 in Membrane.Core.BinTest.assert_buffers_flow_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/bin_test.exs:317: Membrane.Core.BinTest.assert_data_flows_through/3
       test/membrane/integration/bin_test.exs:53: (test)

     The following output was logged:
     
     11:17:30.486 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, test_bin1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin2, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :test_bin1, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1115.0>},
     process options: []
     
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, test_bin1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin2, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :test_bin1, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: nil, terminating?: false}]
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:30.487 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:30.487 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:30.487 [debug] [pipeline@<0.1116.0>] Starting child: name: :test_bin2, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:30.488 [debug] [pipeline@<0.1116.0>] Bin start: :test_bin2
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:30.488 [debug] [:test_bin2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.488 [debug] [:test_bin2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: nil, terminating?: false}]
     
     11:17:30.488 [debug] [:test_bin2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.488 [debug] [:test_bin2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.488 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.488 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.488 [debug] [:test_bin2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.488 [debug] [:test_bin2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.488 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.489 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.489 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:30.489 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:30.489 [debug] [:test_bin2 bin] Spec #Reference<0.3642608924.1448083457.158997> linked internally
     
     11:17:30.489 [debug] [:test_bin2 bin] Linking spec #Reference<0.3642608924.1448083457.158997> externally
     
     11:17:30.489 [debug] [pipeline@<0.1116.0>] Starting child: name: :test_bin1, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:30.489 [debug] [pipeline@<0.1116.0>] Bin start: :test_bin1
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:30.489 [debug] [:test_bin1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:30.490 [debug] [:test_bin1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: nil, terminating?: false}]
     
     11:17:30.490 [debug] [:test_bin1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:test_bin1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.490 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.490 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:test_bin1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:test_bin1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:30.490 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:30.490 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:30.490 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:30.490 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:30.490 [debug] [:test_bin1 bin] Spec #Reference<0.3642608924.1448083460.156281> linked internally
     
     11:17:30.490 [debug] [:test_bin1 bin] Linking spec #Reference<0.3642608924.1448083460.156281> externally
     
     11:17:30.490 [debug] [pipeline@<0.1116.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:30.490 [debug] [pipeline@<0.1116.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:30.490 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:30.490 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:30.490 [debug] [:test_bin1 bin] Received link request on pad :input
     
     11:17:30.490 [debug] [:test_bin2 bin] Received link request on pad :input
     
     11:17:30.490 [debug] [:test_bin1 bin] Sending link response, :input
     
     11:17:30.490 [debug] [:test_bin1 bin] Received link request on pad :output
     
     11:17:30.490 [debug] [:test_bin2 bin] Sending link response, :input
     
     11:17:30.490 [debug] [:test_bin1 bin] Sending link response, :output
     
     11:17:30.491 [debug] [:test_bin2 bin] Received link request on pad :output
     
     11:17:30.491 [debug] [:test_bin2 bin] Sending link response, :output
     
     11:17:30.491 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin1
     
     11:17:30.491 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:30.491 [debug] [:filter2] Element handle link on pad :output with pad :input of child :test_bin2
     
     11:17:30.491 [debug] [:filter1] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:30.491 [debug] [:test_bin1 bin] Spec #Reference<0.3642608924.1448083460.156281> linked externally
     
     11:17:30.491 [debug] [:test_bin1 bin] Spec playback init #Reference<0.3642608924.1448083460.156281> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1125.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1126.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.491 [debug] [:test_bin1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1125.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.491 [debug] [:test_bin1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1126.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156281>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.491 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:30.491 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:30.491 [debug] [:test_bin2 bin] Spec #Reference<0.3642608924.1448083457.158997> linked externally
     
     11:17:30.492 [debug] [:test_bin2 bin] Spec playback init #Reference<0.3642608924.1448083457.158997> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1121.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1122.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.492 [debug] [:test_bin2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1121.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [:test_bin2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1122.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.158997>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Spec #Reference<0.3642608924.1448083460.156264> linked internally
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Spec playback init #Reference<0.3642608924.1448083460.156264> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1118.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1127.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}, test_bin1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1123.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}, test_bin2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1119.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1118.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1127.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1123.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1119.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156264>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Changing playback state from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin1 bin] Changing playback state from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin2 bin] Changing playback state from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin1 bin] Playback state changed from stopped to prepared
     
     11:17:30.492 [debug] [:test_bin2 bin] Playback state changed from stopped to prepared
     
     11:17:30.492 [debug] [pipeline@<0.1116.0>] Playback state changed from stopped to prepared
     
     11:17:30.493 [debug] [pipeline@<0.1116.0>] Changing playback state from prepared to playing
     
     11:17:30.493 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:sink] Evaluating playback buffer
     
     11:17:30.493 [debug] [:test_bin2 bin] Changing playback state from prepared to playing
     
     11:17:30.493 [debug] [:source] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter2] Evaluating playback buffer
     
     11:17:30.493 [debug] [:test_bin1 bin] Changing playback state from prepared to playing
     
     11:17:30.493 [debug] [:filter1] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter1] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter2] Evaluating playback buffer
     
     11:17:30.493 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:test_bin2 bin] Playback state changed from prepared to playing
     
     11:17:30.493 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:test_bin1 bin] Playback state changed from prepared to playing
     
     11:17:30.493 [debug] [pipeline@<0.1116.0>] Playback state changed from prepared to playing
     
     11:17:30.493 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:30.493 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:31.496 [debug] [:tee] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:31.496 [debug] [:left_sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:31.496 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:31.497 [warning] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :left_sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083462.157392>},
           pid: #PID<0.1092.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1090.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1091.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:31.497 [debug] [:left_sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:31.497 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1092.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1090.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1091.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:31.497 [warning] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.AutoDemandTee,
       name: :tee,
       pads_data: %{
         :input => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1093.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1094.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083462.157392>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1090.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1091.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:31.497 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:31.497 [debug] [:tee] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:31.497 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1130.0>},
     process options: []
     
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: nil, terminating?: false}]
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:31.497 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:31.497 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Starting child: name: :filter, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Element start: :filter
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:31.497 [debug] [:filter] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:31.497 [debug] [:filter] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Starting child: name: :source, module: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Element start: :source
     node: ,
     module: Membrane.Integration.AutoDemandsTest.PushSource,
     element options: nil,
     
     
     11:17:31.498 [debug] [:source] Initializing element: Membrane.Integration.AutoDemandsTest.PushSource, options: nil
     
     11:17:31.498 [debug] [:source] Element initialized: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:31.498 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:31.498 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:31.498 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:31.498 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Spec #Reference<0.3642608924.1448083458.156688> linked internally
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Spec playback init #Reference<0.3642608924.1448083458.156688> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1134.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1133.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.1135.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1134.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1133.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.1135.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Changing playback state from stopped to prepared
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Playback state changed from stopped to prepared
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Changing playback state from prepared to playing
     
     11:17:31.498 [debug] [:sink] Evaluating playback buffer
     
     11:17:31.498 [debug] [:filter] Evaluating playback buffer
     
     11:17:31.498 [debug] [:source] Sending caps through pad :output
     Caps: :any
     
     
     11:17:31.498 [debug] [:source] Evaluating playback buffer
     
     11:17:31.498 [debug] [:filter] Received caps on pad :input
     Caps: :any
     
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Playback state changed from prepared to playing
     
     11:17:31.498 [debug] [:filter] Sending caps through pad :output
     Caps: :any
     
     
     11:17:31.498 [debug] [:sink] Received caps on pad :input
     Caps: :any
     
     
     11:17:32.494 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:32.494 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:32.495 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1125.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1116.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1117.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     


 17) test toilet (Membrane.Integration.AutoDemandsTest)
     test/membrane/integration/auto_demands_test.exs:159
     Assertion failed, no matching message after 2000ms
     Showing 10 of 15 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 1, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 2, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 4, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 5, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 6, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 7, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 8, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 9, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1131.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 10, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/auto_demands_test.exs:176: anonymous fn/2 in Membrane.Integration.AutoDemandsTest."test toilet"/1
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/auto_demands_test.exs:175: (test)

     The following output was logged:
     
     11:17:31.497 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1130.0>},
     process options: []
     
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, filter: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, source: Membrane.Integration.AutoDemandsTest.PushSource], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: nil, terminating?: false}]
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:31.497 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:31.497 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Starting child: name: :filter, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:31.497 [debug] [pipeline@<0.1131.0>] Element start: :filter
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1},
     
     
     11:17:31.497 [debug] [:filter] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}
     
     11:17:31.497 [debug] [:filter] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Starting child: name: :source, module: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Element start: :source
     node: ,
     module: Membrane.Integration.AutoDemandsTest.PushSource,
     element options: nil,
     
     
     11:17:31.498 [debug] [:source] Initializing element: Membrane.Integration.AutoDemandsTest.PushSource, options: nil
     
     11:17:31.498 [debug] [:source] Element initialized: Membrane.Integration.AutoDemandsTest.PushSource
     
     11:17:31.498 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:31.498 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:31.498 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:31.498 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Spec #Reference<0.3642608924.1448083458.156688> linked internally
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Spec playback init #Reference<0.3642608924.1448083458.156688> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1134.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1133.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.1135.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: :filter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :up, factor: 1}, pid: #PID<0.1134.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1133.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.PushSource, name: :source, options: nil, pid: #PID<0.1135.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156688>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Changing playback state from stopped to prepared
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Playback state changed from stopped to prepared
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Changing playback state from prepared to playing
     
     11:17:31.498 [debug] [:sink] Evaluating playback buffer
     
     11:17:31.498 [debug] [:filter] Evaluating playback buffer
     
     11:17:31.498 [debug] [:source] Sending caps through pad :output
     Caps: :any
     
     
     11:17:31.498 [debug] [:source] Evaluating playback buffer
     
     11:17:31.498 [debug] [:filter] Received caps on pad :input
     Caps: :any
     
     
     11:17:31.498 [debug] [pipeline@<0.1131.0>] Playback state changed from prepared to playing
     
     11:17:31.498 [debug] [:filter] Sending caps through pad :output
     Caps: :any
     
     
     11:17:31.498 [debug] [:sink] Received caps on pad :input
     Caps: :any
     
     
     11:17:32.494 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:32.494 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:32.495 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1125.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1116.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1117.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:32.495 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.495 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1122.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1116.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1117.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:32.496 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.496 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:32.498 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1138.0>},
     process options: []
     
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: nil, terminating?: false}]
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:32.499 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:32.499 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:32.499 [debug] [pipeline@<0.1139.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:32.499 [debug] [pipeline@<0.1139.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}
     
     
     11:17:32.499 [debug] [:test_bin bin] Initializing spec
     children: [filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.499 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: nil, terminating?: false}]
     
     11:17:32.499 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:32.499 [debug] [:test_bin bin] Bin start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:32.500 [debug] [:filter1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.500 [debug] [:filter1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: nil, terminating?: false}]
     
     11:17:32.500 [debug] [:filter1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.500 [debug] [:filter1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.500 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.500 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.500 [debug] [:filter1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.500 [debug] [:filter1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.500 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.500 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.501 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:32.501 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:32.501 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156766> linked internally
     
     11:17:32.501 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083458.156766> externally
     
     11:17:32.501 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:32.501 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:32.501 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.501 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: nil, terminating?: false}]
     
     11:17:32.501 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.501 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.502 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.502 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.502 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.502 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.502 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.502 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.502 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:32.502 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:32.502 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156785> linked internally
     
     11:17:32.502 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083458.156785> externally
     
     11:17:32.502 [debug] [:filter1 bin] Received link request on pad :input
     
     11:17:32.502 [debug] [:filter1 bin] Sending link response, :input
     
     11:17:32.502 [debug] [:filter2 bin] Received link request on pad :input
     
     11:17:32.502 [debug] [:filter1 bin] Received link request on pad :output
     
     11:17:32.502 [debug] [pipeline@<0.1139.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:32.502 [debug] [:filter2 bin] Sending link response, :input
     
     11:17:32.502 [debug] [:filter1 bin] Sending link response, :output
     
     11:17:32.502 [debug] [:filter2 bin] Received link request on pad :output
     
     11:17:32.502 [debug] [:filter2 bin] Sending link response, :output
     
     11:17:32.502 [debug] [pipeline@<0.1139.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:32.503 [debug] [:filter2] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:32.503 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:32.503 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:32.503 [debug] [:filter1] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:32.503 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156763> linked internally
     
     11:17:32.503 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156763> externally
     
     11:17:32.503 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:32.503 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:32.503 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:32.503 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:32.503 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:32.503 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:32.503 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156766> linked externally
     
     11:17:32.503 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083458.156766> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1146.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1147.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.504 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1146.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1147.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:32.504 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:32.504 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156785> linked externally
     
     11:17:32.504 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083458.156785> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1150.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1151.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.504 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1150.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1151.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156763> linked externally
     
     11:17:32.504 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156763> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1144.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1148.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.505 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1144.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1148.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Spec #Reference<0.3642608924.1448083458.156752> linked internally
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Spec playback init #Reference<0.3642608924.1448083458.156752> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1141.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1152.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1142.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1141.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1152.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1142.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:filter1 bin] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [:filter1 bin] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Changing playback state from prepared to playing
     
     11:17:32.505 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.505 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:32.505 [debug] [:sink] Evaluating playback buffer
     
     11:17:32.505 [debug] [:source] Evaluating playback buffer
     
     11:17:32.505 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:32.506 [debug] [:filter2] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter1 bin] Changing playback state from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter1] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter2] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter1 bin] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [pipeline@<0.1139.0>] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.499 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:33.499 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:33.499 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:33.500 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: :any,
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1134.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1131.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1132.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     


 18) test Starting and transmitting buffers when there are consecutive bins that are nested (Membrane.Core.BinTest)
     test/membrane/integration/bin_test.exs:79
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       b = 'a'
     Showing 7 of 7 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: ^b}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1139.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/bin_test.exs:326: anonymous fn/3 in Membrane.Core.BinTest.assert_buffers_flow_through/3
       (elixir 1.13.2) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/membrane/integration/bin_test.exs:317: Membrane.Core.BinTest.assert_data_flows_through/3
       test/membrane/integration/bin_test.exs:100: (test)

     The following output was logged:
     
     11:17:32.498 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1138.0>},
     process options: []
     
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: Membrane.Testing.Sink, test_bin: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}], links: [%{from: :test_bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :test_bin, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: nil, terminating?: false}]
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:32.498 [debug] [pipeline@<0.1139.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:32.499 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:32.499 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:32.499 [debug] [pipeline@<0.1139.0>] Starting child: name: :test_bin, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:32.499 [debug] [pipeline@<0.1139.0>] Bin start: :test_bin
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}
     
     
     11:17:32.499 [debug] [:test_bin bin] Initializing spec
     children: [filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.499 [debug] [:test_bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: nil, terminating?: false}]
     
     11:17:32.499 [debug] [:test_bin bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:32.499 [debug] [:test_bin bin] Bin start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:32.500 [debug] [:filter1 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.500 [debug] [:filter1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: nil, terminating?: false}]
     
     11:17:32.500 [debug] [:filter1 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.500 [debug] [:filter1 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.500 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.500 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.500 [debug] [:filter1 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.500 [debug] [:filter1 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.500 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.500 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.501 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:32.501 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:32.501 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156766> linked internally
     
     11:17:32.501 [debug] [:filter1 bin] Linking spec #Reference<0.3642608924.1448083458.156766> externally
     
     11:17:32.501 [debug] [:test_bin bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.SimpleBin
     
     11:17:32.501 [debug] [:test_bin bin] Bin start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.SimpleBin,
     bin options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}
     
     
     11:17:32.501 [debug] [:filter2 bin] Initializing spec
     children: [filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: :output, to_pad_props: %{}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {Membrane.Bin, :itself}, from_pad: :input, from_pad_props: %{}, to: :filter1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:32.501 [debug] [:filter2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: nil, terminating?: false}]
     
     11:17:32.501 [debug] [:filter2 bin] Starting child: name: :filter1, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.501 [debug] [:filter2 bin] Element start: :filter1
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.502 [debug] [:filter1] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.502 [debug] [:filter1] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.502 [debug] [:filter2 bin] Starting child: name: :filter2, module: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.502 [debug] [:filter2 bin] Element start: :filter2
     node: ,
     module: Membrane.Support.Bin.TestBins.TestFilter,
     element options: nil,
     
     
     11:17:32.502 [debug] [:filter2] Initializing element: Membrane.Support.Bin.TestBins.TestFilter, options: nil
     
     11:17:32.502 [debug] [:filter2] Element initialized: Membrane.Support.Bin.TestBins.TestFilter
     
     11:17:32.502 [debug] [:filter1] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:32.502 [debug] [:filter2] Element handle link on pad :input with pad :output of child :filter1
     
     11:17:32.502 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156785> linked internally
     
     11:17:32.502 [debug] [:filter2 bin] Linking spec #Reference<0.3642608924.1448083458.156785> externally
     
     11:17:32.502 [debug] [:filter1 bin] Received link request on pad :input
     
     11:17:32.502 [debug] [:filter1 bin] Sending link response, :input
     
     11:17:32.502 [debug] [:filter2 bin] Received link request on pad :input
     
     11:17:32.502 [debug] [:filter1 bin] Received link request on pad :output
     
     11:17:32.502 [debug] [pipeline@<0.1139.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:32.502 [debug] [:filter2 bin] Sending link response, :input
     
     11:17:32.502 [debug] [:filter1 bin] Sending link response, :output
     
     11:17:32.502 [debug] [:filter2 bin] Received link request on pad :output
     
     11:17:32.502 [debug] [:filter2 bin] Sending link response, :output
     
     11:17:32.502 [debug] [pipeline@<0.1139.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:32.503 [debug] [:filter2] Element handle link on pad :output with pad :input of child :filter2
     
     11:17:32.503 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:32.503 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:32.503 [debug] [:filter1] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:32.503 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156763> linked internally
     
     11:17:32.503 [debug] [:test_bin bin] Linking spec #Reference<0.3642608924.1448083458.156763> externally
     
     11:17:32.503 [debug] [:test_bin bin] Received link request on pad :input
     
     11:17:32.503 [debug] [:test_bin bin] Sending link response, :input
     
     11:17:32.503 [debug] [:test_bin bin] Received link request on pad :output
     
     11:17:32.503 [debug] [:test_bin bin] Sending link response, :output
     
     11:17:32.503 [debug] [:source] Element handle link on pad :output with pad :input of child :test_bin
     
     11:17:32.503 [debug] [:filter1] Element handle link on pad :input with pad :output of child :source
     
     11:17:32.503 [debug] [:filter1 bin] Spec #Reference<0.3642608924.1448083458.156766> linked externally
     
     11:17:32.503 [debug] [:filter1 bin] Spec playback init #Reference<0.3642608924.1448083458.156766> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1146.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1147.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.504 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1146.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:filter1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1147.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156766>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:filter2] Element handle link on pad :output with pad :input of child :sink
     
     11:17:32.504 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter2
     
     11:17:32.504 [debug] [:filter2 bin] Spec #Reference<0.3642608924.1448083458.156785> linked externally
     
     11:17:32.504 [debug] [:filter2 bin] Spec playback init #Reference<0.3642608924.1448083458.156785> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1150.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1151.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.504 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter1, options: nil, pid: #PID<0.1150.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:filter2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.Bin.TestBins.TestFilter, name: :filter2, options: nil, pid: #PID<0.1151.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156785>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.504 [debug] [:test_bin bin] Spec #Reference<0.3642608924.1448083458.156763> linked externally
     
     11:17:32.504 [debug] [:test_bin bin] Spec playback init #Reference<0.3642608924.1448083458.156763> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1144.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1148.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.505 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter1, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1144.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [:test_bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :filter2, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, pid: #PID<0.1148.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156763>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Spec #Reference<0.3642608924.1448083458.156752> linked internally
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Spec playback init #Reference<0.3642608924.1448083458.156752> %{sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1141.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1152.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}, test_bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1142.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1141.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1152.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.SimpleBin, name: :test_bin, options: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}, filter2: %Membrane.Support.Bin.TestBins.SimpleBin{filter1: Membrane.Support.Bin.TestBins.TestFilter, filter2: Membrane.Support.Bin.TestBins.TestFilter}}, pid: #PID<0.1142.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156752>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:test_bin bin] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:filter2 bin] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:filter1 bin] Changing playback state from stopped to prepared
     
     11:17:32.505 [debug] [:filter2 bin] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [:filter1 bin] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [:test_bin bin] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Playback state changed from stopped to prepared
     
     11:17:32.505 [debug] [pipeline@<0.1139.0>] Changing playback state from prepared to playing
     
     11:17:32.505 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.505 [debug] [:test_bin bin] Changing playback state from prepared to playing
     
     11:17:32.505 [debug] [:sink] Evaluating playback buffer
     
     11:17:32.505 [debug] [:source] Evaluating playback buffer
     
     11:17:32.505 [debug] [:filter2 bin] Changing playback state from prepared to playing
     
     11:17:32.506 [debug] [:filter2] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter1 bin] Changing playback state from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter1] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter2] Evaluating playback buffer
     
     11:17:32.506 [debug] [:filter2 bin] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter1 bin] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:test_bin bin] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [pipeline@<0.1139.0>] Playback state changed from prepared to playing
     
     11:17:32.506 [debug] [:filter1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:filter2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:32.506 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.499 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:33.499 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:33.499 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:33.500 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: :any,
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1134.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1131.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1132.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:33.500 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:33.500 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :up, factor: 1},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:output],
           auto_demand_size: 4000,
           availability: :always,
           caps: :any,
           demand: 3990,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1135.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: {Membrane.Core.Element.Toilet,
            #Reference<0.3642608924.1448214530.156713>, 200, #PID<0.1134.0>}
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [:input],
           auto_demand_size: nil,
           availability: :always,
           caps: :any,
           demand: 40,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1133.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1131.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1132.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:33.500 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: nil,
       module: Membrane.Integration.AutoDemandsTest.PushSource,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: :any,
           demand: nil,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :push,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1134.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: {Membrane.Core.Element.Toilet,
            #Reference<0.3642608924.1448214530.156713>, 200, #PID<0.1134.0>}
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :push,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1131.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1132.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:33.500 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:33.500 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:33.531 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1155.0>},
     process options: []
     
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}]
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:33.538 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:33.538 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.539 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.539 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]},
     
     
     11:17:33.541 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}
     
     11:17:33.541 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:33.541 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:33.541 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:33.541 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:33.541 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:33.541 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:33.541 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:33.541 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:33.541 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:33.541 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:33.541 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:33.541 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:33.541 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:33.541 [debug] [pipeline@<0.1156.0>] Spec #Reference<0.3642608924.1448083458.156856> linked internally
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Spec playback init #Reference<0.3642608924.1448083458.156856> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1158.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}, pid: #PID<0.1164.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1163.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1162.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1161.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1160.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1159.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1158.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}, pid: #PID<0.1164.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1163.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1162.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1161.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1160.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1159.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Changing playback state from stopped to prepared
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Playback state changed from stopped to prepared
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Changing playback state from prepared to playing
     
     11:17:33.542 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:33.542 [debug] [:sink] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:33.542 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:33.542 [debug] [:source] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.544 [debug] [pipeline@<0.1156.0>] Playback state changed from prepared to playing
     
     11:17:34.507 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:34.507 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:34.507 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:35.547 [warning] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{counter: 1, direction: :down, factor: 10},
  module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
  name: {:filter, 5},
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: 4000,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 3960,
      demand_mode: :auto,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :output,
      pid: #PID<0.1160.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :auto,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1158.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :auto,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :auto,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1156.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1157.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter
}


11:17:35.547 [debug] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 19) test buffers pass through auto-demand filters; setup: %{direction: :down, factor: 10, filters: 5, payloads: 1..4} (Membrane.Integration.AutoDemandsTest)
     test/membrane/integration/auto_demands_test.exs:53
     Assertion failed, no matching message after 2000ms
     Showing 10 of 20 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 2, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 3, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>, {:handle_element_end_of_stream, {{:filter, 1}, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>, {:handle_element_end_of_stream, {{:filter, 2}, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>, {:handle_element_end_of_stream, {{:filter, 3}, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>, {:handle_element_end_of_stream, {{:filter, 4}, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>, {:handle_element_end_of_stream, {{:filter, 5}, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 4, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, buffer}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1156.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/auto_demands_test.exs:82: anonymous fn/2 in Membrane.Integration.AutoDemandsTest."test buffers pass through auto-demand filters; setup: %{direction: :down, factor: 10, filters: 5, payloads: 1..4}"/1
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/auto_demands_test.exs:81: (test)

     The following output was logged:
     
     11:17:33.531 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1155.0>},
     process options: []
     
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [{:sink, Membrane.Testing.Sink}, {{:filter, 5}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 4}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 3}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 2}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {{:filter, 1}, %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}}, {:source, %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}}], links: [%{from: {:filter, 5}, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 4}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 5}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 3}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 4}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 2}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 3}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: {:filter, 1}, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 2}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {:filter, 1}, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: nil, terminating?: false}]
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:33.538 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:33.538 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 5}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 5}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 5}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 5}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 4}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 4}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 4}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 4}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 3}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 3}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 3}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 3}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 2}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.538 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 2}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.538 [debug] [{:filter, 2}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.538 [debug] [{:filter, 2}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Starting child: name: {:filter, 1}, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Element start: {:filter, 1}
     node: ,
     module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
     element options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10},
     
     
     11:17:33.539 [debug] [{:filter, 1}] Initializing element: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}
     
     11:17:33.539 [debug] [{:filter, 1}] Element initialized: Membrane.Integration.AutoDemandsTest.AutoDemandFilter
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:33.539 [debug] [pipeline@<0.1156.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]},
     
     
     11:17:33.541 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}
     
     11:17:33.541 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:33.541 [debug] [:source] Element handle link on pad :output with pad :input of child {:filter, 1}
     
     11:17:33.541 [debug] [{:filter, 1}] Element handle link on pad :input with pad :output of child :source
     
     11:17:33.541 [debug] [{:filter, 1}] Element handle link on pad :output with pad :input of child {:filter, 2}
     
     11:17:33.541 [debug] [{:filter, 2}] Element handle link on pad :input with pad :output of child {:filter, 1}
     
     11:17:33.541 [debug] [{:filter, 2}] Element handle link on pad :output with pad :input of child {:filter, 3}
     
     11:17:33.541 [debug] [{:filter, 3}] Element handle link on pad :input with pad :output of child {:filter, 2}
     
     11:17:33.541 [debug] [{:filter, 3}] Element handle link on pad :output with pad :input of child {:filter, 4}
     
     11:17:33.541 [debug] [{:filter, 4}] Element handle link on pad :input with pad :output of child {:filter, 3}
     
     11:17:33.541 [debug] [{:filter, 4}] Element handle link on pad :output with pad :input of child {:filter, 5}
     
     11:17:33.541 [debug] [{:filter, 5}] Element handle link on pad :input with pad :output of child {:filter, 4}
     
     11:17:33.541 [debug] [{:filter, 5}] Element handle link on pad :output with pad :input of child :sink
     
     11:17:33.541 [debug] [:sink] Element handle link on pad :input with pad :output of child {:filter, 5}
     
     11:17:33.541 [debug] [pipeline@<0.1156.0>] Spec #Reference<0.3642608924.1448083458.156856> linked internally
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Spec playback init #Reference<0.3642608924.1448083458.156856> %{:sink => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1158.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, :source => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}, pid: #PID<0.1164.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 1} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1163.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 2} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1162.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 3} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1161.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 4} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1160.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}, {:filter, 5} => %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1159.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1158.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]}, pid: #PID<0.1164.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 1}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1163.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 2}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1162.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 3}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1161.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 4}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1160.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter, name: {:filter, 5}, options: %Membrane.Integration.AutoDemandsTest.AutoDemandFilter{direction: :down, factor: 10}, pid: #PID<0.1159.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.156856>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Changing playback state from stopped to prepared
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Playback state changed from stopped to prepared
     
     11:17:33.542 [debug] [pipeline@<0.1156.0>] Changing playback state from prepared to playing
     
     11:17:33.542 [debug] [{:filter, 1}] Evaluating playback buffer
     
     11:17:33.542 [debug] [:sink] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 2}] Evaluating playback buffer
     
     11:17:33.542 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 3}] Evaluating playback buffer
     
     11:17:33.542 [debug] [:source] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 4}] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 1}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 5}] Evaluating playback buffer
     
     11:17:33.542 [debug] [{:filter, 1}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 2}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 2}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 3}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 3}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 4}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 4}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 5}] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [{:filter, 5}] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.542 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:33.544 [debug] [pipeline@<0.1156.0>] Playback state changed from prepared to playing
     
     11:17:34.507 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:34.507 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:34.507 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1146.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1139.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1140.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:34.508 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:34.508 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1151.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1139.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1140.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:34.508 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.545 [debug] [{:filter, 4}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.545 [debug] [{:filter, 1}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.545 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.545 [debug] [{:filter, 2}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.545 [debug] [{:filter, 5}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.546 [debug] [{:filter, 3}] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.546 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:35.546 [warning] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :down, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 1},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1164.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1162.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.546 [debug] [{:filter, 1}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.546 [warning] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :down, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 3},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1162.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3600,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1160.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.546 [debug] [{:filter, 3}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.546 [warning] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :down, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 4},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3600,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1161.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1159.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.547 [debug] [{:filter, 4}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.547 [warning] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :down, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 2},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1163.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1161.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.547 [debug] [{:filter, 2}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.547 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 4000,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1163.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:35.547 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1159.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:35.547 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.547 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.547 [warning] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{counter: 1, direction: :down, factor: 10},
       module: Membrane.Integration.AutoDemandsTest.AutoDemandFilter,
       name: {:filter, 5},
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: 4000,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 3960,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :output,
           pid: #PID<0.1160.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1158.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :auto,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1156.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1157.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.547 [debug] [{:filter, 5}] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
......
11:17:35.570 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: []
  },
  module: Membrane.Testing.Source,
  name: :a,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1200.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1197.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1198.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:35.570 [debug] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:35.570 [warning] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :c,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -6,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1200.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1197.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1198.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}



 20) test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts (Membrane.RemoteControlled.PipelineTest)
     test/membrane/remote_controlled/pipeline_test.exs:165
     ** (EXIT from #PID<0.1196.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.RemoteControlled.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}
          
              # 3
              %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:exec_actions, actions}-, _ctx, state)
              def handle_other(-{:subscription, pattern}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:35.558 [debug] Pipeline start link: module: Membrane.RemoteControlled.Pipeline,
     pipeline options: %{controller_pid: #PID<0.1196.0>},
     process options: []
     
     
     11:17:35.558 [debug] [pipeline@<0.1197.0>] Initializing spec
     children: [a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, b: Membrane.RemoteControlled.PipelineTest.Filter, c: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :b, from_pad: :output, from_pad_props: %{options: []}, to: :c, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :a, from_pad: :output, from_pad_props: %{options: []}, to: :b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:35.558 [debug] [pipeline@<0.1197.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: nil, terminating?: false}]
     
     11:17:35.558 [debug] [pipeline@<0.1197.0>] Starting child: name: :a, module: Membrane.Testing.Source
     
     11:17:35.558 [debug] [pipeline@<0.1197.0>] Element start: :a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]},
     
     
     11:17:35.558 [debug] [:a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}
     
     11:17:35.559 [debug] [:a] Element initialized: Membrane.Testing.Source
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Starting child: name: :b, module: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Element start: :b
     node: ,
     module: Membrane.RemoteControlled.PipelineTest.Filter,
     element options: nil,
     
     
     11:17:35.559 [debug] [:b] Initializing element: Membrane.RemoteControlled.PipelineTest.Filter, options: nil
     
     11:17:35.559 [debug] [:b] Element initialized: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Starting child: name: :c, module: Membrane.Testing.Sink
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Element start: :c
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:35.559 [debug] [:c] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:35.559 [debug] [:c] Element initialized: Membrane.Testing.Sink
     
     11:17:35.559 [debug] [:a] Element handle link on pad :output with pad :input of child :b
     
     11:17:35.559 [debug] [:b] Element handle link on pad :input with pad :output of child :a
     
     11:17:35.559 [debug] [:b] Element handle link on pad :output with pad :input of child :c
     
     11:17:35.559 [debug] [:c] Element handle link on pad :input with pad :output of child :b
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Spec #Reference<0.3642608924.1448083458.157114> linked internally
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Spec playback init #Reference<0.3642608924.1448083458.157114> %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.559 [debug] [pipeline@<0.1197.0>] Changing playback state from stopped to prepared
     
     11:17:35.560 [debug] [pipeline@<0.1197.0>] Playback state changed from stopped to prepared
     
     11:17:35.560 [debug] [pipeline@<0.1197.0>] Changing playback state from prepared to playing
     
     11:17:35.560 [debug] [:b] Evaluating playback buffer
     
     11:17:35.560 [debug] [:a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.560 [debug] [:a] Evaluating playback buffer
     
     11:17:35.560 [debug] [:c] Evaluating playback buffer
     
     11:17:35.560 [debug] [:b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.560 [debug] [:b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.560 [debug] [pipeline@<0.1197.0>] Playback state changed from prepared to playing
     
     11:17:35.560 [debug] [:c] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.560 [error] GenServer #PID<0.1197.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}
     State: %Membrane.Core.Pipeline.State{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1200.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :c, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1201.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1199.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1200.0>}}], module: Membrane.RemoteControlled.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1198.0>, timers: %{}}}
     
     11:17:35.569 [debug] [:a] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.569 [debug] [:c] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.569 [debug] [:b] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.570 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :a,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1200.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1197.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1198.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     


 21) test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern (Membrane.RemoteControlled.PipelineTest)
     test/membrane/remote_controlled/pipeline_test.exs:90
     ** (EXIT from #PID<0.1205.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.RemoteControlled.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}
          
              # 3
              %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:exec_actions, actions}-, _ctx, state)
              def handle_other(-{:subscription, pattern}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:35.570 [warning] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :c,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1200.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1197.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1198.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:35.570 [debug] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.570 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1199.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1200.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1201.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.157114>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1198.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1196.0>, matching_functions: [#Function<9.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<8.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>, #Function<7.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with pinned variables as message body parts"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{buffer_count: 4},
       module: Membrane.RemoteControlled.PipelineTest.Filter,
       name: :b,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 36,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1199.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1201.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1197.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1198.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.570 [debug] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.570 [debug] Pipeline start link: module: Membrane.RemoteControlled.Pipeline,
     pipeline options: %{controller_pid: #PID<0.1205.0>},
     process options: []
     
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Initializing spec
     children: [a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, b: Membrane.RemoteControlled.PipelineTest.Filter, c: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :b, from_pad: :output, from_pad_props: %{options: []}, to: :c, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :a, from_pad: :output, from_pad_props: %{options: []}, to: :b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: nil, terminating?: false}]
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Starting child: name: :a, module: Membrane.Testing.Source
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Element start: :a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]},
     
     
     11:17:35.571 [debug] [:a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}
     
     11:17:35.571 [debug] [:a] Element initialized: Membrane.Testing.Source
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Starting child: name: :b, module: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Element start: :b
     node: ,
     module: Membrane.RemoteControlled.PipelineTest.Filter,
     element options: nil,
     
     
     11:17:35.571 [debug] [:b] Initializing element: Membrane.RemoteControlled.PipelineTest.Filter, options: nil
     
     11:17:35.571 [debug] [:b] Element initialized: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Starting child: name: :c, module: Membrane.Testing.Sink
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Element start: :c
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:35.571 [debug] [:c] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:35.571 [debug] [:c] Element initialized: Membrane.Testing.Sink
     
     11:17:35.571 [debug] [:a] Element handle link on pad :output with pad :input of child :b
     
     11:17:35.571 [debug] [:b] Element handle link on pad :input with pad :output of child :a
     
     11:17:35.571 [debug] [:b] Element handle link on pad :output with pad :input of child :c
     
     11:17:35.571 [debug] [:c] Element handle link on pad :input with pad :output of child :b
     
     11:17:35.571 [debug] [pipeline@<0.1206.0>] Spec #Reference<0.3642608924.1448083460.156717> linked internally
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Spec playback init #Reference<0.3642608924.1448083460.156717> %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Changing playback state from stopped to prepared
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Playback state changed from stopped to prepared
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Changing playback state from prepared to playing
     
     11:17:35.572 [debug] [:b] Evaluating playback buffer
     
     11:17:35.572 [debug] [:a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.572 [debug] [:c] Evaluating playback buffer
     
     11:17:35.572 [debug] [:a] Evaluating playback buffer
     
     11:17:35.572 [debug] [:b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.572 [debug] [:b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.572 [debug] [pipeline@<0.1206.0>] Playback state changed from prepared to playing
     
     11:17:35.572 [debug] [:c] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.572 [error] GenServer #PID<0.1206.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}
     State: %Membrane.Core.Pipeline.State{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1209.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :c, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1210.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1208.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1209.0>}}], module: Membrane.RemoteControlled.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1207.0>, timers: %{}}}
     

11:17:35.577 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{buffer_count: 4},
  module: Membrane.RemoteControlled.PipelineTest.Filter,
  name: :b,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 36,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -6,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1217.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1219.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1215.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1216.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter
}


11:17:35.578 [debug] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:35.578 [warning] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :c,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -6,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1218.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1215.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1216.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}


11:17:35.578 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: []
  },
  module: Membrane.Testing.Source,
  name: :a,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1218.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1215.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1216.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:35.578 [debug] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:35.578 [debug] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 22) test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages (Membrane.RemoteControlled.PipelineTest)
     test/membrane/remote_controlled/pipeline_test.exs:120
     ** (EXIT from #PID<0.1214.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.RemoteControlled.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}
          
              # 3
              %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:exec_actions, actions}-, _ctx, state)
              def handle_other(-{:subscription, pattern}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:35.574 [debug] [:b] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.574 [debug] [:c] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.574 [debug] Pipeline start link: module: Membrane.RemoteControlled.Pipeline,
     pipeline options: %{controller_pid: #PID<0.1214.0>},
     process options: []
     
     
     11:17:35.574 [debug] [:a] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.574 [debug] [pipeline@<0.1215.0>] Initializing spec
     children: [a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, b: Membrane.RemoteControlled.PipelineTest.Filter, c: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :b, from_pad: :output, from_pad_props: %{options: []}, to: :c, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :a, from_pad: :output, from_pad_props: %{options: []}, to: :b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:35.574 [warning] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :c,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1209.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1206.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1207.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:35.574 [debug] [pipeline@<0.1215.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: nil, terminating?: false}]
     
     11:17:35.574 [debug] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.574 [debug] [pipeline@<0.1215.0>] Starting child: name: :a, module: Membrane.Testing.Source
     
     11:17:35.574 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :a,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1209.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1206.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1207.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:35.574 [debug] [pipeline@<0.1215.0>] Element start: :a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]},
     
     
     11:17:35.574 [debug] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.574 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1208.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1209.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1210.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156717>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1207.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1205.0>, matching_functions: [#Function<11.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>, #Function<10.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 should allow to use wildcards in subscription pattern"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{buffer_count: 4},
       module: Membrane.RemoteControlled.PipelineTest.Filter,
       name: :b,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 36,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1208.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1210.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1206.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1207.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.574 [debug] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.574 [debug] [:a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}
     
     11:17:35.574 [debug] [:a] Element initialized: Membrane.Testing.Source
     
     11:17:35.574 [debug] [pipeline@<0.1215.0>] Starting child: name: :b, module: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.574 [debug] [pipeline@<0.1215.0>] Element start: :b
     node: ,
     module: Membrane.RemoteControlled.PipelineTest.Filter,
     element options: nil,
     
     
     11:17:35.574 [debug] [:b] Initializing element: Membrane.RemoteControlled.PipelineTest.Filter, options: nil
     
     11:17:35.574 [debug] [:b] Element initialized: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Starting child: name: :c, module: Membrane.Testing.Sink
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Element start: :c
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:35.575 [debug] [:c] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:35.575 [debug] [:c] Element initialized: Membrane.Testing.Sink
     
     11:17:35.575 [debug] [:a] Element handle link on pad :output with pad :input of child :b
     
     11:17:35.575 [debug] [:b] Element handle link on pad :input with pad :output of child :a
     
     11:17:35.575 [debug] [:b] Element handle link on pad :output with pad :input of child :c
     
     11:17:35.575 [debug] [:c] Element handle link on pad :input with pad :output of child :b
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Spec #Reference<0.3642608924.1448083460.156799> linked internally
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Spec playback init #Reference<0.3642608924.1448083460.156799> %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Changing playback state from stopped to prepared
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Playback state changed from stopped to prepared
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Changing playback state from prepared to playing
     
     11:17:35.575 [debug] [:a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.575 [debug] [:b] Evaluating playback buffer
     
     11:17:35.575 [debug] [:a] Evaluating playback buffer
     
     11:17:35.575 [debug] [:c] Evaluating playback buffer
     
     11:17:35.575 [debug] [:b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.575 [debug] [pipeline@<0.1215.0>] Playback state changed from prepared to playing
     
     11:17:35.575 [debug] [:b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.575 [debug] [:c] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.575 [error] GenServer #PID<0.1215.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1218.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :c, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1219.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1217.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1218.0>}}], module: Membrane.RemoteControlled.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1216.0>, timers: %{}}}
     
     11:17:35.577 [debug] [:b] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.577 [debug] [:a] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.577 [debug] [:c] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.577 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{buffer_count: 4},
       module: Membrane.RemoteControlled.PipelineTest.Filter,
       name: :b,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 36,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1217.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1219.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1215.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1216.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.578 [debug] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:35.582 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: []
  },
  module: Membrane.Testing.Source,
  name: :a,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1227.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1224.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1225.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:35.582 [debug] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:35.582 [warning] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :c,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -6,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1227.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1224.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1225.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}


11:17:35.582 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{buffer_count: 4},
  module: Membrane.RemoteControlled.PipelineTest.Filter,
  name: :b,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 36,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -6,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1226.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1228.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1224.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1225.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter
}


11:17:35.582 [debug] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 23) test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified (Membrane.RemoteControlled.PipelineTest)
     test/membrane/remote_controlled/pipeline_test.exs:140
     ** (EXIT from #PID<0.1223.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.RemoteControlled.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}
          
              # 3
              %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:exec_actions, actions}-, _ctx, state)
              def handle_other(-{:subscription, pattern}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:35.578 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1217.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1218.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1219.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156799>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1216.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1214.0>, matching_functions: [#Function<3.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<2.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<1.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>, #Function<0.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :a,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1218.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1215.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1216.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:35.578 [debug] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.578 [debug] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.578 [debug] Pipeline start link: module: Membrane.RemoteControlled.Pipeline,
     pipeline options: %{controller_pid: #PID<0.1223.0>},
     process options: []
     
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Initializing spec
     children: [a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, b: Membrane.RemoteControlled.PipelineTest.Filter, c: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :b, from_pad: :output, from_pad_props: %{options: []}, to: :c, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :a, from_pad: :output, from_pad_props: %{options: []}, to: :b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: nil, terminating?: false}]
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Starting child: name: :a, module: Membrane.Testing.Source
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Element start: :a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]},
     
     
     11:17:35.578 [debug] [:a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}
     
     11:17:35.578 [debug] [:a] Element initialized: Membrane.Testing.Source
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Starting child: name: :b, module: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Element start: :b
     node: ,
     module: Membrane.RemoteControlled.PipelineTest.Filter,
     element options: nil,
     
     
     11:17:35.578 [debug] [:b] Initializing element: Membrane.RemoteControlled.PipelineTest.Filter, options: nil
     
     11:17:35.578 [debug] [:b] Element initialized: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.578 [debug] [pipeline@<0.1224.0>] Starting child: name: :c, module: Membrane.Testing.Sink
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Element start: :c
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:35.579 [debug] [:c] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:35.579 [debug] [:c] Element initialized: Membrane.Testing.Sink
     
     11:17:35.579 [debug] [:a] Element handle link on pad :output with pad :input of child :b
     
     11:17:35.579 [debug] [:b] Element handle link on pad :input with pad :output of child :a
     
     11:17:35.579 [debug] [:b] Element handle link on pad :output with pad :input of child :c
     
     11:17:35.579 [debug] [:c] Element handle link on pad :input with pad :output of child :b
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Spec #Reference<0.3642608924.1448083460.156875> linked internally
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Spec playback init #Reference<0.3642608924.1448083460.156875> %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Changing playback state from stopped to prepared
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Playback state changed from stopped to prepared
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Changing playback state from prepared to playing
     
     11:17:35.579 [debug] [:a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.579 [debug] [:a] Evaluating playback buffer
     
     11:17:35.579 [debug] [:b] Evaluating playback buffer
     
     11:17:35.579 [debug] [:b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.579 [debug] [:c] Evaluating playback buffer
     
     11:17:35.579 [debug] [:b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.579 [debug] [pipeline@<0.1224.0>] Playback state changed from prepared to playing
     
     11:17:35.579 [debug] [:c] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.579 [error] GenServer #PID<0.1224.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}
     State: %Membrane.Core.Pipeline.State{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1227.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :c, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1228.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1226.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1227.0>}}], module: Membrane.RemoteControlled.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1225.0>, timers: %{}}}
     
     11:17:35.581 [debug] [:a] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.581 [debug] [:b] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:35.581 [debug] [:c] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     

11:17:35.585 [debug] [:a] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:35.585 [debug] [:c] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:35.585 [debug] [:b] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:35.586 [warning] [:a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: []
  },
  module: Membrane.Testing.Source,
  name: :a,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1236.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1233.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1234.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:35.586 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{buffer_count: 4},
  module: Membrane.RemoteControlled.PipelineTest.Filter,
  name: :b,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 36,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -6,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1235.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 46,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1237.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1233.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1234.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter
}


11:17:35.586 [debug] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 24) test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events (Membrane.RemoteControlled.PipelineTest)
     test/membrane/remote_controlled/pipeline_test.exs:61
     ** (EXIT from #PID<0.1232.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.RemoteControlled.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}
          
              # 3
              %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:exec_actions, actions}-, _ctx, state)
              def handle_other(-{:subscription, pattern}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:35.582 [warning] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :c,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1227.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1224.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1225.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:35.582 [warning] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.RemoteControlled.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:b, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "test", pts: nil}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1226.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1227.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1228.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.156875>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1225.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1223.0>, matching_functions: [#Function<6.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<5.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>, #Function<4.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline await_* functions should await for requested messages with parts of message body not being specified"/1>]}], [file: 'lib/membrane/remote_controlled/pipeline.ex', line: 415]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{buffer_count: 4},
       module: Membrane.RemoteControlled.PipelineTest.Filter,
       name: :b,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 36,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1226.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 46,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1228.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1224.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1225.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:35.582 [debug] [:c] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.582 [debug] [:b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:35.582 [debug] Pipeline start link: module: Membrane.RemoteControlled.Pipeline,
     pipeline options: %{controller_pid: #PID<0.1232.0>},
     process options: []
     
     
     11:17:35.582 [debug] [pipeline@<0.1233.0>] Initializing spec
     children: [a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, b: Membrane.RemoteControlled.PipelineTest.Filter, c: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :b, from_pad: :output, from_pad_props: %{options: []}, to: :c, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :a, from_pad: :output, from_pad_props: %{options: []}, to: :b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: nil, terminating?: false}]
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Starting child: name: :a, module: Membrane.Testing.Source
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Element start: :a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]},
     
     
     11:17:35.583 [debug] [:a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}
     
     11:17:35.583 [debug] [:a] Element initialized: Membrane.Testing.Source
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Starting child: name: :b, module: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Element start: :b
     node: ,
     module: Membrane.RemoteControlled.PipelineTest.Filter,
     element options: nil,
     
     
     11:17:35.583 [debug] [:b] Initializing element: Membrane.RemoteControlled.PipelineTest.Filter, options: nil
     
     11:17:35.583 [debug] [:b] Element initialized: Membrane.RemoteControlled.PipelineTest.Filter
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Starting child: name: :c, module: Membrane.Testing.Sink
     
     11:17:35.583 [debug] [pipeline@<0.1233.0>] Element start: :c
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:35.583 [debug] [:c] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:35.583 [debug] [:c] Element initialized: Membrane.Testing.Sink
     
     11:17:35.584 [debug] [:a] Element handle link on pad :output with pad :input of child :b
     
     11:17:35.584 [debug] [:b] Element handle link on pad :input with pad :output of child :a
     
     11:17:35.584 [debug] [:b] Element handle link on pad :output with pad :input of child :c
     
     11:17:35.584 [debug] [:c] Element handle link on pad :input with pad :output of child :b
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Spec #Reference<0.3642608924.1448083461.156591> linked internally
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Spec playback init #Reference<0.3642608924.1448083461.156591> %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Changing playback state from stopped to prepared
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Playback state changed from stopped to prepared
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Changing playback state from prepared to playing
     
     11:17:35.584 [debug] [:c] Evaluating playback buffer
     
     11:17:35.584 [debug] [:a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.584 [debug] [:b] Evaluating playback buffer
     
     11:17:35.584 [debug] [:a] Evaluating playback buffer
     
     11:17:35.584 [debug] [pipeline@<0.1233.0>] Playback state changed from prepared to playing
     
     11:17:35.584 [debug] [:b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.584 [debug] [:b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.584 [debug] [:c] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:35.584 [error] GenServer #PID<0.1233.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.RemoteControlled.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/remote_controlled/pipeline.ex:415: Membrane.RemoteControlled.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1234.0>, playback_state: :playing}, %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:c, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: [161, 178, 195, 212]}, pid: #PID<0.1235.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RemoteControlled.PipelineTest.Filter, name: :b, options: nil, pid: #PID<0.1236.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}, c: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :c, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1237.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083461.156591>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.RemoteControlled.Pipeline.State{controller_pid: #PID<0.1232.0>, matching_functions: [#Function<20.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<19.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<18.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>, #Function<17.43177770/1 in Membrane.RemoteControlled.PipelineTest."test Membrane.RemoteControlled.Pipeline.subscribe/2 testing process should receive all subscribed events"/1>]}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1236.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :c, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1237.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1235.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1236.0>}}], module: Membrane.RemoteControlled.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1234.0>, timers: %{}}}
     
.........................................
11:17:35.599 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -7,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1414.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1410.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1411.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}


11:17:35.704 [debug] [:source] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}


11:17:35.704 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:35.704 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"

..
11:17:37.715 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: ['a', 'b', 'c'],
    output_for_pad: %{},
    type: :enum
  },
  module: Membrane.Testing.DynamicSource,
  name: :source,
  pads_data: %{},
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1441.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}

.
11:17:37.715 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:shutdown, :parent_crash}"


11:17:39.721 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: true,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -7,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1454.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1450.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1451.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}


11:17:39.721 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 25) test when element is connected to a bin and element is removed normally, handle_pad_removed should be called (Membrane.Integration.LinkingTest)
     test/membrane/integration/linking_test.exs:106
     Assertion failed, no matching message after 2000ms
     Showing 10 of 11 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Buffer{payload: 'a'}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>, {:playback_state_changed, :stopped, :prepared}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>, {:handle_element_start_of_stream, {:sink, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>, {:playback_state_changed, :prepared, :playing}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1450.0>, {:handle_element_end_of_stream, {:sink, :input}}}
     stacktrace:
       test/membrane/integration/linking_test.exs:122: (test)

     The following output was logged:
     
     11:17:37.715 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:37.716 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %{testing_pid: #PID<0.1449.0>}, module: Membrane.Integration.LinkingTest.Pipeline, test_process: #PID<0.1449.0>},
     process options: []
     
     
     11:17:37.716 [debug] [pipeline@<0.1450.0>] Initializing spec
     children: [bin: %Membrane.Integration.LinkingTest.Bin{child: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :bin, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:37.717 [debug] [pipeline@<0.1450.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.LinkingTest.Bin, name: :bin, options: %Membrane.Integration.LinkingTest.Bin{child: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160055>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160055>, sync: nil, terminating?: false}]
     
     11:17:37.717 [debug] [pipeline@<0.1450.0>] Starting child: name: :bin, module: Membrane.Integration.LinkingTest.Bin
     
     11:17:37.717 [debug] [pipeline@<0.1450.0>] Bin start: :bin
     node: ,
     module: Membrane.Integration.LinkingTest.Bin,
     bin options: %Membrane.Integration.LinkingTest.Bin{child: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}
     
     
     11:17:37.717 [debug] [:bin bin] Initializing spec
     children: [source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}]
     links: []
     
     
     11:17:37.717 [debug] [:bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160058>, sync: nil, terminating?: false}]
     
     11:17:37.717 [debug] [:bin bin] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:37.717 [debug] [:bin bin] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:37.717 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:37.718 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:37.718 [debug] [:bin bin] Spec #Reference<0.3642608924.1448083457.160058> linked internally
     
     11:17:37.718 [debug] [:bin bin] Linking spec #Reference<0.3642608924.1448083457.160058> externally
     
     11:17:37.718 [debug] [:bin bin] Spec #Reference<0.3642608924.1448083457.160058> linked externally
     
     11:17:37.718 [debug] [:bin bin] Spec playback init #Reference<0.3642608924.1448083457.160058> %{source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1454.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160058>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:37.718 [debug] [:bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1454.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160058>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:37.718 [debug] [pipeline@<0.1450.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:37.718 [debug] [pipeline@<0.1450.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:37.718 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:37.718 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:37.718 [debug] [:bin bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.157960>}
     
     11:17:37.719 [debug] [:bin bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.157960>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:37.719 [debug] [:bin bin] Starting children: []
     
     11:17:37.719 [debug] [:bin bin] Spec #Reference<0.3642608924.1448083457.160068> linked internally
     
     11:17:37.719 [debug] [:bin bin] Linking spec #Reference<0.3642608924.1448083457.160068> externally
     
     11:17:37.719 [debug] [:source] Element handle link on pad :output with pad :input of child :sink
     
     11:17:37.719 [debug] [:sink] Element handle link on pad :input with pad :output of child :source
     
     11:17:37.719 [debug] [:bin bin] Spec #Reference<0.3642608924.1448083457.160068> linked externally
     
     11:17:37.719 [debug] [:bin bin] Spec playback init #Reference<0.3642608924.1448083457.160068> %{source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1454.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160058>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:37.719 [debug] [pipeline@<0.1450.0>] Spec #Reference<0.3642608924.1448083457.160055> linked internally
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Spec playback init #Reference<0.3642608924.1448083457.160055> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.LinkingTest.Bin, name: :bin, options: %Membrane.Integration.LinkingTest.Bin{child: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1452.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160055>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1455.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160055>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Integration.LinkingTest.Bin, name: :bin, options: %Membrane.Integration.LinkingTest.Bin{child: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}}, pid: #PID<0.1452.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160055>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1455.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160055>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Changing playback state from stopped to prepared
     
     11:17:37.720 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:37.720 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Playback state changed from stopped to prepared
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Changing playback state from prepared to playing
     
     11:17:37.720 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:37.720 [debug] [:sink] Evaluating playback buffer
     
     11:17:37.720 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:37.720 [debug] [:source] Evaluating playback buffer
     
     11:17:37.720 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:37.720 [debug] [:bin bin] Playback state changed from prepared to playing
     
     11:17:37.720 [debug] [pipeline@<0.1450.0>] Playback state changed from prepared to playing
     
     11:17:39.720 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:39.720 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:39.720 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:39.721 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:42.146 [warning] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_1,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: {Membrane.Pad, :output,
       #Reference<0.3642608924.1448083460.157107>},
      pid: #PID<0.1465.0>,
      ref: :input,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1463.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1464.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}


11:17:42.146 [debug] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 26) test Source works properly when using generator function (Membrane.Testing.DynamicSourceTest)
     test/membrane/testing/dynamic_source_test.exs:50
     Assertion failed, no matching message after 2000ms
     Showing 10 of 419583 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Buffer{payload: <<0::16>>}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<50, 200>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "4&", pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "4'", pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<50, 201>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "4(", pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<50, 202>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: "4)", pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<50, 203>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<50, 204>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<0::16>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1463.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<50, 205>>, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/testing/dynamic_source_test.exs:65: (test)

     The following output was logged:
     
     11:17:39.723 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [source: Membrane.Testing.DynamicSource, sink_1: Membrane.Testing.Sink, sink_2: Membrane.Testing.Sink], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1462.0>},
     process options: []
     
     
     11:17:39.724 [debug] [pipeline@<0.1463.0>] Initializing spec
     children: [source: Membrane.Testing.DynamicSource, sink_1: Membrane.Testing.Sink, sink_2: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:39.724 [debug] [pipeline@<0.1463.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.DynamicSource, name: :source, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.DynamicSource.default_buf_gen/3}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_1, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_2, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: nil, terminating?: false}]
     
     11:17:39.724 [debug] [pipeline@<0.1463.0>] Starting child: name: :source, module: Membrane.Testing.DynamicSource
     
     11:17:39.724 [debug] [pipeline@<0.1463.0>] Element start: :source
     node: ,
     module: Membrane.Testing.DynamicSource,
     element options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.DynamicSource.default_buf_gen/3}},
     
     
     11:17:39.724 [debug] [:source] Initializing element: Membrane.Testing.DynamicSource, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.DynamicSource.default_buf_gen/3}}
     
     11:17:39.724 [debug] [:source] Element initialized: Membrane.Testing.DynamicSource
     
     11:17:39.725 [debug] [pipeline@<0.1463.0>] Starting child: name: :sink_1, module: Membrane.Testing.Sink
     
     11:17:39.725 [debug] [pipeline@<0.1463.0>] Element start: :sink_1
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:39.725 [debug] [:sink_1] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:39.725 [debug] [:sink_1] Element initialized: Membrane.Testing.Sink
     
     11:17:39.725 [debug] [pipeline@<0.1463.0>] Starting child: name: :sink_2, module: Membrane.Testing.Sink
     
     11:17:39.725 [debug] [pipeline@<0.1463.0>] Element start: :sink_2
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:39.725 [debug] [:sink_2] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:39.725 [debug] [:sink_2] Element initialized: Membrane.Testing.Sink
     
     11:17:39.725 [debug] [:source] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157107>} with pad :input of child :sink_1
     
     11:17:39.725 [debug] [:sink_1] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157107>} of child :source
     
     11:17:39.725 [debug] [:source] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157109>} with pad :input of child :sink_2
     
     11:17:39.726 [debug] [:sink_2] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157109>} of child :source
     
     11:17:39.726 [debug] [pipeline@<0.1463.0>] Spec #Reference<0.3642608924.1448083460.157088> linked internally
     
     11:17:39.726 [debug] [pipeline@<0.1463.0>] Spec playback init #Reference<0.3642608924.1448083460.157088> %{sink_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_1, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1466.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: :membrane_no_sync, terminating?: false}, sink_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_2, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1467.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.DynamicSource, name: :source, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.DynamicSource.default_buf_gen/3}}, pid: #PID<0.1465.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:39.726 [debug] [pipeline@<0.1463.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_1, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1466.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:39.726 [debug] [pipeline@<0.1463.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_2, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1467.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:39.726 [debug] [pipeline@<0.1463.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.DynamicSource, name: :source, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.DynamicSource.default_buf_gen/3}}, pid: #PID<0.1465.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157088>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:39.726 [debug] [pipeline@<0.1463.0>] Changing playback state from stopped to prepared
     
     11:17:39.727 [debug] [pipeline@<0.1463.0>] Playback state changed from stopped to prepared
     
     11:17:39.727 [debug] [pipeline@<0.1463.0>] Changing playback state from prepared to playing
     
     11:17:39.727 [debug] [:sink_1] Evaluating playback buffer
     
     11:17:39.727 [debug] [:sink_2] Evaluating playback buffer
     
     11:17:39.727 [debug] [:source] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157107>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:39.727 [debug] [:source] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157109>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:39.727 [debug] [:source] Evaluating playback buffer
     
     11:17:39.727 [debug] [:sink_1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:39.727 [debug] [:sink_2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:39.728 [debug] [pipeline@<0.1463.0>] Playback state changed from prepared to playing
     
     11:17:42.146 [debug] [:sink_2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:42.146 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:42.146 [debug] [:sink_1] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:42.146 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         generator: &Membrane.Testing.DynamicSource.default_buf_gen/3,
         generator_state: 0,
         output: {0, &Membrane.Testing.DynamicSource.default_buf_gen/3},
         state_for_pad: %{
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157107>} => 234670,
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157109>} => 234220
         },
         type: :generator
       },
       module: Membrane.Testing.DynamicSource,
       name: :source,
       pads_data: %{
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157107>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1466.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157107>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157109>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1467.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083460.157109>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1463.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1464.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:42.146 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:42.146 [warning] [:sink_2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -6,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083460.157109>},
           pid: #PID<0.1465.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1463.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1464.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:42.146 [debug] [:sink_2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:42.146 [warning] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_1,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083460.157107>},
           pid: #PID<0.1465.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1463.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1464.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:42.146 [debug] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
..
11:17:44.151 [debug] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 27) test Source works properly when payload are passed as enumerable (Membrane.Testing.DynamicSourceTest)
     test/membrane/testing/dynamic_source_test.exs:25
     Assertion failed, no matching message after 2000ms
     Showing 10 of 17 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification, {{:buffer, %Buffer{payload: 'a'}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_1,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink_1, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>, {:handle_element_end_of_stream, {:sink_1, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink_2, %Membrane.Testing.Notification{payload: {:start_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>, {:handle_element_start_of_stream, {:sink_2, :input}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'a', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'b', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink_2,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: 'c', pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [:sink_2, %Membrane.Testing.Notification{payload: {:end_of_stream, :input}}], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification, {{:buffer, %Membrane.Buffer{payload: 'a'}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1480.0>, {:handle_element_end_of_stream, {:sink_2, :input}}}
     stacktrace:
       test/membrane/testing/dynamic_source_test.exs:40: (test)

     The following output was logged:
     
     11:17:42.147 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [source: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, sink_1: Membrane.Testing.Sink, sink_2: Membrane.Testing.Sink], links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1479.0>},
     process options: []
     
     
     11:17:42.147 [debug] [pipeline@<0.1480.0>] Initializing spec
     children: [source: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, sink_1: Membrane.Testing.Sink, sink_2: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :sink_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:42.147 [debug] [pipeline@<0.1480.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.DynamicSource, name: :source, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_1, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_2, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: nil, terminating?: false}]
     
     11:17:42.147 [debug] [pipeline@<0.1480.0>] Starting child: name: :source, module: Membrane.Testing.DynamicSource
     
     11:17:42.147 [debug] [pipeline@<0.1480.0>] Element start: :source
     node: ,
     module: Membrane.Testing.DynamicSource,
     element options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']},
     
     
     11:17:42.147 [debug] [:source] Initializing element: Membrane.Testing.DynamicSource, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}
     
     11:17:42.147 [debug] [:source] Element initialized: Membrane.Testing.DynamicSource
     
     11:17:42.147 [debug] [pipeline@<0.1480.0>] Starting child: name: :sink_1, module: Membrane.Testing.Sink
     
     11:17:42.147 [debug] [pipeline@<0.1480.0>] Element start: :sink_1
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:42.148 [debug] [:sink_1] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:42.148 [debug] [:sink_1] Element initialized: Membrane.Testing.Sink
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Starting child: name: :sink_2, module: Membrane.Testing.Sink
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Element start: :sink_2
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:42.148 [debug] [:sink_2] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:42.148 [debug] [:sink_2] Element initialized: Membrane.Testing.Sink
     
     11:17:42.148 [debug] [:source] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155826>} with pad :input of child :sink_1
     
     11:17:42.148 [debug] [:sink_1] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155826>} of child :source
     
     11:17:42.148 [debug] [:source] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155828>} with pad :input of child :sink_2
     
     11:17:42.148 [debug] [:sink_2] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155828>} of child :source
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Spec #Reference<0.3642608924.1448083464.156895> linked internally
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Spec playback init #Reference<0.3642608924.1448083464.156895> %{sink_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_1, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1483.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: :membrane_no_sync, terminating?: false}, sink_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_2, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1484.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.DynamicSource, name: :source, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1482.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_1, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1483.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_2, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1484.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.DynamicSource, name: :source, options: %Membrane.Testing.DynamicSource{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ['a', 'b', 'c']}, pid: #PID<0.1482.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156895>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Changing playback state from stopped to prepared
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Playback state changed from stopped to prepared
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Changing playback state from prepared to playing
     
     11:17:42.148 [debug] [:sink_1] Evaluating playback buffer
     
     11:17:42.148 [debug] [:sink_2] Evaluating playback buffer
     
     11:17:42.148 [debug] [:source] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155826>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:42.148 [debug] [:source] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155828>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:42.148 [debug] [:sink_1] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:42.148 [debug] [:source] Evaluating playback buffer
     
     11:17:42.148 [debug] [:sink_2] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:42.148 [debug] [pipeline@<0.1480.0>] Playback state changed from prepared to playing
     
     11:17:44.149 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:44.149 [debug] [:sink_2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:44.150 [debug] [:sink_1] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:44.151 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: ['a', 'b', 'c'],
         output_for_pad: %{
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155826>} => [],
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155828>} => []
         },
         type: :enum
       },
       module: Membrane.Testing.DynamicSource,
       name: :source,
       pads_data: %{
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155826>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1483.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155826>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155828>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 47,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1484.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083463.155828>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1480.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1481.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:44.151 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:44.151 [warning] [:sink_2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_2,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155828>},
           pid: #PID<0.1482.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1480.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1481.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:44.151 [debug] [:sink_2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:44.151 [warning] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_1,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: true,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -7,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083463.155826>},
           pid: #PID<0.1482.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1480.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1481.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:44.151 [debug] [:sink_1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
.......
11:17:44.166 [warning] [:sink_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {{:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}, {GenServer, :call, [#PID<0.1525.0>, {:sync, []}, 5000]}},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_a,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1526.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1523.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1524.0>,
    stream_sync: #PID<0.1525.0>,
    timers: %{}
  },
  type: :sink
}


11:17:44.167 [warning] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_b,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1528.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1523.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1524.0>,
    stream_sync: #PID<0.1525.0>,
    timers: %{}
  },
  type: :sink
}


11:17:44.167 [warning] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: []
  },
  module: Membrane.Testing.Source,
  name: :source_a,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 39,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1527.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1523.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1524.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:44.167 [debug] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:44.167 [debug] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 28) test synchronization inside a bin is possible (Membrane.Integration.SyncTest)
     test/membrane/integration/sync_test.exs:135
     ** (EXIT from #PID<0.1520.0>) shutdown: :child_crash

     The following output was logged:
     
     11:17:44.156 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [bin: Membrane.Support.Sync.SyncBin], links: [], module: :default, test_process: #PID<0.1520.0>},
     process options: []
     
     
     11:17:44.156 [debug] [pipeline@<0.1521.0>] Initializing spec
     children: [bin: Membrane.Support.Sync.SyncBin]
     links: []
     
     
     11:17:44.158 [debug] [pipeline@<0.1521.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Sync.SyncBin, name: :bin, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160198>, sync: nil, terminating?: false}]
     
     11:17:44.158 [debug] [pipeline@<0.1521.0>] Starting child: name: :bin, module: Membrane.Support.Sync.SyncBin
     
     11:17:44.158 [debug] [pipeline@<0.1521.0>] Bin start: :bin
     node: ,
     module: Membrane.Support.Sync.SyncBin,
     bin options: nil
     
     
     11:17:44.161 [debug] [:bin bin] Initializing spec
     children: [source_a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, sink_a: %Membrane.Testing.Sink{autodemand: true}, source_b: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, sink_b: %Membrane.Testing.Sink{autodemand: true}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_a, from_pad: :output, from_pad_props: %{options: []}, to: :sink_a, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_b, from_pad: :output, from_pad_props: %{options: []}, to: :sink_b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:44.161 [debug] [:bin bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: nil, terminating?: false}]
     
     11:17:44.161 [debug] [:bin bin] Starting child: name: :source_a, module: Membrane.Testing.Source
     
     11:17:44.161 [debug] [:bin bin] Element start: :source_a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]},
     
     
     11:17:44.161 [debug] [:source_a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}
     
     11:17:44.161 [debug] [:source_a] Element initialized: Membrane.Testing.Source
     
     11:17:44.162 [debug] [:bin bin] Starting child: name: :sink_a, module: Membrane.Testing.Sink
     
     11:17:44.162 [debug] [:bin bin] Element start: :sink_a
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.162 [debug] [:sink_a] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.162 [debug] [:sink_a] Element initialized: Membrane.Testing.Sink
     
     11:17:44.162 [debug] [:bin bin] Starting child: name: :source_b, module: Membrane.Testing.Source
     
     11:17:44.162 [debug] [:bin bin] Element start: :source_b
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}},
     
     
     11:17:44.162 [debug] [:source_b] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}
     
     11:17:44.162 [debug] [:source_b] Element initialized: Membrane.Testing.Source
     
     11:17:44.162 [debug] [:bin bin] Starting child: name: :sink_b, module: Membrane.Testing.Sink
     
     11:17:44.162 [debug] [:bin bin] Element start: :sink_b
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.162 [debug] [:sink_b] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.162 [debug] [:sink_b] Element initialized: Membrane.Testing.Sink
     
     11:17:44.162 [debug] [:source_a] Element handle link on pad :output with pad :input of child :sink_a
     
     11:17:44.162 [debug] [:sink_a] Element handle link on pad :input with pad :output of child :source_a
     
     11:17:44.162 [debug] [:source_b] Element handle link on pad :output with pad :input of child :sink_b
     
     11:17:44.163 [debug] [:sink_b] Element handle link on pad :input with pad :output of child :source_b
     
     11:17:44.163 [debug] [:bin bin] Spec #Reference<0.3642608924.1448083464.156992> linked internally
     
     11:17:44.163 [debug] [:bin bin] Linking spec #Reference<0.3642608924.1448083464.156992> externally
     
     11:17:44.163 [debug] [:bin bin] Spec #Reference<0.3642608924.1448083464.156992> linked externally
     
     11:17:44.163 [debug] [:bin bin] Spec playback init #Reference<0.3642608924.1448083464.156992> %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.163 [debug] [:bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}
     
     11:17:44.163 [debug] [:bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}
     
     11:17:44.163 [debug] [:bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.163 [debug] [:bin bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.163 [debug] [pipeline@<0.1521.0>] Spec #Reference<0.3642608924.1448083457.160198> linked internally
     
     11:17:44.163 [debug] [pipeline@<0.1521.0>] Spec playback init #Reference<0.3642608924.1448083457.160198> %{bin: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Sync.SyncBin, name: :bin, options: nil, pid: #PID<0.1523.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160198>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.163 [debug] [pipeline@<0.1521.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Sync.SyncBin, name: :bin, options: nil, pid: #PID<0.1523.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160198>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.163 [debug] [pipeline@<0.1521.0>] Changing playback state from stopped to prepared
     
     11:17:44.163 [debug] [:bin bin] Changing playback state from stopped to prepared
     
     11:17:44.164 [debug] [:bin bin] Playback state changed from stopped to prepared
     
     11:17:44.164 [debug] [pipeline@<0.1521.0>] Playback state changed from stopped to prepared
     
     11:17:44.164 [debug] [pipeline@<0.1521.0>] Changing playback state from prepared to playing
     
     11:17:44.164 [debug] [:bin bin] Changing playback state from prepared to playing
     
     11:17:44.164 [debug] [:sink_a] Evaluating playback buffer
     
     11:17:44.164 [debug] [:sink_b] Evaluating playback buffer
     
     11:17:44.164 [debug] [:source_a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.164 [debug] [:source_a] Evaluating playback buffer
     
     11:17:44.164 [debug] [:source_b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.164 [debug] [:source_b] Evaluating playback buffer
     
     11:17:44.164 [debug] [:sink_a] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.164 [debug] [:sink_b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.164 [error] GenServer #PID<0.1523.0> terminating
     ** (UndefinedFunctionError) function Membrane.Support.Sync.SyncBin.handle_parent_notification/4 is undefined or private
         (membrane_core 0.10.1) Membrane.Support.Sync.SyncBin.handle_parent_notification(:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Bin.State{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, children_log_metadata: [parent_path: ["pipeline@<0.1521.0>"]], crash_groups: %{}, delayed_playback_change: nil, internal_state: %{}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1528.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1529.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1526.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1527.0>}}], module: Membrane.Support.Sync.SyncBin, name: :bin, pads_data: %{}, pads_info: %{}, parent_pid: #PID<0.1521.0>, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock: nil, clock_provider: %{choice: :auto, clock: #PID<0.1522.0>, provider: Membrane.Parent}, clock_proxy: #PID<0.1524.0>, latency: 0, parent_clock: #PID<0.1522.0>, stream_sync: :membrane_no_sync, timers: %{}}}
     
     11:17:44.166 [debug] [pipeline@<0.1521.0>] Pipeline child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:44.166 [debug] [pipeline@<0.1521.0>] A child crashed but was not a member of any crash group.
     Terminating.
     
     
     11:17:44.166 [debug] [:sink_b] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:44.166 [debug] [:source_a] Shutting down because of pipeline failure
     Reason: {:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:44.166 [warning] [:sink_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {{:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}, {GenServer, :call, [#PID<0.1525.0>, {:sync, []}, 5000]}},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_a,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1526.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1523.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1524.0>,
         stream_sync: #PID<0.1525.0>,
         timers: %{}
       },
       type: :sink
     }
     
     


 29) test synchronize dynamically spawned elements (Membrane.Integration.SyncTest)
     test/membrane/integration/sync_test.exs:58
     ** (EXIT from #PID<0.1533.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.Sync.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}
          
              # 3
              %{}
          
          Attempted function clauses (showing 1 out of 1):
          
              def handle_other(-{:spawn_children, spec}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:44.167 [warning] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_b,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1528.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1523.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1524.0>,
         stream_sync: #PID<0.1525.0>,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:44.167 [warning] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:undef, [{Membrane.Support.Sync.SyncBin, :handle_parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{}], []}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Bin, :handle_info, 2, [file: 'lib/membrane/core/bin.ex', line: 138]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source_a,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 39,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1527.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1523.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1524.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:44.167 [debug] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:44.167 [debug] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:44.167 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %Membrane.ParentSpec{children: %{}, clock_provider: nil, crash_group: nil, links: [], log_metadata: [], node: nil, stream_sync: []}, module: Membrane.Support.Sync.Pipeline, test_process: #PID<0.1533.0>},
     process options: []
     
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Initializing spec
     children: %{}
     links: []
     
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Starting children: []
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Spec #Reference<0.3642608924.1448083463.155873> linked internally
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Spec playback init #Reference<0.3642608924.1448083463.155873> %{}
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Changing playback state from stopped to prepared
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Playback state changed from stopped to prepared
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Changing playback state from prepared to playing
     
     11:17:44.167 [debug] [pipeline@<0.1534.0>] Playback state changed from prepared to playing
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Initializing spec
     children: [source_a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, sink_a: %Membrane.Testing.Sink{autodemand: true}, source_b: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, sink_b: %Membrane.Testing.Sink{autodemand: true}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_a, from_pad: :output, from_pad_props: %{options: []}, to: :sink_a, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_b, from_pad: :output, from_pad_props: %{options: []}, to: :sink_b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: nil, terminating?: false}]
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Starting child: name: :source_a, module: Membrane.Testing.Source
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Element start: :source_a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]},
     
     
     11:17:44.168 [debug] [:source_a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}
     
     11:17:44.168 [debug] [:source_a] Element initialized: Membrane.Testing.Source
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Starting child: name: :sink_a, module: Membrane.Testing.Sink
     
     11:17:44.166 [error] GenServer #PID<0.1527.0> terminating
     ** (stop) exited in: GenServer.call(#PID<0.1525.0>, {:sync, []}, 5000)
         ** (EXIT) an exception was raised:
             ** (UndefinedFunctionError) function Membrane.Support.Sync.SyncBin.handle_parent_notification/4 is undefined or private
                 (membrane_core 0.10.1) Membrane.Support.Sync.SyncBin.handle_parent_notification(:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}, %Membrane.Bin.CallbackContext.ParentNotification{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1527.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1529.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: #PID<0.1525.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1526.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1528.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083464.156992>, sync: :membrane_no_sync, terminating?: false}}, clock: nil, name: :bin, pads: %{}, parent_clock: #PID<0.1522.0>, playback_state: :prepared}, %{})
                 (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
                 (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
                 (membrane_core 0.10.1) lib/membrane/core/bin.ex:138: Membrane.Core.Bin.handle_info/2
                 (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
                 (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
                 (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
         (elixir 1.13.2) lib/gen_server.ex:1030: GenServer.call/3
         (membrane_core 0.10.1) lib/membrane/core/element/event_controller.ex:102: Membrane.Core.Element.EventController.check_sync/2
         (membrane_core 0.10.1) lib/membrane/core/element/event_controller.ex:51: Membrane.Core.Element.EventController.exec_handle_event/4
         (membrane_core 0.10.1) lib/membrane/core/element/playback_buffer.ex:143: Membrane.Core.Element.PlaybackBuffer.exec/2
         (membrane_core 0.10.1) lib/membrane/core/element.ex:173: Membrane.Core.Element.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :buffer, [%Membrane.Buffer{dts: nil, metadata: %{}, payload: "a", pts: nil}], [for_pad: :input]}
     State: %Membrane.Core.Element.State{delayed_demands: #MapSet<[]>, demand_size: nil, internal_state: %Membrane.Testing.Sink{autodemand: true}, module: Membrane.Testing.Sink, name: :sink_a, pads_data: %{input: %Membrane.Element.PadData{accepted_caps: :any, associated_pads: [], auto_demand_size: nil, availability: :always, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, demand: 1, demand_mode: :manual, demand_unit: :buffers, direction: :input, end_of_stream?: false, input_queue: %Membrane.Core.Element.InputQueue{demand: 0, log_tag: ":input", metric: Membrane.Buffer.Metric.Count, min_demand: 10, q: #Qex<[]>, size: 0, target_size: 40, toilet?: false}, mode: :pull, name: :input, options: %{}, other_demand_unit: nil, other_ref: :output, pid: #PID<0.1526.0>, ref: :input, start_of_stream?: false, sticky_messages: [], toilet: nil}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}}, parent_pid: #PID<0.1523.0>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.1524.0>, stream_sync: #PID<0.1525.0>, timers: %{}}, type: :sink}
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Element start: :sink_a
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.168 [debug] [:sink_a] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.168 [debug] [:sink_a] Element initialized: Membrane.Testing.Sink
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Starting child: name: :source_b, module: Membrane.Testing.Source
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Element start: :source_b
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}},
     
     
     11:17:44.168 [debug] [:source_b] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}
     
     11:17:44.168 [debug] [:source_b] Element initialized: Membrane.Testing.Source
     
     11:17:44.168 [debug] [pipeline@<0.1534.0>] Starting child: name: :sink_b, module: Membrane.Testing.Sink
     
     11:17:44.169 [debug] [pipeline@<0.1534.0>] Element start: :sink_b
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.169 [debug] [:sink_b] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.169 [debug] [:sink_b] Element initialized: Membrane.Testing.Sink
     
     11:17:44.169 [debug] [:source_a] Element handle link on pad :output with pad :input of child :sink_a
     
     11:17:44.169 [debug] [:sink_a] Element handle link on pad :input with pad :output of child :source_a
     
     11:17:44.169 [debug] [:source_b] Element handle link on pad :output with pad :input of child :sink_b
     
     11:17:44.169 [debug] [:sink_b] Element handle link on pad :input with pad :output of child :source_b
     
     11:17:44.169 [debug] [pipeline@<0.1534.0>] Spec #Reference<0.3642608924.1448083463.155877> linked internally
     
     11:17:44.169 [debug] [pipeline@<0.1534.0>] Spec playback init #Reference<0.3642608924.1448083463.155877> %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.169 [debug] [pipeline@<0.1534.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}
     
     11:17:44.169 [debug] [pipeline@<0.1534.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}
     
     11:17:44.169 [debug] [:sink_a] Evaluating playback buffer
     
     11:17:44.169 [debug] [pipeline@<0.1534.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.170 [debug] [:sink_b] Evaluating playback buffer
     
     11:17:44.170 [debug] [:source_a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.170 [debug] [:source_a] Evaluating playback buffer
     
     11:17:44.170 [debug] [pipeline@<0.1534.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.170 [debug] [:sink_a] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.170 [debug] [:source_b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.170 [debug] [:source_b] Evaluating playback buffer
     
     11:17:44.170 [debug] [:sink_b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.170 [error] GenServer #PID<0.1534.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.Sync.Pipeline, test_process: #PID<0.1533.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1539.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1540.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1537.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1538.0>}}], module: Membrane.Testing.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1535.0>, timers: %{}}}
     
     11:17:44.172 [debug] [:source_a] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:44.172 [debug] [:sink_b] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:44.172 [warning] [:sink_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {{:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}, {GenServer, :call, [#PID<0.1536.0>, {:sync, []}, 5000]}},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_a,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1537.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1534.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1535.0>,
         stream_sync: #PID<0.1536.0>,
         timers: %{}
       },
       type: :sink
     }
     
     

11:17:44.176 [warning] [:sink_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {{:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}, {GenServer, :call, [#PID<0.1547.0>, {:sync, []}, 5000]}},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_a,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1548.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1545.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1546.0>,
    stream_sync: #PID<0.1547.0>,
    timers: %{}
  },
  type: :sink
}


11:17:44.177 [warning] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    output: []
  },
  module: Membrane.Testing.Source,
  name: :source_a,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 39,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: true,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1549.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1545.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:44.177 [debug] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:44.177 [warning] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_b,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1550.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1545.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1546.0>,
    stream_sync: #PID<0.1547.0>,
    timers: %{}
  },
  type: :sink
}


11:17:44.178 [warning] [:el1] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    generator_state: 0,
    output: &Membrane.Testing.Source.default_buf_gen/2
  },
  module: Membrane.Testing.Source,
  name: :el1,
  pads_data: %{},
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1556.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1557.0>,
    stream_sync: #PID<0.1558.0>,
    timers: %{}
  },
  type: :source
}


11:17:44.178 [debug] [:el1] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:shutdown, :parent_crash}"



 30) test synchronize selected groups (Membrane.Integration.SyncTest)
     test/membrane/integration/sync_test.exs:78
     ** (EXIT from #PID<0.1544.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.Sync.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 1 out of 1):
          
              def handle_other(-{:spawn_children, spec}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:44.172 [warning] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         output: []
       },
       module: Membrane.Testing.Source,
       name: :source_a,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 39,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: true,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1538.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1534.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1535.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:44.172 [debug] [:source_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:44.172 [warning] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_b,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1539.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1534.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1535.0>,
         stream_sync: #PID<0.1536.0>,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:44.172 [debug] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:44.172 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %Membrane.ParentSpec{children: [source_a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, sink_a: %Membrane.Testing.Sink{autodemand: true}, source_b: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, sink_b: %Membrane.Testing.Sink{autodemand: true}], clock_provider: nil, crash_group: nil, links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_a, from_pad: :output, from_pad_props: %{options: []}, to: :sink_a, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_b, from_pad: :output, from_pad_props: %{options: []}, to: :sink_b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], log_metadata: [], node: nil, stream_sync: [[:sink_a, :sink_b]]}, module: Membrane.Support.Sync.Pipeline, test_process: #PID<0.1544.0>},
     process options: []
     
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Initializing spec
     children: [source_a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, sink_a: %Membrane.Testing.Sink{autodemand: true}, source_b: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, sink_b: %Membrane.Testing.Sink{autodemand: true}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_a, from_pad: :output, from_pad_props: %{options: []}, to: :sink_a, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_b, from_pad: :output, from_pad_props: %{options: []}, to: :sink_b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: nil, terminating?: false}]
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Starting child: name: :source_a, module: Membrane.Testing.Source
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Element start: :source_a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]},
     
     
     11:17:44.172 [error] GenServer #PID<0.1538.0> terminating
     ** (stop) exited in: GenServer.call(#PID<0.1536.0>, {:sync, []}, 5000)
         ** (EXIT) an exception was raised:
             ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
                 (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1538.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1540.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: #PID<0.1536.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1537.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1539.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.155877>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1535.0>, playback_state: :playing}, %{})
                 (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
                 (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
                 (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
                 (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
                 (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
                 (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
                 (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
                 (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
         (elixir 1.13.2) lib/gen_server.ex:1030: GenServer.call/3
         (membrane_core 0.10.1) lib/membrane/core/element/event_controller.ex:102: Membrane.Core.Element.EventController.check_sync/2
         (membrane_core 0.10.1) lib/membrane/core/element/event_controller.ex:51: Membrane.Core.Element.EventController.exec_handle_event/4
         (membrane_core 0.10.1) lib/membrane/core/element/playback_buffer.ex:143: Membrane.Core.Element.PlaybackBuffer.exec/2
         (membrane_core 0.10.1) lib/membrane/core/element.ex:173: Membrane.Core.Element.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :buffer, [%Membrane.Buffer{dts: nil, metadata: %{}, payload: "a", pts: nil}], [for_pad: :input]}
     State: %Membrane.Core.Element.State{delayed_demands: #MapSet<[]>, demand_size: nil, internal_state: %Membrane.Testing.Sink{autodemand: true}, module: Membrane.Testing.Sink, name: :sink_a, pads_data: %{input: %Membrane.Element.PadData{accepted_caps: :any, associated_pads: [], auto_demand_size: nil, availability: :always, caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, demand: 1, demand_mode: :manual, demand_unit: :buffers, direction: :input, end_of_stream?: false, input_queue: %Membrane.Core.Element.InputQueue{demand: 0, log_tag: ":input", metric: Membrane.Buffer.Metric.Count, min_demand: 10, q: #Qex<[]>, size: 0, target_size: 40, toilet?: false}, mode: :pull, name: :input, options: %{}, other_demand_unit: nil, other_ref: :output, pid: #PID<0.1537.0>, ref: :input, start_of_stream?: false, sticky_messages: [], toilet: nil}}, pads_info: %{input: %{accepted_caps: :any, availability: :always, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}}, parent_pid: #PID<0.1534.0>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.1535.0>, stream_sync: #PID<0.1536.0>, timers: %{}}, type: :sink}
     
     11:17:44.173 [debug] [:source_a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}
     
     11:17:44.173 [debug] [:source_a] Element initialized: Membrane.Testing.Source
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Starting child: name: :sink_a, module: Membrane.Testing.Sink
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Element start: :sink_a
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.173 [debug] [:sink_a] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.173 [debug] [:sink_a] Element initialized: Membrane.Testing.Sink
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Starting child: name: :source_b, module: Membrane.Testing.Source
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Element start: :source_b
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}},
     
     
     11:17:44.173 [debug] [:source_b] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}
     
     11:17:44.173 [debug] [:source_b] Element initialized: Membrane.Testing.Source
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Starting child: name: :sink_b, module: Membrane.Testing.Sink
     
     11:17:44.173 [debug] [pipeline@<0.1545.0>] Element start: :sink_b
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.174 [debug] [:sink_b] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.174 [debug] [:sink_b] Element initialized: Membrane.Testing.Sink
     
     11:17:44.174 [debug] [:source_a] Element handle link on pad :output with pad :input of child :sink_a
     
     11:17:44.174 [debug] [:sink_a] Element handle link on pad :input with pad :output of child :source_a
     
     11:17:44.174 [debug] [:source_b] Element handle link on pad :output with pad :input of child :sink_b
     
     11:17:44.174 [debug] [:sink_b] Element handle link on pad :input with pad :output of child :source_b
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Spec #Reference<0.3642608924.1448083462.157439> linked internally
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Spec playback init #Reference<0.3642608924.1448083462.157439> %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Changing playback state from stopped to prepared
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Playback state changed from stopped to prepared
     
     11:17:44.174 [debug] [pipeline@<0.1545.0>] Changing playback state from prepared to playing
     
     11:17:44.174 [debug] [:sink_b] Evaluating playback buffer
     
     11:17:44.174 [debug] [:sink_a] Evaluating playback buffer
     
     11:17:44.174 [debug] [:source_a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.174 [debug] [:source_b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.175 [debug] [:source_a] Evaluating playback buffer
     
     11:17:44.175 [debug] [:source_b] Evaluating playback buffer
     
     11:17:44.175 [debug] [:sink_a] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.175 [debug] [:sink_b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.175 [error] GenServer #PID<0.1545.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.Sync.Pipeline, test_process: #PID<0.1544.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1550.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1551.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1548.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1549.0>}}], module: Membrane.Testing.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1546.0>, timers: %{}}}
     
     11:17:44.176 [debug] [:source_a] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:44.176 [debug] [:sink_b] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:44.176 [warning] [:sink_a] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {{:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1549.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1551.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: #PID<0.1547.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1548.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1550.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083462.157439>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1546.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}, {GenServer, :call, [#PID<0.1547.0>, {:sync, []}, 5000]}},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink_a,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1548.0>,
           ref: :input,
           start_of_stream?: false,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1545.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1546.0>,
         stream_sync: #PID<0.1547.0>,
         timers: %{}
       },
       type: :sink
     }
     
     
.
11:17:44.182 [debug] [:sink_b] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1565.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:44.183 [warning] [:sink_a] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {{:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1565.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}, {GenServer, :call, [#PID<0.1566.0>, {:sync, []}, 5000]}},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_a,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1567.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1564.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1565.0>,
    stream_sync: #PID<0.1566.0>,
    timers: %{}
  },
  type: :sink
}


11:17:44.183 [debug] [:source_a] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1565.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:44.183 [warning] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.Sync.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1565.0>, playback_state: :prepared}, %{}], [file: 'test/support/sync/pipeline.ex', line: 40]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink_b,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[]>,
        size: 0,
        target_size: 40,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1569.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1564.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1565.0>,
    stream_sync: #PID<0.1566.0>,
    timers: %{}
  },
  type: :sink
}


11:17:44.183 [debug] [:sink_b] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 31) test synchronize sinks (Membrane.Integration.SyncTest)
     test/membrane/integration/sync_test.exs:43
     ** (EXIT from #PID<0.1563.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.Sync.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1565.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 1 out of 1):
          
              def handle_other(-{:spawn_children, spec}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:44.179 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %Membrane.ParentSpec{children: [source_a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, sink_a: %Membrane.Testing.Sink{autodemand: true}, source_b: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, sink_b: %Membrane.Testing.Sink{autodemand: true}], clock_provider: nil, crash_group: nil, links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_a, from_pad: :output, from_pad_props: %{options: []}, to: :sink_a, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_b, from_pad: :output, from_pad_props: %{options: []}, to: :sink_b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], log_metadata: [], node: nil, stream_sync: :sinks}, module: Membrane.Support.Sync.Pipeline, test_process: #PID<0.1563.0>},
     process options: []
     
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Initializing spec
     children: [source_a: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, sink_a: %Membrane.Testing.Sink{autodemand: true}, source_b: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, sink_b: %Membrane.Testing.Sink{autodemand: true}]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_a, from_pad: :output, from_pad_props: %{options: []}, to: :sink_a, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_b, from_pad: :output, from_pad_props: %{options: []}, to: :sink_b, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: nil, terminating?: false}]
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Starting child: name: :source_a, module: Membrane.Testing.Source
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Element start: :source_a
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]},
     
     
     11:17:44.179 [debug] [:source_a] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}
     
     11:17:44.179 [debug] [:source_a] Element initialized: Membrane.Testing.Source
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Starting child: name: :sink_a, module: Membrane.Testing.Sink
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Element start: :sink_a
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.179 [debug] [:sink_a] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.179 [debug] [:sink_a] Element initialized: Membrane.Testing.Sink
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Starting child: name: :source_b, module: Membrane.Testing.Source
     
     11:17:44.179 [debug] [pipeline@<0.1564.0>] Element start: :source_b
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}},
     
     
     11:17:44.179 [debug] [:source_b] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}
     
     11:17:44.180 [debug] [:source_b] Element initialized: Membrane.Testing.Source
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Starting child: name: :sink_b, module: Membrane.Testing.Sink
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Element start: :sink_b
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:44.180 [debug] [:sink_b] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:44.180 [debug] [:sink_b] Element initialized: Membrane.Testing.Sink
     
     11:17:44.180 [debug] [:source_a] Element handle link on pad :output with pad :input of child :sink_a
     
     11:17:44.180 [debug] [:sink_a] Element handle link on pad :input with pad :output of child :source_a
     
     11:17:44.180 [debug] [:source_b] Element handle link on pad :output with pad :input of child :sink_b
     
     11:17:44.180 [debug] [:sink_b] Element handle link on pad :input with pad :output of child :source_b
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Spec #Reference<0.3642608924.1448083457.160407> linked internally
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Spec playback init #Reference<0.3642608924.1448083457.160407> %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}
     
     11:17:44.180 [debug] [pipeline@<0.1564.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.181 [debug] [pipeline@<0.1564.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.181 [debug] [pipeline@<0.1564.0>] Changing playback state from stopped to prepared
     
     11:17:44.181 [debug] [pipeline@<0.1564.0>] Playback state changed from stopped to prepared
     
     11:17:44.181 [debug] [pipeline@<0.1564.0>] Changing playback state from prepared to playing
     
     11:17:44.181 [debug] [:sink_a] Evaluating playback buffer
     
     11:17:44.181 [debug] [:sink_b] Evaluating playback buffer
     
     11:17:44.181 [debug] [:source_a] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.181 [debug] [:source_a] Evaluating playback buffer
     
     11:17:44.181 [debug] [:source_b] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.181 [debug] [:source_b] Evaluating playback buffer
     
     11:17:44.181 [debug] [:sink_a] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.181 [debug] [:sink_b] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:44.181 [error] GenServer #PID<0.1564.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.Sync.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/sync/pipeline.ex:40: Membrane.Support.Sync.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1565.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink_a, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{sink_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_a, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1568.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, sink_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink_b, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1570.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: #PID<0.1566.0>, terminating?: false}, source_a: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_a, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: ["a"]}, pid: #PID<0.1567.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}, source_b: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_b, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {200, #Function<0.20269130/2 in Membrane.Support.Sync.Pipeline.default_spec/0>}}, pid: #PID<0.1569.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160407>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.Sync.Pipeline, test_process: #PID<0.1563.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1569.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_b, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1570.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :source_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1567.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink_a, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1568.0>}}], module: Membrane.Testing.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: true, pending_state: :playing, state: :prepared, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1565.0>, timers: %{}}}
     
............

 32) test Custom log metadata are delivered to the correct element (Membrane.LogMetadataTest)
     test/membrane/log_metadata_test.exs:9
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       metadata_1 = "Metadata 1"
     Showing 2 of 2 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification,
             {[mb_prefix: _mb_prefix, parent_path: _parent_path, test: ^metadata_1], ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {[mb_prefix: _mb_prefix, parent_path: _parent_path, test: ^metadata_1], ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1682.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification, [:element_1, [mb_prefix: ":element_1"]], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {[mb_prefix: _mb_prefix, parent_path: _parent_path, test: ^metadata_1], ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1682.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification, [:element_2, [mb_prefix: ":element_2"]], []}}}
     stacktrace:
       test/membrane/log_metadata_test.exs:21: (test)

     The following output was logged:
     
     11:17:44.725 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %{elements: [element_1: "Metadata 1", element_2: "Metadata 2"]}, module: Membrane.Support.LogMetadataTest.Pipeline, test_process: #PID<0.1681.0>},
     process options: []
     
     
     11:17:44.725 [debug] [pipeline@<0.1682.0>] Initializing spec
     children: [element_1: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement]
     links: []
     
     
     11:17:44.726 [debug] [pipeline@<0.1682.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160735>, sync: nil, terminating?: false}]
     
     11:17:44.726 [debug] [pipeline@<0.1682.0>] Starting child: name: :element_1, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement
     
     11:17:44.726 [debug] [pipeline@<0.1682.0>] Element start: :element_1
     node: ,
     module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement,
     element options: nil,
     
     
     11:17:44.726 [debug] [:element_1] Initializing element: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, options: nil
     
     11:17:44.726 [debug] [:element_1] Element initialized: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement
     
     11:17:44.726 [debug] [pipeline@<0.1682.0>] Spec #Reference<0.3642608924.1448083457.160735> linked internally
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Spec playback init #Reference<0.3642608924.1448083457.160735> %{element_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_1, options: nil, pid: #PID<0.1684.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160735>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_1, options: nil, pid: #PID<0.1684.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160735>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Initializing spec
     children: [element_2: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement]
     links: []
     
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157802>, sync: nil, terminating?: false}]
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Starting child: name: :element_2, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Element start: :element_2
     node: ,
     module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement,
     element options: nil,
     
     
     11:17:44.727 [debug] [:element_2] Initializing element: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, options: nil
     
     11:17:44.727 [debug] [:element_2] Element initialized: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Spec #Reference<0.3642608924.1448083460.157802> linked internally
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Spec playback init #Reference<0.3642608924.1448083460.157802> %{element_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_1, options: nil, pid: #PID<0.1684.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160735>, sync: :membrane_no_sync, terminating?: false}, element_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_2, options: nil, pid: #PID<0.1685.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157802>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:44.727 [debug] [pipeline@<0.1682.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement, name: :element_2, options: nil, pid: #PID<0.1685.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157802>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.728 [debug] [:element_2] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:46.728 [debug] [:element_1] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:46.729 [warning] [:element_2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement,
       name: :element_2,
       pads_data: %{},
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1682.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1683.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:46.729 [debug] [:element_2] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.729 [warning] [:element_1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{},
       module: Membrane.Support.LogMetadataTest.Pipeline.MetadataNotifyingElement,
       name: :element_1,
       pads_data: %{},
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1682.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :stopped,
         target_state: :stopped
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1683.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:46.729 [debug] [:element_1] Terminating element possibly not prepared for termination as it was in state :stopped.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:46.745 [debug] [:sink] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:46.746 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    __struct__: Membrane.Support.ChildRemovalTest.Filter,
    demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
    pads: #MapSet<[
      {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>},
      {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>}
    ]>,
    playing_delay: 0
  },
  module: Membrane.Support.ChildRemovalTest.Filter,
  name: :filter1,
  pads_data: %{
    {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 3,
        q: #Qex<[
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 22>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 23>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 24>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 25>>,
               pts: nil
             }
           ], 3},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 26>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 27>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 28>>,
               pts: nil
             }
           ], 3},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 29>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 30>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 31>>,
               pts: nil
             }
           ], 3}
        ]>,
        size: 10,
        target_size: 10,
        toilet?: false
      },
      mode: :pull,
      name: :input1,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1694.0>,
      ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: {Membrane.Pad, :input1,
       #Reference<0.3642608924.1448083461.157198>},
      pid: #PID<0.1696.0>,
      ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input1: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input1,
      options: nil
    },
    input2: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input2,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
     (truncated)

11:17:46.746 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:46.746 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    __struct__: Membrane.Support.ChildRemovalTest.Filter,
    demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
    pads: #MapSet<[
      {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>},
      {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>}
    ]>,
    playing_delay: 0
  },
  module: Membrane.Support.ChildRemovalTest.Filter,
  name: :filter2,
  pads_data: %{
    {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -2,
        log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 3,
        q: #Qex<[
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 10>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 11>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 12>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 13>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 14>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 15>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 16>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 17>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 18>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 19>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 20>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 21>>,
               pts: nil
             }
           ], 1}
        ]>,
        size: 12,
        target_size: 10,
        toilet?: false
      },
      mode: :pull,
      name: :input1,
      options: %{},
      other_demand_unit: nil,
      other_ref: {Membrane.Pad, :output,
       #Reference<0.3642608924.1448083461.157197>},
      pid: #PID<0.1695.0>,
      ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: {Membrane.Pad, :input1,
       #Reference<0.3642608924.1448083461.157 (truncated)

11:17:46.746 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:46.746 [warning] [:filter3] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    __struct__: Membrane.Support.ChildRemovalTest.Filter,
    demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
    pads: #MapSet<[
      {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>},
      {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157203>}
    ]>,
    playing_delay: 300
  },
  module: Membrane.Support.ChildRemovalTest.Filter,
  name: :filter3,
  pads_data: %{
    {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: nil,
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 3,
        q: #Qex<[]>,
        size: 0,
        target_size: 10,
        toilet?: false
      },
      mode: :pull,
      name: :input1,
      options: %{},
      other_demand_unit: nil,
      other_ref: {Membrane.Pad, :output,
       #Reference<0.3642608924.1448083461.157200>},
      pid: #PID<0.1696.0>,
      ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>},
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157203>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: nil,
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1698.0>,
      ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157203>},
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input1: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input1,
      options: nil
    },
    input2: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input2,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1692.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: true,
    pending_state: :playing,
    state: :prepared,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[
      {Membrane.Core.Message, :demand, 10,
       [
         for_pad: {Membrane.Pad, :output,
          #Reference<0.3642608924.1448083461.157203>}
       ]},
      {Membrane.Core.Message, :caps,
       %Membrane.RemoteStream{content_format: nil, type: :bytestream},
       [
         for_pad: {Membrane.Pad, :input1,
          #Reference<0.3642608924.1448083461.157201>}
       ]},
      {Membrane.Core.Message, :buffer,
       [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<0, 0>>, pts: nil}],
       [
         for_pad: {Membrane.Pad, :input1,
          #Reference<0.3642608924.1448083461.157201>}
       ]},
      {Membrane.Core.Message, :buffer,
       [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<0, 1>>, pts: nil}],
       [
         for_pad: {Membrane.Pad, :input1,
          #Reference<0.3642608924.1448083461.157201>}
       ]},
      {Membrane.Core.Message, :buffer,
       [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<0, 2>>, pts: nil}],
       [
         for_pad: {Membrane.Pad, :input1,
          #Reference<0.3642608924.1448083461.157201>}
       ]},
      {Membrane.Core.Message, :buffer,
       [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<0, 3>>, pts: nil}],
       [
         for_pad: {Membrane.Pad, :input1,
          #Reference<0.3642608924.1448083461.157201>}
       ]},
      {Membrane.Core.Message, :buffer,
       [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<0, 4>>, pts: nil}],
       [
         for_pad: {Membrane.Pad, :input1,
          #Reference<0.3642608924.1448083461.157201>}
       ]},
      {Membrane.Core.Message,  (truncated)

11:17:46.746 [debug] [:filter3] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}"


11:17:46.746 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    generator_state: 32,
    output: &Membrane.Testing.Source.default_buf_gen/2
  },
  module: Membrane.Testing.Source,
  name: :source,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: {Membrane.Pad, :input1,
       #Reference<0.3642608924.1448083461.157195>},
      pid: #PID<0.1695.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1692.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1693.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:46.746 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:46.747 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %Membrane.Testing.Sink{autodemand: true},
  module: Membrane.Testing.Sink,
  name: :sink,
  pads_data: %{
    input: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: nil,
      demand: 1,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: ":input",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 3,
        q: #Qex<[]>,
        size: 0,
        target_size: 10,
        toilet?: false
      },
      mode: :pull,
      name: :input,
      options: %{},
      other_demand_unit: nil,
      other_ref: {Membrane.Pad, :output,
       #Reference<0.3642608924.1448083461.157203>},
      pid: #PID<0.1697.0>,
      ref: :input,
      start_of_stream?: false,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input,
      options: nil
    }
  },
  parent_pid: #PID<0.1692.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1693.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink
}


11:17:46.747 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 33) test When PlaybackBuffer is evaluated there is no buffers from removed element (Membrane.Integration.ChildRemovalTest)
     test/membrane/integration/child_removal_test.exs:84
     ** (EXIT from #PID<0.1691.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:child_msg, name, msg}-, _ctx, state)
              def handle_other(-{:remove_child, name}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/child_removal_test/pipeline.ex:59: Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:46.734 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %{filter1: Membrane.Support.ChildRemovalTest.Filter, filter2: Membrane.Support.ChildRemovalTest.Filter, filter3: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, sink: Membrane.Testing.Sink, source: Membrane.Testing.Source}, module: Membrane.Support.ChildRemovalTest.Pipeline, test_process: #PID<0.1691.0>},
     process options: []
     
     
     11:17:46.735 [debug] [pipeline@<0.1692.0>] Initializing spec
     children: [source: Membrane.Testing.Source, filter1: Membrane.Support.ChildRemovalTest.Filter, filter2: Membrane.Support.ChildRemovalTest.Filter, filter3: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter3, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: :filter3, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter1, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:46.735 [debug] [pipeline@<0.1692.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: nil, terminating?: false}]
     
     11:17:46.735 [debug] [pipeline@<0.1692.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:46.735 [debug] [pipeline@<0.1692.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:46.736 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:46.736 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:46.736 [debug] [pipeline@<0.1692.0>] Starting child: name: :filter1, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.736 [debug] [pipeline@<0.1692.0>] Element start: :filter1
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.736 [debug] [:filter1] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.736 [debug] [:filter1] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.736 [debug] [pipeline@<0.1692.0>] Starting child: name: :filter2, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.736 [debug] [pipeline@<0.1692.0>] Element start: :filter2
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.736 [debug] [:filter2] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.736 [debug] [:filter2] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.736 [debug] [pipeline@<0.1692.0>] Starting child: name: :filter3, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.736 [debug] [pipeline@<0.1692.0>] Element start: :filter3
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300},
     
     
     11:17:46.737 [debug] [:filter3] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}
     
     11:17:46.737 [debug] [:filter3] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.737 [debug] [pipeline@<0.1692.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:46.737 [debug] [pipeline@<0.1692.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:46.737 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:46.737 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:46.737 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>} of child :filter1
     
     11:17:46.737 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>} with pad :output of child :source
     
     11:17:46.737 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>} with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>} of child :filter2
     
     11:17:46.737 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>} of child :filter1
     
     11:17:46.738 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>} with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>} of child :filter3
     
     11:17:46.738 [debug] [:filter3] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>} of child :filter2
     
     11:17:46.738 [debug] [:filter3] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157203>} with pad :input of child :sink
     
     11:17:46.738 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157203>} of child :filter3
     
     11:17:46.738 [debug] [pipeline@<0.1692.0>] Spec #Reference<0.3642608924.1448083457.160768> linked internally
     
     11:17:46.738 [debug] [pipeline@<0.1692.0>] Spec playback init #Reference<0.3642608924.1448083457.160768> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Changing playback state from stopped to prepared
     
     11:17:46.741 [debug] [pipeline@<0.1692.0>] Playback state changed from stopped to prepared
     
     11:17:46.742 [debug] [pipeline@<0.1692.0>] Changing playback state from prepared to playing
     
     11:17:46.742 [debug] [:filter2] Evaluating playback buffer
     
     11:17:46.742 [debug] [:filter1] Evaluating playback buffer
     
     11:17:46.742 [debug] [:sink] Evaluating playback buffer
     
     11:17:46.742 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.742 [debug] [:source] Evaluating playback buffer
     
     11:17:46.742 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.742 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.742 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.742 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.742 [error] GenServer #PID<0.1692.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/child_removal_test/pipeline.ex:59: Membrane.Support.ChildRemovalTest.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}
     State: %Membrane.Core.Pipeline.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.ChildRemovalTest.Pipeline, test_process: #PID<0.1691.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter3, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157203>}, pad_spec: :output, pid: #PID<0.1697.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1698.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>}, pad_spec: :output, pid: #PID<0.1696.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter3, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input1, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157201>}, pad_spec: :input1, pid: #PID<0.1697.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>}, pad_spec: :output, pid: #PID<0.1695.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input1, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157 (truncated)
     
     11:17:46.745 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.745 [debug] [:filter3] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.745 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.745 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.745 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.746 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         __struct__: Membrane.Support.ChildRemovalTest.Filter,
         demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
         pads: #MapSet<[
           {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>},
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>}
         ]>,
         playing_delay: 0
       },
       module: Membrane.Support.ChildRemovalTest.Filter,
       name: :filter1,
       pads_data: %{
         {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>}",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 22>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 23>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 24>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 25>>,
                    pts: nil
                  }
                ], 3},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 26>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 27>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 28>>,
                    pts: nil
                  }
                ], 3},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 29>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 30>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 31>>,
                    pts: nil
                  }
                ], 3}
             ]>,
             size: 10,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input1,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1694.0>,
           ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157195>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083461.157198>},
           pid: #PID<0.1696.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157197>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input1: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input1,
           options: nil
         },
         input2: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input2,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
          (truncated)
     
     11:17:46.746 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.746 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1695.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1696.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 300}, pid: #PID<0.1697.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1698.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1694.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160768>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1693.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         __struct__: Membrane.Support.ChildRemovalTest.Filter,
         demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
         pads: #MapSet<[
           {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>},
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>}
         ]>,
         playing_delay: 0
       },
       module: Membrane.Support.ChildRemovalTest.Filter,
       name: :filter2,
       pads_data: %{
         {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -2,
             log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>}",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 10>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 11>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 12>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 13>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 14>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 15>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 16>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 17>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 18>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 19>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 20>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 21>>,
                    pts: nil
                  }
                ], 1}
             ]>,
             size: 12,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input1,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083461.157197>},
           pid: #PID<0.1695.0>,
           ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083461.157198>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083461.157200>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083461.157 (truncated)
     


 34) test Element can be removed when pipeline is in stopped state (Membrane.Integration.ChildRemovalTest)
     test/membrane/integration/child_removal_test.exs:14
     ** (EXIT from #PID<0.1702.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:child_msg, name, msg}-, _ctx, state)
              def handle_other(-{:remove_child, name}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/child_removal_test/pipeline.ex:59: Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:46.747 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %{filter1: Membrane.Support.ChildRemovalTest.Filter, filter2: Membrane.Support.ChildRemovalTest.Filter, filter3: Membrane.Support.ChildRemovalTest.Filter, sink: Membrane.Testing.Sink, source: Membrane.Testing.Source}, module: Membrane.Support.ChildRemovalTest.Pipeline, test_process: #PID<0.1702.0>},
     process options: []
     
     
     11:17:46.747 [debug] [pipeline@<0.1703.0>] Initializing spec
     children: [source: Membrane.Testing.Source, filter1: Membrane.Support.ChildRemovalTest.Filter, filter2: Membrane.Support.ChildRemovalTest.Filter, filter3: Membrane.Support.ChildRemovalTest.Filter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter3, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: :filter3, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter1, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: nil, terminating?: false}]
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:46.748 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:46.748 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Starting child: name: :filter1, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Element start: :filter1
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.748 [debug] [:filter1] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.748 [debug] [:filter1] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Starting child: name: :filter2, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Element start: :filter2
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.748 [debug] [:filter2] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.748 [debug] [:filter2] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Starting child: name: :filter3, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Element start: :filter3
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.748 [debug] [:filter3] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.748 [debug] [:filter3] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:46.748 [debug] [pipeline@<0.1703.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:46.748 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:46.748 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:46.749 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>} of child :filter1
     
     11:17:46.749 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>} with pad :output of child :source
     
     11:17:46.749 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>} with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>} of child :filter2
     
     11:17:46.749 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>} of child :filter1
     
     11:17:46.749 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>} with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>} of child :filter3
     
     11:17:46.749 [debug] [:filter3] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>} of child :filter2
     
     11:17:46.749 [debug] [:filter3] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>} with pad :input of child :sink
     
     11:17:46.749 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>} of child :filter3
     
     11:17:46.749 [debug] [pipeline@<0.1703.0>] Spec #Reference<0.3642608924.1448083461.157239> linked internally
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Spec playback init #Reference<0.3642608924.1448083461.157239> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Changing playback state from stopped to prepared
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Playback state changed from stopped to prepared
     
     11:17:46.750 [debug] [pipeline@<0.1703.0>] Changing playback state from prepared to playing
     
     11:17:46.750 [debug] [:filter1] Evaluating playback buffer
     
     11:17:46.750 [debug] [:filter2] Evaluating playback buffer
     
     11:17:46.750 [debug] [:sink] Evaluating playback buffer
     
     11:17:46.750 [debug] [:filter3] Evaluating playback buffer
     
     11:17:46.750 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.750 [debug] [:source] Evaluating playback buffer
     
     11:17:46.750 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.750 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.750 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.750 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.750 [debug] [:filter3] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.751 [debug] [:filter3] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.751 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.750 [error] GenServer #PID<0.1703.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/child_removal_test/pipeline.ex:59: Membrane.Support.ChildRemovalTest.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}
     State: %Membrane.Core.Pipeline.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.ChildRemovalTest.Pipeline, test_process: #PID<0.1702.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter3, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>}, pad_spec: :output, pid: #PID<0.1708.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1709.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>}, pad_spec: :output, pid: #PID<0.1707.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter3, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input1, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>}, pad_spec: :input1, pid: #PID<0.1708.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>}, pad_spec: :output, pid: #PID<0.1706.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input1, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833> (truncated)
     
     11:17:46.753 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.753 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.753 [debug] [:filter2] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.754 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.754 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         generator_state: 113,
         output: &Membrane.Testing.Source.default_buf_gen/2
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083457.160830>},
           pid: #PID<0.1706.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1703.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1704.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:46.754 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.754 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         __struct__: Membrane.Support.ChildRemovalTest.Filter,
         demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
         pads: #MapSet<[
           {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>},
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>}
         ]>,
         playing_delay: 0
       },
       module: Membrane.Support.ChildRemovalTest.Filter,
       name: :filter2,
       pads_data: %{
         {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>}",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[]>,
             size: 0,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input1,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083457.160832>},
           pid: #PID<0.1706.0>,
           ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160833>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083457.160836>},
           pid: #PID<0.1708.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160835>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input1: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input1,
           options: nil
         },
         input2: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input2,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1703.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1704.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:46.754 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.754 [debug] [:filter3] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.754 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         __struct__: Membrane.Support.ChildRemovalTest.Filter,
         demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
         pads: #MapSet<[
           {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>},
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>}
         ]>,
         playing_delay: 0
       },
       module: Membrane.Support.ChildRemovalTest.Filter,
       name: :filter1,
       pads_data: %{
         {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>}",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 106>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 107>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 108>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 109>>,
                    pts: nil
                  }
                ], 3}
             ]>,
             size: 4,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input1,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1705.0>,
           ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160830>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083457.160833>},
           pid: #PID<0.1707.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160832>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input1: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input1,
           options: nil
         },
         input2: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input2,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1703.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1704.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:46.754 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:46.761 [debug] [:filter2] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:46.761 [warning] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    __struct__: Membrane.Support.ChildRemovalTest.Filter,
    demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
    pads: #MapSet<[
      {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>},
      {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>}
    ]>,
    playing_delay: 0
  },
  module: Membrane.Support.ChildRemovalTest.Filter,
  name: :filter3,
  pads_data: %{
    {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: -2,
        log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 3,
        q: #Qex<[
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 112>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 113>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 114>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 115>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 116>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 117>>,
               pts: nil
             }
           ], 1}
        ]>,
        size: 6,
        target_size: 10,
        toilet?: false
      },
      mode: :pull,
      name: :input1,
      options: %{},
      other_demand_unit: nil,
      other_ref: {Membrane.Pad, :output,
       #Reference<0.3642608924.1448083459.157327>},
      pid: #PID<0.1718.0>,
      ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1720.0>,
      ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input1: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input1,
      options: nil
    },
    input2: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input2,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1714.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1715.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter
}


11:17:46.761 [warning] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    __struct__: Membrane.Support.ChildRemovalTest.Filter,
    demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
    pads: #MapSet<[
      {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>},
      {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>}
    ]>,
    playing_delay: 0
  },
  module: Membrane.Support.ChildRemovalTest.Filter,
  name: :filter1,
  pads_data: %{
    {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 3,
        q: #Qex<[
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 130>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 131>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 132>>,
               pts: nil
             },
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 133>>,
               pts: nil
             }
           ], 3}
        ]>,
        size: 4,
        target_size: 10,
        toilet?: false
      },
      mode: :pull,
      name: :input1,
      options: %{},
      other_demand_unit: nil,
      other_ref: :output,
      pid: #PID<0.1716.0>,
      ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: {Membrane.Pad, :input1,
       #Reference<0.3642608924.1448083459.157325>},
      pid: #PID<0.1718.0>,
      ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>},
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    input1: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input1,
      options: nil
    },
    input2: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      mode: :pull,
      name: :input2,
      options: nil
    },
    output: %{
      accepted_caps: :any,
      availability: :on_request,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1714.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1715.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter
}


11:17:46.761 [debug] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:46.761 [debug] [:filter1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 35) test Element can be removed when pipeline is in playing state (Membrane.Integration.ChildRemovalTest)
     test/membrane/integration/child_removal_test.exs:43
     ** (EXIT from #PID<0.1713.0>) an exception was raised:
     
          ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 2 out of 2):
          
              def handle_other(-{:child_msg, name, msg}-, _ctx, state)
              def handle_other(-{:remove_child, name}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/child_removal_test/pipeline.ex:59: Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     

     The following output was logged:
     
     11:17:46.755 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -1,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[]>,
             size: 0,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083457.160838>},
           pid: #PID<0.1708.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1703.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1704.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:46.755 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: %{filter1: Membrane.Support.ChildRemovalTest.Filter, filter2: Membrane.Support.ChildRemovalTest.Filter, filter3: Membrane.Support.ChildRemovalTest.Filter, sink: Membrane.Testing.Sink, source: Membrane.Testing.Source}, module: Membrane.Support.ChildRemovalTest.Pipeline, test_process: #PID<0.1713.0>},
     process options: []
     
     
     11:17:46.755 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.755 [warning] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter1, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1706.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1707.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1708.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1709.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1705.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083461.157239>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1704.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         __struct__: Membrane.Support.ChildRemovalTest.Filter,
         demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
         pads: #MapSet<[
           {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>},
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>}
         ]>,
         playing_delay: 0
       },
       module: Membrane.Support.ChildRemovalTest.Filter,
       name: :filter3,
       pads_data: %{
         {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 9,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -2,
             log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>}",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[]>,
             size: 0,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input1,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083457.160835>},
           pid: #PID<0.1707.0>,
           ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083457.160836>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 9,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1709.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160838>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input1: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input1,
           options: nil
         },
         input2: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input2,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1703.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1704.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:46.755 [debug] [pipeline@<0.1714.0>] Initializing spec
     children: [source: Membrane.Testing.Source, filter1: Membrane.Support.ChildRemovalTest.Filter, filter2: Membrane.Support.ChildRemovalTest.Filter, filter3: Membrane.Support.ChildRemovalTest.Filter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter3, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :filter2, from_pad: :output, from_pad_props: %{options: []}, to: :filter3, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :filter1, from_pad: :output, from_pad_props: %{options: []}, to: :filter2, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter1, to_pad: :input1, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:46.755 [debug] [:filter3] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.755 [debug] [pipeline@<0.1714.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: nil, terminating?: false}]
     
     11:17:46.755 [debug] [pipeline@<0.1714.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:46.755 [debug] [pipeline@<0.1714.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:46.755 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:46.755 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:46.755 [debug] [pipeline@<0.1714.0>] Starting child: name: :filter1, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.755 [debug] [pipeline@<0.1714.0>] Element start: :filter1
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.756 [debug] [:filter1] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.756 [debug] [:filter1] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Starting child: name: :filter2, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Element start: :filter2
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.756 [debug] [:filter2] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.756 [debug] [:filter2] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Starting child: name: :filter3, module: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Element start: :filter3
     node: ,
     module: Membrane.Support.ChildRemovalTest.Filter,
     element options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0},
     
     
     11:17:46.756 [debug] [:filter3] Initializing element: Membrane.Support.ChildRemovalTest.Filter, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}
     
     11:17:46.756 [debug] [:filter3] Element initialized: Membrane.Support.ChildRemovalTest.Filter
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:46.756 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:46.756 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:46.756 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>} of child :filter1
     
     11:17:46.756 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>} with pad :output of child :source
     
     11:17:46.756 [debug] [:filter1] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>} with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>} of child :filter2
     
     11:17:46.756 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>} of child :filter1
     
     11:17:46.756 [debug] [:filter2] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>} with pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>} of child :filter3
     
     11:17:46.756 [debug] [:filter3] Element handle link on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>} with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>} of child :filter2
     
     11:17:46.756 [debug] [:filter3] Element handle link on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>} with pad :input of child :sink
     
     11:17:46.756 [debug] [:sink] Element handle link on pad :input with pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>} of child :filter3
     
     11:17:46.756 [debug] [pipeline@<0.1714.0>] Spec #Reference<0.3642608924.1448083458.158033> linked internally
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Spec playback init #Reference<0.3642608924.1448083458.158033> %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Changing playback state from stopped to prepared
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Playback state changed from stopped to prepared
     
     11:17:46.757 [debug] [pipeline@<0.1714.0>] Changing playback state from prepared to playing
     
     11:17:46.757 [debug] [:filter2] Evaluating playback buffer
     
     11:17:46.757 [debug] [:filter1] Evaluating playback buffer
     
     11:17:46.757 [debug] [:sink] Evaluating playback buffer
     
     11:17:46.757 [debug] [:filter3] Evaluating playback buffer
     
     11:17:46.757 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [debug] [:source] Evaluating playback buffer
     
     11:17:46.757 [debug] [:filter1] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157322>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [debug] [:filter1] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [debug] [:filter2] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [debug] [:filter2] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [debug] [:filter3] Received caps on pad {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [debug] [:filter3] Sending caps through pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.758 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.757 [error] GenServer #PID<0.1714.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildRemovalTest.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/child_removal_test/pipeline.ex:59: Membrane.Support.ChildRemovalTest.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}
     State: %Membrane.Core.Pipeline.State{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.ChildRemovalTest.Pipeline, test_process: #PID<0.1713.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter3, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157330>}, pad_spec: :output, pid: #PID<0.1719.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1720.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>}, pad_spec: :output, pid: #PID<0.1718.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter3, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input1, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157328>}, pad_spec: :input1, pid: #PID<0.1719.0>}}, %Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter1, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157324>}, pad_spec: :output, pid: #PID<0.1717.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :filter2, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input1, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: 10, toilet_capacity: nil}, pad_ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325> (truncated)
     
     11:17:46.760 [debug] [:source] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.760 [debug] [:filter3] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.760 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.760 [debug] [:filter1] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:46.761 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         generator_state: 134,
         output: &Membrane.Testing.Source.default_buf_gen/2
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083459.157322>},
           pid: #PID<0.1717.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1714.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1715.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:46.761 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.761 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -2,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[]>,
             size: 0,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083459.157330>},
           pid: #PID<0.1719.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1714.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1715.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:46.761 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:48.765 [debug] [:sink] Shutting down because of pipeline failure
Reason: :shutdown


11:17:48.765 [debug] [:filter] Shutting down because of pipeline failure
Reason: :shutdown



 36) test Pipeline with source not generating enough buffers (Membrane.Integration.DemandsTest)
     test/membrane/integration/demands_test.exs:64
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       i = 0
     Showing 10 of 505 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification,
             {{:buffer, %Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 234, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 235, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 236, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 237, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 238, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 239, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 240, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 241, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 242, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1727.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 243, 255>>, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/demands_test.exs:14: anonymous fn/2 in Membrane.Integration.DemandsTest.assert_buffers_received/2
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/demands_test.exs:26: Membrane.Integration.DemandsTest.test_pipeline/1
       test/membrane/integration/demands_test.exs:86: (test)

     The following output was logged:
     
     11:17:46.762 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Support.DemandsTest.Filter, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1726.0>},
     process options: []
     
     
     11:17:46.762 [warning] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildRemovalTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:filter2, :playing], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{filter1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter1, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1717.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter2, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1718.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, filter3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildRemovalTest.Filter, name: :filter3, options: %Membrane.Support.ChildRemovalTest.Filter{demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1, playing_delay: 0}, pid: #PID<0.1719.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1720.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1716.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158033>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1715.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_removal_test/pipeline.ex', line: 59]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         __struct__: Membrane.Support.ChildRemovalTest.Filter,
         demand_generator: &Membrane.Support.ChildRemovalTest.Filter.default_demand_generator/1,
         pads: #MapSet<[
           {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>},
           {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>}
         ]>,
         playing_delay: 0
       },
       module: Membrane.Support.ChildRemovalTest.Filter,
       name: :filter2,
       pads_data: %{
         {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: -2,
             log_tag: "{Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>}",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 3,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 121>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 122>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<0, 123>>,
                    pts: nil
                  }
                ], 1}
             ]>,
             size: 3,
             target_size: 10,
             toilet?: false
           },
           mode: :pull,
           name: :input1,
           options: %{},
           other_demand_unit: nil,
           other_ref: {Membrane.Pad, :output,
            #Reference<0.3642608924.1448083459.157324>},
           pid: #PID<0.1717.0>,
           ref: {Membrane.Pad, :input1, #Reference<0.3642608924.1448083459.157325>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>} => %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :on_request,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: {Membrane.Pad, :input1,
            #Reference<0.3642608924.1448083459.157328>},
           pid: #PID<0.1719.0>,
           ref: {Membrane.Pad, :output, #Reference<0.3642608924.1448083459.157327>},
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input1: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input1,
           options: nil
         },
         input2: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input2,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1714.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1715.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:46.762 [debug] [:filter2] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Support.DemandsTest.Filter, source: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}}], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: nil, terminating?: false}]
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:46.762 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:46.762 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Starting child: name: :filter, module: Membrane.Support.DemandsTest.Filter
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Element start: :filter
     node: ,
     module: Membrane.Support.DemandsTest.Filter,
     element options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1},
     
     
     11:17:46.762 [debug] [:filter] Initializing element: Membrane.Support.DemandsTest.Filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}
     
     11:17:46.762 [debug] [:filter] Element initialized: Membrane.Support.DemandsTest.Filter
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:46.762 [debug] [pipeline@<0.1727.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}},
     
     
     11:17:46.763 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}}
     
     11:17:46.763 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:46.763 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:46.763 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:46.763 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:46.763 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Spec #Reference<0.3642608924.1448083458.158064> linked internally
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Spec playback init #Reference<0.3642608924.1448083458.158064> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}, pid: #PID<0.1730.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1729.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}}, pid: #PID<0.1731.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}, pid: #PID<0.1730.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1729.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>}}, pid: #PID<0.1731.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158064>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Changing playback state from stopped to prepared
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Playback state changed from stopped to prepared
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Changing playback state from prepared to playing
     
     11:17:46.763 [debug] [:filter] Evaluating playback buffer
     
     11:17:46.763 [debug] [:sink] Evaluating playback buffer
     
     11:17:46.763 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.763 [debug] [:source] Evaluating playback buffer
     
     11:17:46.763 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.763 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:46.763 [debug] [pipeline@<0.1727.0>] Playback state changed from prepared to playing
     
     11:17:46.763 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:48.765 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:48.765 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     

11:17:50.774 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: :shutdown,
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
    generator_state: 580,
    output: &Membrane.Testing.Source.default_buf_gen/2
  },
  module: Membrane.Testing.Source,
  name: :source,
  pads_data: %{
    output: %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: :input,
      pid: #PID<0.1739.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    }
  },
  pads_info: %{
    output: %{
      accepted_caps: :any,
      availability: :always,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      mode: :pull,
      name: :output,
      options: nil
    }
  },
  parent_pid: #PID<0.1736.0>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :playing,
    target_state: :playing
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.1737.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source
}


11:17:50.774 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"



 37) test Regular pipeline with proper demands (Membrane.Integration.DemandsTest)
     test/membrane/integration/demands_test.exs:38
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       i = 0
     Showing 10 of 505 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification,
             {{:buffer, %Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 234, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 235, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 236, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 237, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 238, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 239, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 240, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 241, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 242, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1736.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 243, 255>>, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/demands_test.exs:14: anonymous fn/2 in Membrane.Integration.DemandsTest.assert_buffers_received/2
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/demands_test.exs:26: Membrane.Integration.DemandsTest.test_pipeline/1
       test/membrane/integration/demands_test.exs:47: (test)

     The following output was logged:
     
     11:17:48.767 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         generator_state: 580,
         output: #Function<2.38742003/2 in Membrane.Integration.DemandsTest."test Pipeline with source not generating enough buffers"/1>
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1730.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1727.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1728.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:48.767 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Support.DemandsTest.Filter, source: Membrane.Testing.Source], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1735.0>},
     process options: []
     
     
     11:17:48.767 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:48.768 [debug] [pipeline@<0.1736.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: Membrane.Support.DemandsTest.Filter, source: Membrane.Testing.Source], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:48.768 [debug] [pipeline@<0.1736.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: nil, terminating?: false}]
     
     11:17:48.768 [debug] [pipeline@<0.1736.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:48.768 [debug] [pipeline@<0.1736.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:48.768 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:48.768 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:48.769 [debug] [pipeline@<0.1736.0>] Starting child: name: :filter, module: Membrane.Support.DemandsTest.Filter
     
     11:17:48.769 [debug] [pipeline@<0.1736.0>] Element start: :filter
     node: ,
     module: Membrane.Support.DemandsTest.Filter,
     element options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1},
     
     
     11:17:48.769 [debug] [:filter] Initializing element: Membrane.Support.DemandsTest.Filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}
     
     11:17:48.769 [debug] [:filter] Element initialized: Membrane.Support.DemandsTest.Filter
     
     11:17:48.769 [debug] [pipeline@<0.1736.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:48.769 [debug] [pipeline@<0.1736.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:48.769 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:48.769 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:48.769 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:48.769 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:48.769 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Support.DemandsTest.Filter{
         demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1
       },
       module: Membrane.Support.DemandsTest.Filter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 28>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 29>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 30>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 31>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 32>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 33>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 34>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 35>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 36>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 37>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 38>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 39>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 40>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 41>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 42>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 43>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 44>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 45>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 46>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 47>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 48>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 49>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 50>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 51>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 52>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 53>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 54>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 55>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 56>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 57>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 58>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 59>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 60>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 61>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 62>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 63>>,
                    pts: nil
                  }
                ], 4},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 64>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 65>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 66>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 67>>,
                    pts: nil
                  }
                ], 4}
             ]>,
             size: 40,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: ni (truncated)
     
     11:17:48.769 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:48.769 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:48.769 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Spec #Reference<0.3642608924.1448083459.157346> linked internally
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Spec playback init #Reference<0.3642608924.1448083459.157346> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}, pid: #PID<0.1739.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1738.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1740.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1}, pid: #PID<0.1739.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1738.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1740.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157346>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Changing playback state from stopped to prepared
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Playback state changed from stopped to prepared
     
     11:17:48.770 [debug] [pipeline@<0.1736.0>] Changing playback state from prepared to playing
     
     11:17:48.770 [debug] [:filter] Evaluating playback buffer
     
     11:17:48.770 [debug] [:sink] Evaluating playback buffer
     
     11:17:48.770 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:48.770 [debug] [:source] Evaluating playback buffer
     
     11:17:48.771 [debug] [pipeline@<0.1736.0>] Playback state changed from prepared to playing
     
     11:17:48.771 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:48.771 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:48.771 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:48.771 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 244, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 245, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 246, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 247, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 248, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 249, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 250, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 251, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 252, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 253, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 254, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 255, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 0, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 1, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 2, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 3, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 4, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 5, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 6, ...>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, ...>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<...>>, ...}],
                1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 40,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1730.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1727.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1728.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:48.771 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:50.773 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:50.773 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:50.773 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     


 38) test Pipeline with filter underestimating demand (Membrane.Integration.DemandsTest)
     test/membrane/integration/demands_test.exs:50
     Assertion failed, no matching message after 2000ms
     The following variables were pinned:
       i = 0
     Showing 10 of 505 messages in the mailbox
     code: assert_receive {Membrane.Testing.Pipeline, ^pid_value,
            {:handle_child_notification,
             {{:buffer, %Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
     mailbox:
       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 234, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 235, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 236, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 237, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 238, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 239, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 240, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 241, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 242, 255>>, pts: nil}}
                     }
                   ], []}}}

       pattern: {Membrane.Testing.Pipeline, ^pid_value,
                 {:handle_child_notification,
                  {{:buffer, %Membrane.Buffer{payload: <<^i::16>> <> <<255>>}}, ^element_name_value}}}
       value:   {Membrane.Testing.Pipeline, #PID<0.1745.0>,
                 {:handle_other,
                  {Membrane.Core.Message, :parent_notification,
                   [
                     :sink,
                     %Membrane.Testing.Notification{
                       payload: {:buffer, %Membrane.Buffer{dts: nil, metadata: %{}, payload: <<1, 243, 255>>, pts: nil}}
                     }
                   ], []}}}
     stacktrace:
       test/membrane/integration/demands_test.exs:14: anonymous fn/2 in Membrane.Integration.DemandsTest.assert_buffers_received/2
       (elixir 1.13.2) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.2) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.2) lib/enum.ex:2400: Enum.each/2
       test/membrane/integration/demands_test.exs:26: Membrane.Integration.DemandsTest.test_pipeline/1
       test/membrane/integration/demands_test.exs:61: (test)

     The following output was logged:
     
     11:17:50.775 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{children: [], links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>}, source: Membrane.Testing.Source], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}], module: :default, test_process: #PID<0.1744.0>},
     process options: []
     
     
     11:17:50.776 [debug] [pipeline@<0.1745.0>] Initializing spec
     children: []
     links: [%Membrane.ParentSpec.LinkBuilder{children: [sink: %Membrane.Testing.Sink{autodemand: false}, filter: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>}, source: Membrane.Testing.Source], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:50.776 [debug] [pipeline@<0.1745.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: nil, terminating?: false}]
     
     11:17:50.776 [debug] [pipeline@<0.1745.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:50.776 [debug] [pipeline@<0.1745.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: false},
     
     
     11:17:50.776 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 244, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 245, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 246, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 247, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 248, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 249, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 250, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 251, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 252, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 253, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 254, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 255, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 0, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 1, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 2, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 3, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 4, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 5, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 6, ...>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, ...>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<...>>, ...}],
                1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 40,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1739.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1736.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1737.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:50.776 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: false}
     
     11:17:50.776 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:50.776 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:50.776 [debug] [pipeline@<0.1745.0>] Starting child: name: :filter, module: Membrane.Support.DemandsTest.Filter
     
     11:17:50.776 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Support.DemandsTest.Filter{
         demand_generator: &Membrane.Support.DemandsTest.Filter.default_demand_generator/1
       },
       module: Membrane.Support.DemandsTest.Filter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 28>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 29>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 30>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 31>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 32>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 33>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 34>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 35>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 36>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 37>>,
                    pts: nil
                  }
                ], 10},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 38>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 39>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 40>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 41>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 42>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 43>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 44>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 45>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 46>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 47>>,
                    pts: nil
                  }
                ], 10},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 48>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 49>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 50>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 51>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 52>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 53>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 54>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 55>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 56>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 57>>,
                    pts: nil
                  }
                ], 10},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 58>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 59>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 60>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 61>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 62>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 63>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 64>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 65>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 66>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 67>>,
                    pts: nil
                  }
                ], 10}
             ]>,
             size: 40,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1740.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :al (truncated)
     
     11:17:50.776 [debug] [pipeline@<0.1745.0>] Element start: :filter
     node: ,
     module: Membrane.Support.DemandsTest.Filter,
     element options: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>},
     
     
     11:17:50.776 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:50.777 [debug] [:filter] Initializing element: Membrane.Support.DemandsTest.Filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>}
     
     11:17:50.777 [debug] [:filter] Element initialized: Membrane.Support.DemandsTest.Filter
     
     11:17:50.777 [debug] [pipeline@<0.1745.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:50.777 [debug] [pipeline@<0.1745.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:50.777 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:50.777 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:50.777 [debug] [:source] Element handle link on pad :output with pad :input of child :filter
     
     11:17:50.777 [debug] [:filter] Element handle link on pad :input with pad :output of child :source
     
     11:17:50.777 [debug] [:filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:50.777 [debug] [:sink] Element handle link on pad :input with pad :output of child :filter
     
     11:17:50.777 [debug] [pipeline@<0.1745.0>] Spec #Reference<0.3642608924.1448083460.157879> linked internally
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Spec playback init #Reference<0.3642608924.1448083460.157879> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>}, pid: #PID<0.1748.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1747.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1749.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.DemandsTest.Filter, name: :filter, options: %Membrane.Support.DemandsTest.Filter{demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>}, pid: #PID<0.1748.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: false}, pid: #PID<0.1747.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1749.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157879>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Changing playback state from stopped to prepared
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Playback state changed from stopped to prepared
     
     11:17:50.778 [debug] [pipeline@<0.1745.0>] Changing playback state from prepared to playing
     
     11:17:50.778 [debug] [:sink] Evaluating playback buffer
     
     11:17:50.778 [debug] [:filter] Evaluating playback buffer
     
     11:17:50.779 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:50.779 [debug] [:source] Evaluating playback buffer
     
     11:17:50.779 [debug] [:filter] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:50.779 [debug] [pipeline@<0.1745.0>] Playback state changed from prepared to playing
     
     11:17:50.779 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:50.779 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.782 [debug] [:sink] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:52.782 [debug] [:source] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:52.782 [debug] [:filter] Shutting down because of pipeline failure
     Reason: :shutdown
     
     
     11:17:52.782 [warning] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{
         caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
         generator_state: 580,
         output: &Membrane.Testing.Source.default_buf_gen/2
       },
       module: Membrane.Testing.Source,
       name: :source,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1748.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1745.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1746.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :source
     }
     
     
     11:17:52.783 [debug] [:source] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:52.803 [warning] [:filter_2_1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    pads: #MapSet<[
      {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156028>}
    ]>
  },
  module: Membrane.Support.ChildCrashTest.Filter,
  name: :filter_2_1,
  pads_data: %{
    :output => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: {Membrane.Pad, :input,
       #Reference<0.3642608924.1448083463.156030>},
      pid: #PID<0.1758.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156028>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: "{Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156028>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 40>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 41>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 42>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 43>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 44>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 45>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 46>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 47>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 48>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 49>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 50>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
            (truncated)

11:17:52.803 [debug] [:filter_2_1] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:shutdown, :parent_crash}"


11:17:52.803 [warning] [:filter_2_2] Terminating element possibly not prepared for termination as it was in state :playing.
Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
State: %Membrane.Core.Element.State{
  delayed_demands: #MapSet<[]>,
  demand_size: nil,
  internal_state: %{
    pads: #MapSet<[
      {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156059>}
    ]>
  },
  module: Membrane.Support.ChildCrashTest.Filter,
  name: :filter_2_2,
  pads_data: %{
    :output => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :always,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :output,
      end_of_stream?: false,
      input_queue: nil,
      mode: :pull,
      name: :output,
      options: %{},
      other_demand_unit: :buffers,
      other_ref: {Membrane.Pad, :input,
       #Reference<0.3642608924.1448083463.156061>},
      pid: #PID<0.1758.0>,
      ref: :output,
      start_of_stream?: true,
      sticky_messages: [],
      toilet: nil
    },
    {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156059>} => %Membrane.Element.PadData{
      accepted_caps: :any,
      associated_pads: [],
      auto_demand_size: nil,
      availability: :on_request,
      caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
      demand: 0,
      demand_mode: :manual,
      demand_unit: :buffers,
      direction: :input,
      end_of_stream?: false,
      input_queue: %Membrane.Core.Element.InputQueue{
        demand: 0,
        log_tag: "{Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156059>}",
        metric: Membrane.Buffer.Metric.Count,
        min_demand: 10,
        q: #Qex<[
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 40>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 41>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 42>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 43>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 44>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 45>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 46>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 47>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 48>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 49>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
               payload: <<0, 50>>,
               pts: nil
             }
           ], 1},
          {:buffers,
           [
             %Membrane.Buffer{
               dts: nil,
               metadata: %{},
            (truncated)


 39) test Crash two groups one after another (Membrane.Integration.ChildCrashTest)
     test/membrane/integration/child_crash_test.exs:118
     ** (exit) exited in: :sys.get_state(#PID<0.1756.0>)
        ** (EXIT) an exception was raised:
          ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.ChildCrashTest.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 1 out of 1):
          
              def handle_other(-{:create_path, spec}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/child_crash_test/pipeline.ex:39: Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     
     stacktrace:
       (stdlib 3.17) sys.erl:338: :sys.send_system_msg/2
       (stdlib 3.17) sys.erl:139: :sys.get_state/1
       test/membrane/integration/child_crash_test.exs:203: Membrane.Integration.ChildCrashTest.get_pid_and_link/2
       (elixir 1.13.2) lib/enum.ex:1593: Enum."-map/2-lists^map/1-0-"/2
       (elixir 1.13.2) lib/enum.ex:1593: Enum."-map/2-lists^map/1-0-"/2
       test/membrane/integration/child_crash_test.exs:157: (test)

     The following output was logged:
     
     11:17:52.784 [warning] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Support.DemandsTest.Filter{
         demand_generator: #Function<1.38742003/1 in Membrane.Integration.DemandsTest."test Pipeline with filter underestimating demand"/1>
       },
       module: Membrane.Support.DemandsTest.Filter,
       name: :filter,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 28>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 29>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 30>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 31>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 32>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 33>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 34>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 35>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 36>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 37>>,
                    pts: nil
                  }
                ], 10},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 38>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 39>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 40>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 41>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 42>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 43>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 44>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 45>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 46>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 47>>,
                    pts: nil
                  }
                ], 10},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 48>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 49>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 50>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 51>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 52>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 53>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 54>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 55>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 56>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 57>>,
                    pts: nil
                  }
                ], 10},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 58>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 59>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 60>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 61>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 62>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 63>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 64>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 65>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 66>>,
                    pts: nil
                  },
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 67>>,
                    pts: nil
                  }
                ], 10}
             ]>,
             size: 40,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1749.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         },
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
         (truncated)
     
     11:17:52.785 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:52.785 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: :shutdown,
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: false},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 0,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 244, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 245, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 246, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 247, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 248, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 249, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 250, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 251, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 252, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 253, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 254, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<1, 255, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 0, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 1, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 2, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 3, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 4, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 5, 255>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, 6, ...>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [
                  %Membrane.Buffer{
                    dts: nil,
                    metadata: %{},
                    payload: <<2, ...>>,
                    pts: nil
                  }
                ], 1},
               {:buffers,
                [%Membrane.Buffer{dts: nil, metadata: %{}, payload: <<...>>, ...}],
                1},
               {:buffers, [%Membrane.Buffer{dts: nil, metadata: %{}, ...}], 1},
               {:buffers, [%Membrane.Buffer{dts: nil, ...}], 1},
               {:buffers, [%Membrane.Buffer{...}], 1},
               {:buffers, [...], ...},
               {:buffers, ...},
               {...},
               ...
             ]>,
             size: 40,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1748.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1745.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1746.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:52.785 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:52.788 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: nil, module: Membrane.Support.ChildCrashTest.Pipeline, test_process: #PID<0.1755.0>},
     process options: []
     
     
     11:17:52.788 [debug] [pipeline@<0.1756.0>] Initializing spec
     children: [center_filter: Membrane.Support.ChildCrashTest.Filter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :center_filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.791 [debug] [pipeline@<0.1756.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: nil, terminating?: false}]
     
     11:17:52.791 [debug] [pipeline@<0.1756.0>] Starting child: name: :center_filter, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.791 [debug] [pipeline@<0.1756.0>] Element start: :center_filter
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.792 [debug] [:center_filter] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.792 [debug] [:center_filter] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:52.792 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:52.792 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:52.792 [debug] [:center_filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:52.792 [debug] [:sink] Element handle link on pad :input with pad :output of child :center_filter
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Spec #Reference<0.3642608924.1448083460.157937> linked internally
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Spec playback init #Reference<0.3642608924.1448083460.157937> %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Changing playback state from stopped to prepared
     
     11:17:52.792 [debug] [pipeline@<0.1756.0>] Playback state changed from stopped to prepared
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Changing playback state from prepared to playing
     
     11:17:52.793 [debug] [:center_filter] Evaluating playback buffer
     
     11:17:52.793 [debug] [:sink] Evaluating playback buffer
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Initializing spec
     children: [source_1: Membrane.Testing.Source, filter_1_1: Membrane.Support.ChildCrashTest.Filter, filter_2_1: Membrane.Support.ChildCrashTest.Filter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_1, from_pad: :output, from_pad_props: %{options: []}, to: :filter_1_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter_1_1, from_pad: :output, from_pad_props: %{options: []}, to: :filter_2_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter_2_1, from_pad: :output, from_pad_props: %{options: []}, to: :center_filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: nil, terminating?: false}]
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Starting child: name: :source_1, module: Membrane.Testing.Source
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Element start: :source_1
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:52.793 [debug] [:source_1] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:52.793 [debug] [:source_1] Element initialized: Membrane.Testing.Source
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Starting child: name: :filter_1_1, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Element start: :filter_1_1
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.793 [debug] [:filter_1_1] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.793 [debug] [:filter_1_1] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.793 [debug] [pipeline@<0.1756.0>] Starting child: name: :filter_2_1, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.794 [debug] [pipeline@<0.1756.0>] Element start: :filter_2_1
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.794 [debug] [:filter_2_1] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.794 [debug] [:filter_2_1] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.794 [debug] [:source_1] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156026>} of child :filter_1_1
     
     11:17:52.794 [debug] [:filter_1_1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156026>} with pad :output of child :source_1
     
     11:17:52.794 [debug] [:filter_1_1] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156028>} of child :filter_2_1
     
     11:17:52.794 [debug] [:filter_2_1] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156028>} with pad :output of child :filter_1_1
     
     11:17:52.794 [debug] [:filter_2_1] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156030>} of child :center_filter
     
     11:17:52.794 [debug] [:center_filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156030>} with pad :output of child :filter_2_1
     
     11:17:52.794 [debug] [pipeline@<0.1756.0>] Spec #Reference<0.3642608924.1448083463.156012> linked internally
     
     11:17:52.795 [debug] [pipeline@<0.1756.0>] Spec playback init #Reference<0.3642608924.1448083463.156012> %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.795 [debug] [pipeline@<0.1756.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.795 [debug] [pipeline@<0.1756.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.795 [debug] [:filter_1_1] Evaluating playback buffer
     
     11:17:52.795 [debug] [:filter_2_1] Evaluating playback buffer
     
     11:17:52.795 [debug] [pipeline@<0.1756.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.795 [debug] [:source_1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.795 [debug] [:source_1] Evaluating playback buffer
     
     11:17:52.795 [debug] [:filter_1_1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156026>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.795 [debug] [:filter_1_1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.795 [debug] [:filter_2_1] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156028>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.795 [debug] [:filter_2_1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.795 [debug] [pipeline@<0.1756.0>] Initializing spec
     children: [source_2: Membrane.Testing.Source, filter_1_2: Membrane.Support.ChildCrashTest.Filter, filter_2_2: Membrane.Support.ChildCrashTest.Filter]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source_2, from_pad: :output, from_pad_props: %{options: []}, to: :filter_1_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter_1_2, from_pad: :output, from_pad_props: %{options: []}, to: :filter_2_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}, %Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter_2_2, from_pad: :output, from_pad_props: %{options: []}, to: :center_filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.795 [debug] [:center_filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156030>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.796 [debug] [:center_filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: nil, terminating?: false}]
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Starting child: name: :source_2, module: Membrane.Testing.Source
     
     11:17:52.796 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Element start: :source_2
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:52.796 [debug] [:source_2] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:52.796 [debug] [:source_2] Element initialized: Membrane.Testing.Source
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Starting child: name: :filter_1_2, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Element start: :filter_1_2
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.796 [debug] [:filter_1_2] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.796 [debug] [:filter_1_2] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Starting child: name: :filter_2_2, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.796 [debug] [pipeline@<0.1756.0>] Element start: :filter_2_2
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.796 [debug] [:filter_2_2] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.796 [debug] [:filter_2_2] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.796 [debug] [:source_2] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156057>} of child :filter_1_2
     
     11:17:52.796 [debug] [:filter_1_2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156057>} with pad :output of child :source_2
     
     11:17:52.797 [debug] [:filter_1_2] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156059>} of child :filter_2_2
     
     11:17:52.797 [debug] [:filter_2_2] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156059>} with pad :output of child :filter_1_2
     
     11:17:52.797 [debug] [:filter_2_2] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156061>} of child :center_filter
     
     11:17:52.797 [debug] [:center_filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156061>} with pad :output of child :filter_2_2
     
     11:17:52.797 [debug] [pipeline@<0.1756.0>] Spec #Reference<0.3642608924.1448083460.157965> linked internally
     
     11:17:52.797 [debug] [pipeline@<0.1756.0>] Spec playback init #Reference<0.3642608924.1448083460.157965> %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.797 [debug] [pipeline@<0.1756.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.797 [debug] [pipeline@<0.1756.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.797 [debug] [:filter_1_2] Evaluating playback buffer
     
     11:17:52.797 [debug] [:filter_2_2] Evaluating playback buffer
     
     11:17:52.797 [debug] [pipeline@<0.1756.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.797 [debug] [:source_2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:source_2] Evaluating playback buffer
     
     11:17:52.798 [debug] [:filter_1_2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156057>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:filter_1_2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:filter_2_2] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156059>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:filter_2_2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:center_filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156061>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:center_filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.798 [error] GenServer #PID<0.1756.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/child_crash_test/pipeline.ex:39: Membrane.Support.ChildCrashTest.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{1 => %Membrane.Core.Parent.CrashGroup{alive_members_pids: [#PID<0.1760.0>, #PID<0.1761.0>, #PID<0.1762.0>], crash_initiator: nil, members: [:source_1, :filter_1_1, :filter_2_1], mode: :temporary, name: 1, triggered?: false}, 2 => %Membrane.Core.Parent.CrashGroup{alive_members_pids: [#PID<0.1763.0>, #PID<0.1764.0>, #PID<0.1765.0>], crash_initiator: nil, members: [:source_2, :filter_1_2, :filter_2_2], mode: :temporary, name: 2, triggered?: false}}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.ChildCrashTest.Pipeline, test_process: #PID<0.1755.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :filter_2_2, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1765.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :center_filter, pad_info: %{availability: :on_request, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, optio (truncated)
     
     11:17:52.801 [debug] [:filter_1_1] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:52.801 [debug] [:filter_2_1] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:52.801 [debug] [:filter_2_2] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:52.802 [debug] [:center_filter] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:52.802 [debug] [:filter_1_2] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1758.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, filter_1_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_1, options: nil, pid: #PID<0.1761.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_1_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_1_2, options: nil, pid: #PID<0.1764.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, filter_2_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_1, options: nil, pid: #PID<0.1762.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, filter_2_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter_2_2, options: nil, pid: #PID<0.1765.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1759.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083460.157937>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1760.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083463.156012>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1763.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083460.157965>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1757.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
.

 40) test small pipeline with one crash group test (Membrane.Integration.ChildCrashTest)
     test/membrane/integration/child_crash_test.exs:40
     Unexpectedly received message {:EXIT, #PID<0.1783.0>, {:shutdown, :parent_crash}} (which matched {:EXIT, ^pid, _})
     code: assert_pid_alive(center_filter_pid)
     stacktrace:
       test/membrane/integration/child_crash_test.exs:59: (test)

     The following output was logged:
     
     11:17:52.808 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: nil, module: Membrane.Support.ChildCrashTest.Pipeline, test_process: #PID<0.1780.0>},
     process options: []
     
     
     11:17:52.808 [debug] [pipeline@<0.1781.0>] Initializing spec
     children: [center_filter: Membrane.Support.ChildCrashTest.Filter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :center_filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.808 [debug] [pipeline@<0.1781.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: nil, terminating?: false}]
     
     11:17:52.808 [debug] [pipeline@<0.1781.0>] Starting child: name: :center_filter, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.808 [debug] [pipeline@<0.1781.0>] Element start: :center_filter
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.808 [debug] [:center_filter] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.808 [debug] [:center_filter] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.808 [debug] [pipeline@<0.1781.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:52.808 [debug] [pipeline@<0.1781.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:52.808 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:52.808 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:52.808 [debug] [:center_filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:52.809 [debug] [:sink] Element handle link on pad :input with pad :output of child :center_filter
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Spec #Reference<0.3642608924.1448083459.157429> linked internally
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Spec playback init #Reference<0.3642608924.1448083459.157429> %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Changing playback state from stopped to prepared
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Initializing spec
     children: [source: Membrane.Testing.Source]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :source, from_pad: :output, from_pad_props: %{options: []}, to: :center_filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156162>, sync: nil, terminating?: false}]
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Starting child: name: :source, module: Membrane.Testing.Source
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Element start: :source
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:52.809 [debug] [:source] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:52.809 [debug] [:source] Element initialized: Membrane.Testing.Source
     
     11:17:52.809 [debug] [:source] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156171>} of child :center_filter
     
     11:17:52.809 [debug] [:center_filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156171>} with pad :output of child :source
     
     11:17:52.809 [debug] [pipeline@<0.1781.0>] Spec #Reference<0.3642608924.1448083463.156162> linked internally
     
     11:17:52.810 [debug] [pipeline@<0.1781.0>] Spec playback init #Reference<0.3642608924.1448083463.156162> %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, source: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1785.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156162>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.810 [debug] [pipeline@<0.1781.0>] Initializing playback state :prepared %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1785.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083463.156162>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.810 [debug] [pipeline@<0.1781.0>] Playback state changed from stopped to prepared
     
     11:17:52.810 [debug] [pipeline@<0.1781.0>] Changing playback state from prepared to playing
     
     11:17:52.810 [debug] [:center_filter] Evaluating playback buffer
     
     11:17:52.810 [debug] [:sink] Evaluating playback buffer
     
     11:17:52.810 [debug] [:source] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.810 [debug] [:source] Evaluating playback buffer
     
     11:17:52.810 [debug] [:center_filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083463.156171>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.810 [debug] [:center_filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.810 [debug] [pipeline@<0.1781.0>] Playback state changed from prepared to playing
     
     11:17:52.810 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.810 [error] GenServer #PID<0.1781.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/child_crash_test/pipeline.ex:39: Membrane.Support.ChildCrashTest.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1782.0>, playback_state: :playing}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.ChildCrashTest.Pipeline, test_process: #PID<0.1780.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :center_filter, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: nil}, pad_props: %{options: []}, pad_ref: :output, pad_spec: :output, pid: #PID<0.1783.0>}, to: %Membrane.Core.Parent.Link.Endpoint{child: :sink, pad_info: %{availability: :always, caps: :any, demand_mode: :manual, demand_unit: :buffers, direction: :input, mode: :pull, name: :input, options: nil}, pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}, pad_ref: :input, pad_spec: :input, pid: #PID<0.1784.0>}}], module: Membrane.Testing.Pipeline, pending_specs: %{}, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :playing, target_state: :playing}, synchronization: %{clock_provider: %{choice: :auto, clock: nil, provider: nil}, clock_proxy: #PID<0.1782.0>, timers: %{}}}
     
     11:17:52.811 [debug] [:center_filter] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1782.0>, playback_state: :playing}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:52.811 [debug] [:sink] Shutting down because of pipeline failure
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1782.0>, playback_state: :playing}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     
     
     11:17:52.812 [warning] [:center_filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1782.0>, playback_state: :playing}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %{pads: #MapSet<[]>},
       module: Membrane.Support.ChildCrashTest.Filter,
       name: :center_filter,
       pads_data: %{
         output: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 40,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           end_of_stream?: false,
           input_queue: nil,
           mode: :pull,
           name: :output,
           options: %{},
           other_demand_unit: :buffers,
           other_ref: :input,
           pid: #PID<0.1784.0>,
           ref: :output,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :on_request,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         },
         output: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :output,
           mode: :pull,
           name: :output,
           options: nil
         }
       },
       parent_pid: #PID<0.1781.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1782.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :filter
     }
     
     
     11:17:52.812 [warning] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1783.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1784.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157429>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1782.0>, playback_state: :playing}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]},
     State: %Membrane.Core.Element.State{
       delayed_demands: #MapSet<[]>,
       demand_size: nil,
       internal_state: %Membrane.Testing.Sink{autodemand: true},
       module: Membrane.Testing.Sink,
       name: :sink,
       pads_data: %{
         input: %Membrane.Element.PadData{
           accepted_caps: :any,
           associated_pads: [],
           auto_demand_size: nil,
           availability: :always,
           caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream},
           demand: 1,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           end_of_stream?: false,
           input_queue: %Membrane.Core.Element.InputQueue{
             demand: 0,
             log_tag: ":input",
             metric: Membrane.Buffer.Metric.Count,
             min_demand: 10,
             q: #Qex<[]>,
             size: 0,
             target_size: 40,
             toilet?: false
           },
           mode: :pull,
           name: :input,
           options: %{},
           other_demand_unit: nil,
           other_ref: :output,
           pid: #PID<0.1783.0>,
           ref: :input,
           start_of_stream?: true,
           sticky_messages: [],
           toilet: nil
         }
       },
       pads_info: %{
         input: %{
           accepted_caps: :any,
           availability: :always,
           demand_mode: :manual,
           demand_unit: :buffers,
           direction: :input,
           mode: :pull,
           name: :input,
           options: nil
         }
       },
       parent_pid: #PID<0.1781.0>,
       playback: %Membrane.Core.Playback{
         async_state_change: false,
         pending_state: nil,
         state: :playing,
         target_state: :playing
       },
       playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
       supplying_demand?: false,
       synchronization: %{
         clock: nil,
         latency: 0,
         parent_clock: #PID<0.1782.0>,
         stream_sync: :membrane_no_sync,
         timers: %{}
       },
       type: :sink
     }
     
     
     11:17:52.812 [debug] [:center_filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:52.812 [debug] [:sink] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     

11:17:52.933 [debug] [:source_2] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1791.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:52.933 [debug] [:source_3] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1791.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}


11:17:52.933 [debug] [:source_1] Shutting down because of pipeline failure
Reason: {:function_clause, [{Membrane.Support.ChildCrashTest.Pipeline, :handle_other, [{Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1791.0>, playback_state: :prepared}, %{}], [file: 'test/support/child_crash_test/pipeline.ex', line: 39]}, {Membrane.Testing.Pipeline, :eval_injected_module_callback, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 540]}, {Membrane.Testing.Pipeline, :handle_other, 3, [file: 'lib/membrane/testing/pipeline.ex', line: 460]}, {Membrane.Core.CallbackHandler, :exec_callback, 4, [file: 'lib/membrane/core/callback_handler.ex', line: 140]}, {Membrane.Core.CallbackHandler, :exec_and_handle_callback, 5, [file: 'lib/membrane/core/callback_handler.ex', line: 65]}, {Membrane.Core.Pipeline, :handle_info, 2, [file: 'lib/membrane/core/pipeline.ex', line: 112]}, {:gen_server, :try_dispatch, 4, [file: 'gen_server.erl', line: 695]}, {:gen_server, :handle_msg, 6, [file: 'gen_server.erl', line: 771]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}



 41) test Crash group consisting of bin crashes (Membrane.Integration.ChildCrashTest)
     test/membrane/integration/child_crash_test.exs:66
     ** (exit) exited in: :sys.get_state(#PID<0.1790.0>)
        ** (EXIT) an exception was raised:
          ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
     
          The following arguments were given to Membrane.Support.ChildCrashTest.Pipeline.handle_other/3:
          
              # 1
              {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
          
              # 2
              %Membrane.Pipeline.CallbackContext.Other{children: %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1791.0>, playback_state: :prepared}
          
              # 3
              %{}
          
          Attempted function clauses (showing 1 out of 1):
          
              def handle_other(-{:create_path, spec}-, _ctx, state)
          
          stacktrace:
            (membrane_core 0.10.1) test/support/child_crash_test/pipeline.ex:39: Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
            (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
            (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
            (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
            (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
            (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
            (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     
     stacktrace:
       (stdlib 3.17) sys.erl:338: :sys.send_system_msg/2
       (stdlib 3.17) sys.erl:139: :sys.get_state/1
       test/membrane/integration/child_crash_test.exs:203: Membrane.Integration.ChildCrashTest.get_pid_and_link/2
       (elixir 1.13.2) lib/enum.ex:1593: Enum."-map/2-lists^map/1-0-"/2
       (elixir 1.13.2) lib/enum.ex:1593: Enum."-map/2-lists^map/1-0-"/2
       test/membrane/integration/child_crash_test.exs:97: (test)

     The following output was logged:
     
     11:17:52.913 [debug] Pipeline start link: module: Membrane.Testing.Pipeline,
     pipeline options: %{custom_args: nil, module: Membrane.Support.ChildCrashTest.Pipeline, test_process: #PID<0.1789.0>},
     process options: []
     
     
     11:17:52.913 [debug] [pipeline@<0.1790.0>] Initializing spec
     children: [center_filter: Membrane.Support.ChildCrashTest.Filter, sink: Membrane.Testing.Sink]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :center_filter, from_pad: :output, from_pad_props: %{options: []}, to: :sink, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.914 [debug] [pipeline@<0.1790.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: nil, terminating?: false}]
     
     11:17:52.914 [debug] [pipeline@<0.1790.0>] Starting child: name: :center_filter, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.914 [debug] [pipeline@<0.1790.0>] Element start: :center_filter
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.914 [debug] [:center_filter] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.914 [debug] [:center_filter] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.914 [debug] [pipeline@<0.1790.0>] Starting child: name: :sink, module: Membrane.Testing.Sink
     
     11:17:52.915 [debug] [pipeline@<0.1790.0>] Element start: :sink
     node: ,
     module: Membrane.Testing.Sink,
     element options: %Membrane.Testing.Sink{autodemand: true},
     
     
     11:17:52.915 [debug] [:sink] Initializing element: Membrane.Testing.Sink, options: %Membrane.Testing.Sink{autodemand: true}
     
     11:17:52.915 [debug] [:sink] Element initialized: Membrane.Testing.Sink
     
     11:17:52.915 [debug] [:center_filter] Element handle link on pad :output with pad :input of child :sink
     
     11:17:52.915 [debug] [:sink] Element handle link on pad :input with pad :output of child :center_filter
     
     11:17:52.915 [debug] [pipeline@<0.1790.0>] Spec #Reference<0.3642608924.1448083458.158445> linked internally
     
     11:17:52.915 [debug] [pipeline@<0.1790.0>] Spec playback init #Reference<0.3642608924.1448083458.158445> %{center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.915 [debug] [pipeline@<0.1790.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.915 [debug] [pipeline@<0.1790.0>] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.915 [debug] [pipeline@<0.1790.0>] Changing playback state from stopped to prepared
     
     11:17:52.916 [debug] [pipeline@<0.1790.0>] Playback state changed from stopped to prepared
     
     11:17:52.916 [debug] [pipeline@<0.1790.0>] Changing playback state from prepared to playing
     
     11:17:52.916 [debug] [:center_filter] Evaluating playback buffer
     
     11:17:52.916 [debug] [:sink] Evaluating playback buffer
     
     11:17:52.916 [debug] [pipeline@<0.1790.0>] Initializing spec
     children: [source_1: Membrane.Testing.Source, bin_1: Membrane.Support.Bin.TestBins.CrashTestBin]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :bin_1, from_pad: :output, from_pad_props: %{options: []}, to: :center_filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source_1, from_pad: :output, from_pad_props: %{options: []}, to: :bin_1, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.921 [debug] [pipeline@<0.1790.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: nil, terminating?: false}]
     
     11:17:52.922 [debug] [pipeline@<0.1790.0>] Starting child: name: :source_1, module: Membrane.Testing.Source
     
     11:17:52.922 [debug] [pipeline@<0.1790.0>] Element start: :source_1
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:52.922 [debug] [:source_1] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:52.922 [debug] [:source_1] Element initialized: Membrane.Testing.Source
     
     11:17:52.922 [debug] [pipeline@<0.1790.0>] Starting child: name: :bin_1, module: Membrane.Support.Bin.TestBins.CrashTestBin
     
     11:17:52.922 [debug] [pipeline@<0.1790.0>] Bin start: :bin_1
     node: ,
     module: Membrane.Support.Bin.TestBins.CrashTestBin,
     bin options: nil
     
     
     11:17:52.922 [debug] [:bin_1 bin] Initializing spec
     children: [filter: Membrane.Support.ChildCrashTest.Filter]
     links: []
     
     
     11:17:52.922 [debug] [:bin_1 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158461>, sync: nil, terminating?: false}]
     
     11:17:52.922 [debug] [:bin_1 bin] Starting child: name: :filter, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.922 [debug] [:bin_1 bin] Element start: :filter
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.922 [debug] [:filter] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.922 [debug] [:filter] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.922 [debug] [:bin_1 bin] Spec #Reference<0.3642608924.1448083458.158461> linked internally
     
     11:17:52.922 [debug] [:bin_1 bin] Linking spec #Reference<0.3642608924.1448083458.158461> externally
     
     11:17:52.922 [debug] [:bin_1 bin] Spec #Reference<0.3642608924.1448083458.158461> linked externally
     
     11:17:52.923 [debug] [:bin_1 bin] Spec playback init #Reference<0.3642608924.1448083458.158461> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1797.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158461>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.923 [debug] [:bin_1 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1797.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158461>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.923 [debug] [:bin_1 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158471>}
     
     11:17:52.923 [debug] [pipeline@<0.1790.0>] Initializing spec
     children: [source_2: Membrane.Testing.Source, bin_2: Membrane.Support.Bin.TestBins.CrashTestBin]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :bin_2, from_pad: :output, from_pad_props: %{options: []}, to: :center_filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source_2, from_pad: :output, from_pad_props: %{options: []}, to: :bin_2, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.923 [debug] [:bin_1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158471>}, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.923 [debug] [:bin_1 bin] Starting children: []
     
     11:17:52.923 [debug] [:bin_1 bin] Spec #Reference<0.3642608924.1448083459.157514> linked internally
     
     11:17:52.923 [debug] [pipeline@<0.1790.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: nil, terminating?: false}]
     
     11:17:52.923 [debug] [pipeline@<0.1790.0>] Starting child: name: :source_2, module: Membrane.Testing.Source
     
     11:17:52.923 [debug] [:bin_1 bin] Linking spec #Reference<0.3642608924.1448083459.157514> externally
     
     11:17:52.923 [debug] [:bin_1 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.158473>}
     
     11:17:52.923 [debug] [pipeline@<0.1790.0>] Element start: :source_2
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:52.923 [debug] [:bin_1 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083458.158473>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:52.923 [debug] [:source_2] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:52.923 [debug] [:source_2] Element initialized: Membrane.Testing.Source
     
     11:17:52.923 [debug] [pipeline@<0.1790.0>] Starting child: name: :bin_2, module: Membrane.Support.Bin.TestBins.CrashTestBin
     
     11:17:52.923 [debug] [pipeline@<0.1790.0>] Bin start: :bin_2
     node: ,
     module: Membrane.Support.Bin.TestBins.CrashTestBin,
     bin options: nil
     
     
     11:17:52.923 [debug] [:bin_1 bin] Starting children: []
     
     11:17:52.923 [debug] [:bin_1 bin] Spec #Reference<0.3642608924.1448083459.157519> linked internally
     
     11:17:52.923 [debug] [:bin_2 bin] Initializing spec
     children: [filter: Membrane.Support.ChildCrashTest.Filter]
     links: []
     
     
     11:17:52.923 [debug] [:bin_1 bin] Linking spec #Reference<0.3642608924.1448083459.157519> externally
     
     11:17:52.924 [debug] [:bin_2 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158482>, sync: nil, terminating?: false}]
     
     11:17:52.924 [debug] [:bin_2 bin] Starting child: name: :filter, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.924 [debug] [:bin_2 bin] Element start: :filter
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.924 [debug] [:filter] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.924 [debug] [:filter] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.924 [debug] [:bin_2 bin] Spec #Reference<0.3642608924.1448083458.158482> linked internally
     
     11:17:52.924 [debug] [:bin_2 bin] Linking spec #Reference<0.3642608924.1448083458.158482> externally
     
     11:17:52.924 [debug] [:bin_2 bin] Spec #Reference<0.3642608924.1448083458.158482> linked externally
     
     11:17:52.924 [debug] [:bin_2 bin] Spec playback init #Reference<0.3642608924.1448083458.158482> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1801.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158482>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.924 [debug] [:bin_2 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1801.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158482>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.924 [debug] [:bin_2 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160933>}
     
     11:17:52.924 [debug] [:bin_2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160933>}, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.924 [debug] [:bin_2 bin] Starting children: []
     
     11:17:52.924 [debug] [pipeline@<0.1790.0>] Initializing spec
     children: [source_3: Membrane.Testing.Source, bin_3: Membrane.Support.Bin.TestBins.CrashTestBin]
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :bin_3, from_pad: :output, from_pad_props: %{options: []}, to: :center_filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}, %{from: :source_3, from_pad: :output, from_pad_props: %{options: []}, to: :bin_3, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.924 [debug] [:bin_2 bin] Spec #Reference<0.3642608924.1448083458.158488> linked internally
     
     11:17:52.924 [debug] [:bin_2 bin] Linking spec #Reference<0.3642608924.1448083458.158488> externally
     
     11:17:52.924 [debug] [:bin_2 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160935>}
     
     11:17:52.924 [debug] [pipeline@<0.1790.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: nil, terminating?: false}]
     
     11:17:52.924 [debug] [pipeline@<0.1790.0>] Starting child: name: :source_3, module: Membrane.Testing.Source
     
     11:17:52.924 [debug] [:bin_2 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160935>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:52.924 [debug] [pipeline@<0.1790.0>] Element start: :source_3
     node: ,
     module: Membrane.Testing.Source,
     element options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}},
     
     
     11:17:52.924 [debug] [:bin_2 bin] Starting children: []
     
     11:17:52.924 [debug] [:bin_2 bin] Spec #Reference<0.3642608924.1448083458.158493> linked internally
     
     11:17:52.925 [debug] [:bin_2 bin] Linking spec #Reference<0.3642608924.1448083458.158493> externally
     
     11:17:52.924 [debug] [:source_3] Initializing element: Membrane.Testing.Source, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}
     
     11:17:52.925 [debug] [:source_3] Element initialized: Membrane.Testing.Source
     
     11:17:52.925 [debug] [pipeline@<0.1790.0>] Starting child: name: :bin_3, module: Membrane.Support.Bin.TestBins.CrashTestBin
     
     11:17:52.925 [debug] [pipeline@<0.1790.0>] Bin start: :bin_3
     node: ,
     module: Membrane.Support.Bin.TestBins.CrashTestBin,
     bin options: nil
     
     
     11:17:52.925 [debug] [:bin_3 bin] Initializing spec
     children: [filter: Membrane.Support.ChildCrashTest.Filter]
     links: []
     
     
     11:17:52.925 [debug] [:bin_3 bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: nil, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160944>, sync: nil, terminating?: false}]
     
     11:17:52.925 [debug] [:bin_3 bin] Starting child: name: :filter, module: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.925 [debug] [:bin_3 bin] Element start: :filter
     node: ,
     module: Membrane.Support.ChildCrashTest.Filter,
     element options: nil,
     
     
     11:17:52.925 [debug] [:filter] Initializing element: Membrane.Support.ChildCrashTest.Filter, options: nil
     
     11:17:52.925 [debug] [:filter] Element initialized: Membrane.Support.ChildCrashTest.Filter
     
     11:17:52.925 [debug] [:bin_3 bin] Spec #Reference<0.3642608924.1448083457.160944> linked internally
     
     11:17:52.925 [debug] [:bin_3 bin] Linking spec #Reference<0.3642608924.1448083457.160944> externally
     
     11:17:52.925 [debug] [:bin_3 bin] Spec #Reference<0.3642608924.1448083457.160944> linked externally
     
     11:17:52.925 [debug] [:bin_3 bin] Spec playback init #Reference<0.3642608924.1448083457.160944> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1805.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160944>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.925 [debug] [:bin_3 bin] Initializing playback state :stopped %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1805.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160944>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.925 [debug] [:bin_3 bin] Received link request on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160954>}
     
     11:17:52.925 [debug] [:source_1] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158471>} of child :bin_1
     
     11:17:52.926 [debug] [:bin_3 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {Membrane.Bin, :itself}, from_pad: {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160954>}, from_pad_props: %{}, to: :filter, to_pad: :input, to_pad_props: %{auto_demand_size: nil, min_demand_factor: nil, options: [], target_queue_size: nil, toilet_capacity: nil}}], status: :done}]
     
     
     11:17:52.926 [debug] [:filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083459.157517>} with pad :output of child :source_1
     
     11:17:52.926 [debug] [:bin_3 bin] Starting children: []
     
     11:17:52.926 [debug] [:bin_3 bin] Spec #Reference<0.3642608924.1448083457.160960> linked internally
     
     11:17:52.926 [debug] [:bin_3 bin] Linking spec #Reference<0.3642608924.1448083457.160960> externally
     
     11:17:52.926 [debug] [:bin_3 bin] Received link request on pad {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160956>}
     
     11:17:52.926 [debug] [:bin_1 bin] Spec #Reference<0.3642608924.1448083459.157514> linked externally
     
     11:17:52.926 [debug] [:bin_3 bin] Initializing spec
     children: %{}
     links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :filter, from_pad: :output, from_pad_props: %{options: []}, to: {Membrane.Bin, :itself}, to_pad: {Membrane.Pad, :output, #Reference<0.3642608924.1448083457.160956>}, to_pad_props: %{}}], status: :done}]
     
     
     11:17:52.926 [debug] [:bin_1 bin] Spec playback init #Reference<0.3642608924.1448083459.157514> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1797.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158461>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.926 [debug] [:bin_3 bin] Starting children: []
     
     11:17:52.926 [debug] [:bin_3 bin] Spec #Reference<0.3642608924.1448083457.160964> linked internally
     
     11:17:52.926 [debug] [:bin_3 bin] Linking spec #Reference<0.3642608924.1448083457.160964> externally
     
     11:17:52.926 [debug] [:filter] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158474>} of child :center_filter
     
     11:17:52.926 [debug] [:center_filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158474>} with pad :output of child :filter
     
     11:17:52.926 [debug] [:bin_1 bin] Spec #Reference<0.3642608924.1448083459.157519> linked externally
     
     11:17:52.926 [debug] [:bin_1 bin] Spec playback init #Reference<0.3642608924.1448083459.157519> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1797.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158461>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.926 [debug] [pipeline@<0.1790.0>] Spec #Reference<0.3642608924.1448083459.157494> linked internally
     
     11:17:52.927 [debug] [pipeline@<0.1790.0>] Spec playback init #Reference<0.3642608924.1448083459.157494> %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.927 [debug] [pipeline@<0.1790.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.927 [debug] [:bin_1 bin] Changing playback state from stopped to prepared
     
     11:17:52.927 [debug] [pipeline@<0.1790.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.927 [debug] [:bin_1 bin] Playback state changed from stopped to prepared
     
     11:17:52.927 [debug] [:source_1] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.927 [debug] [:bin_1 bin] Changing playback state from prepared to playing
     
     11:17:52.927 [debug] [:source_1] Evaluating playback buffer
     
     11:17:52.927 [debug] [:filter] Evaluating playback buffer
     
     11:17:52.927 [debug] [:source_2] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160933>} of child :bin_2
     
     11:17:52.927 [debug] [:filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083459.157517>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.927 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.927 [debug] [:filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158491>} with pad :output of child :source_2
     
     11:17:52.927 [debug] [:center_filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158474>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.927 [debug] [:bin_1 bin] Playback state changed from prepared to playing
     
     11:17:52.927 [debug] [:center_filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.927 [debug] [:bin_2 bin] Spec #Reference<0.3642608924.1448083458.158488> linked externally
     
     11:17:52.927 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.927 [debug] [:bin_2 bin] Spec playback init #Reference<0.3642608924.1448083458.158488> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1801.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158482>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.928 [debug] [:filter] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160936>} of child :center_filter
     
     11:17:52.928 [debug] [:center_filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160936>} with pad :output of child :filter
     
     11:17:52.928 [debug] [:bin_2 bin] Spec #Reference<0.3642608924.1448083458.158493> linked externally
     
     11:17:52.928 [debug] [:bin_2 bin] Spec playback init #Reference<0.3642608924.1448083458.158493> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1801.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158482>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.928 [debug] [pipeline@<0.1790.0>] Spec #Reference<0.3642608924.1448083458.158476> linked internally
     
     11:17:52.928 [debug] [pipeline@<0.1790.0>] Spec playback init #Reference<0.3642608924.1448083458.158476> %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.928 [debug] [pipeline@<0.1790.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.928 [debug] [:bin_2 bin] Changing playback state from stopped to prepared
     
     11:17:52.928 [debug] [pipeline@<0.1790.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.929 [debug] [:bin_2 bin] Playback state changed from stopped to prepared
     
     11:17:52.929 [debug] [:bin_2 bin] Changing playback state from prepared to playing
     
     11:17:52.929 [debug] [:source_2] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.929 [debug] [:source_2] Evaluating playback buffer
     
     11:17:52.929 [debug] [:source_3] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160954>} of child :bin_3
     
     11:17:52.929 [debug] [:filter] Evaluating playback buffer
     
     11:17:52.929 [debug] [:filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160962>} with pad :output of child :source_3
     
     11:17:52.929 [debug] [:bin_2 bin] Playback state changed from prepared to playing
     
     11:17:52.929 [debug] [:filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083458.158491>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.929 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.929 [debug] [:bin_3 bin] Spec #Reference<0.3642608924.1448083457.160960> linked externally
     
     11:17:52.929 [debug] [:center_filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160936>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.929 [debug] [:bin_3 bin] Spec playback init #Reference<0.3642608924.1448083457.160960> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1805.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160944>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.929 [debug] [:center_filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.929 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.929 [debug] [:filter] Element handle link on pad :output with pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160957>} of child :center_filter
     
     11:17:52.929 [debug] [:center_filter] Element handle link on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160957>} with pad :output of child :filter
     
     11:17:52.929 [debug] [:bin_3 bin] Spec #Reference<0.3642608924.1448083457.160964> linked externally
     
     11:17:52.929 [debug] [:bin_3 bin] Spec playback init #Reference<0.3642608924.1448083457.160964> %{filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :filter, options: nil, pid: #PID<0.1805.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083457.160944>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.929 [debug] [pipeline@<0.1790.0>] Spec #Reference<0.3642608924.1448083457.160938> linked internally
     
     11:17:52.930 [debug] [pipeline@<0.1790.0>] Spec playback init #Reference<0.3642608924.1448083457.160938> %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}
     
     11:17:52.930 [debug] [pipeline@<0.1790.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.930 [debug] [pipeline@<0.1790.0>] Initializing playback state :playing %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :not_synced, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}
     
     11:17:52.930 [debug] [:source_3] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.930 [debug] [:source_3] Evaluating playback buffer
     
     11:17:52.930 [debug] [:bin_3 bin] Changing playback state from stopped to prepared
     
     11:17:52.930 [debug] [:bin_3 bin] Playback state changed from stopped to prepared
     
     11:17:52.930 [debug] [:bin_3 bin] Changing playback state from prepared to playing
     
     11:17:52.930 [debug] [:filter] Evaluating playback buffer
     
     11:17:52.930 [debug] [:filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160962>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.930 [debug] [:filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.930 [debug] [:center_filter] Received caps on pad {Membrane.Pad, :input, #Reference<0.3642608924.1448083457.160957>}
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.930 [debug] [:center_filter] Sending caps through pad :output
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.931 [debug] [:sink] Received caps on pad :input
     Caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}
     
     
     11:17:52.931 [debug] [:bin_3 bin] Playback state changed from prepared to playing
     
     11:17:52.930 [error] GenServer #PID<0.1790.0> terminating
     ** (FunctionClauseError) no function clause matching in Membrane.Support.ChildCrashTest.Pipeline.handle_other/3
         (membrane_core 0.10.1) test/support/child_crash_test/pipeline.ex:39: Membrane.Support.ChildCrashTest.Pipeline.handle_other({Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}, %Membrane.Pipeline.CallbackContext.Other{children: %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}, clock: #PID<0.1791.0>, playback_state: :prepared}, %{})
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:540: Membrane.Testing.Pipeline.eval_injected_module_callback/3
         (membrane_core 0.10.1) lib/membrane/testing/pipeline.ex:460: Membrane.Testing.Pipeline.handle_other/3
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:140: Membrane.Core.CallbackHandler.exec_callback/4
         (membrane_core 0.10.1) lib/membrane/core/callback_handler.ex:65: Membrane.Core.CallbackHandler.exec_and_handle_callback/5
         (membrane_core 0.10.1) lib/membrane/core/pipeline.ex:112: Membrane.Core.Pipeline.handle_info/2
         (stdlib 3.17) gen_server.erl:695: :gen_server.try_dispatch/4
         (stdlib 3.17) gen_server.erl:771: :gen_server.handle_msg/6
         (stdlib 3.17) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
     Last message: {Membrane.Core.Message, :parent_notification, [:sink, %Membrane.Testing.Notification{payload: {:caps, :input, %Membrane.RemoteStream{content_format: nil, type: :bytestream}}}], []}
     State: %Membrane.Core.Pipeline.State{children: %{bin_1: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_1, options: nil, pid: #PID<0.1795.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, bin_2: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_2, options: nil, pid: #PID<0.1799.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, bin_3: %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.Support.Bin.TestBins.CrashTestBin, name: :bin_3, options: nil, pid: #PID<0.1803.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}, center_filter: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Support.ChildCrashTest.Filter, name: :center_filter, options: nil, pid: #PID<0.1792.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, sink: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Sink, name: :sink, options: %Membrane.Testing.Sink{autodemand: true}, pid: #PID<0.1793.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083458.158445>, sync: :membrane_no_sync, terminating?: false}, source_1: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_1, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1794.0>, playback_sync: :synced, spec_ref: #Reference<0.3642608924.1448083459.157494>, sync: :membrane_no_sync, terminating?: false}, source_2: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_2, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1798.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083458.158476>, sync: :membrane_no_sync, terminating?: false}, source_3: %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Testing.Source, name: :source_3, options: %Membrane.Testing.Source{caps: %Membrane.RemoteStream{content_format: nil, type: :bytestream}, output: {0, &Membrane.Testing.Source.default_buf_gen/2}}, pid: #PID<0.1802.0>, playback_sync: :syncing, spec_ref: #Reference<0.3642608924.1448083457.160938>, sync: :membrane_no_sync, terminating?: false}}, crash_groups: %{1 => %Membrane.Core.Parent.CrashGroup{alive_members_pids: [#PID<0.1794.0>, #PID<0.1795.0>], crash_initiator: nil, members: [:source_1, :bin_1], mode: :temporary, name: 1, triggered?: false}, 2 => %Membrane.Core.Parent.CrashGroup{alive_members_pids: [#PID<0.1798.0>, #PID<0.1799.0>], crash_initiator: nil, members: [:source_2, :bin_2], mode: :temporary, name: 2, triggered?: false}, 3 => %Membrane.Core.Parent.CrashGroup{alive_members_pids: [#PID<0.1802.0>, #PID<0.1803.0>], crash_initiator: nil, members: [:source_3, :bin_3], mode: :temporary, name: 3, triggered?: false}}, delayed_playback_change: nil, internal_state: %Membrane.Testing.Pipeline.State{custom_pipeline_state: %{}, module: Membrane.Support.ChildCrashTest.Pipeline, test_process: #PID<0.1789.0>}, links: [%Membrane.Core.Parent.Link{from: %Membrane.Core.Parent.Link.Endpoint{child: :bin_3, pad_info: %{availability: :on_request, caps: :any, demand_unit: :buffers, direction: :output, mode: :pull, name: :output, options: ni (truncated)
     
     11:17:52.933 [debug] [:filter] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:52.933 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:52.933 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:52.933 [debug] [:filter] Shutting down because of pipeline failure
     Reason: {:shutdown, :parent_crash}
     
     
     11:17:52.933 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
     11:17:52.933 [debug] [:filter] Terminating element possibly not prepared for termination as it was in state :playing.
     Reason: {:shutdown, :parent_crash}"
     
     
................................................

Finished in 33.3 seconds (14.6s async, 18.6s sync)
6 doctests, 253 tests, 41 failures, 1 excluded

Randomized with seed 736889
