# Upgrading to v0.11

v0.11 is a release with a lot of improvements and breaking changes, that haven't been introduced during earlier releases, so we decided to create this guide, to let you know, what changes will be introduced, and how to modify your existing code, to adjust to them.

## Deps ugrade

Update `membrane_core` to `v0.11`
```elixir 
defp deps do
   [
     {:membrane_core, "~> 0.11.0"},
     ...
   ]
end
```

## Update callbacks

To update callbacks
  * rename `handle_caps/4` on `handle_stream_format/4`
  * ...

```diff
- def handle_caps(pad_ref, caps, ctx, state) do
+ def handle_stream_format(pad_ref, stream_format, ctx, state) do
```

## Update actions returned from callbacks

To update actions, rename:
  * `:caps` -> `:stream_format`
  * ...

```diff
- {{:ok, caps: %My.Format{freq: 1}}, state}
+ {{:ok, stream_format: %My.Format{freq: 1}}, state}
```

## Update pads definitions

Instead of using `:caps`, use `:accepted_format` option.
Option `:accepted_format` is able to receive:

 * Module name

```diff
- caps: My.Format
+ accepted_format: My.Format 
```

 * Elixir pattern

```diff
- caps: {My.Format, field: one_of([:some, :enumeration])}
+ accepted_format: %My.Format{field: value} when value in [:some, :enumeration]
```

```diff
- caps: :any
+ accepted_format: _any
```

 * Call to `any_of` function. You can pass there as many arguments, as you want. Each argment should be Elixir pattern or a module name

```diff
- caps: [My.Format, My.Another.Format]
+ accepted_format: any_of(My.Format, My.Another.Format)
```

```diff
- caps: [My.Format, {My.Another.Format, field: :strict_value}, My.Yet.Another.Format]
+ accepted_format: any_of(My.Format, %My.Another.Format{field: :strict_value}, My.Yet.Another.Format)
```

## Update options definitions

Remove `:type` key and related value from defined options. Add `:spec` instead, if it haven't been added before, and proper `:inspector`, if option has default value, that shouldn't be inspected by `inspect/1` during generating docs.

```diff 
- def_options tick_interval: [
-                 type: :time, 
-                 default: Membrane.Time.seconds(1)
-             ],
-             process: [
-                 type: :pid
-             ]
+ def_options tick_interval: [
+                 spec: Membrane.Time.t(),
+                 default: Membrane.Time.seconds(1),
+                 inspector: &Membrane.Time.inspect/1
+             ],
+             process: [
+                 spec: pid()
+             ] 
```

## Membrane.Time functions

Rename `Membrane.Time.to_<unit name>/1` into `Membrane.Time.round_to_<unit name>/1`:
```diff
- rounded_time = Membrane.Time.to_seconds(time)
+ rounded_time = Membrane.Time.round_to_seconds(time)
```


## Update the signatures of `handle_element_start_of_stream` and `handle_element_end_of_stream`

Change the signature of:
* `Membrane.Bin.handle_element_start_of_stream/3` into `Membrane.Bin.handle_element_start_of_stream/4`
* `Membrane.Bin.handle_element_end_of_stream/3` into `Membrane.Bin.handle_element_end_of_stream/4`
* `Membrane.Pipeline.handle_element_start_of_stream/3` into `Membrane.Pipeline.handle_element_start_of_stream/4`
* `Membrane.Pipeline.handle_element_end_of_stream/3` into `Membrane.Pipeline.handle_element_end_of_stream/4`

since till now on these functions accept children name and pad reference as two separate arguments instead of storing them as tuple in the first argument.

```diff
use Membrane.Pipeline
...
@impl true
- def handle_element_end_of_stream({child_name, pad_ref}, context, state)
+ def handle_element_end_of_stream(child_name, pad_ref, context, state)
```

## Update functions used for children <-> parent communication
Rename the following callbacks:
* `Membrane.Bin.handle_notification/4` -> `Membrane.Bin.handle_child_notification/4`
* `Membrane.Pipeline.handle_notification/4` -> `Membrane.Pipeline.handle_child_notification/4`


Rename the following actions:
* `Membrane.Bin.notify_t` -> `Membrane.Bin.notify_parent_t`
* `Membrane.Element.notify_t` -> `Membrane.Element.notify_parent_t`
* `Membrane.Pipeline.forward_t` -> `Membrane.Pipeline.notify_child_t`
* `Membrane.Bin.forward_t` -> `Membrane.Bin.notify_child_t`

Add an implementation of the `Membrane.Bin.handle_parent_notification/3` and `Membrane.Element.handle_parent_notification/3` in place of the `Membrane.Bin.handle_other/3` and `Membrane.Pipeline.handle_other/3` that
were responsible for receiving messages from the parents.

```diff
use Membrane.Bin
,,,
@impl true
- def handle_notification(notification, child, context, state) do
+ def handle_child_notification(notification, child, context, state) do
  ...
- {{:ok, [forward: {child, :response}]}, state}
+ {[notify_child: {child, :response}], state}
end

@impl true
- def handle_other({:message_from_parent, parent_notification}, context, state) do
    ...
-   {{:ok, [notify: :answer]}, state}
+   {[notify_parent: :answer], state}
  end
```

## Update the children definitions
Children defintions syntax (previously known as `ParentSpec`, after the name of a structure used to define children), that was used in `Membrane.Pipeline.Action.spec_t` and `Membrane.Bin.Action.spec_t` actions, has changed.
Since there are quite a few changed concerning children definition, we have decided to present them in the subsections below.

### Update children names
We have restricted the available names for the children. Previously, the children name could be of `any()` type, now it is specified as follows: `tuple() | atom()`.
In case you have used a child name that does not match the new children names specification, you can wrap that name into a tuple, i.e.:
```diff
- child_name = [:why_would, :i_use, :a_list, :as_a, :child_name?]
+ child_name = {:child_name, [:why_would, :i_use, :a_list, :as_a, :child_name?]}
```

### Update the children and links definition
Update the following:
* `Membrane.ParentSpec.link/1` into `Membrane.ChildrenSpec.get_child/1`
* `Membrane.ParentSpec.link/2` into `Membrane.ChildrenSpec.child/2`
* `Membrane.ParentSpec.to/2` into `Membrane.ChildrenSpec.get_child/3`
* `Membane.ParentSpec.to/3` into `Membrane.ChildrenSpec.child/4`

```diff
- children = %{source: SomeSource, filter: SomeFilter}
- links = [link(:source) |> to(:another_filter, SomeFilter) |> to(:filter) |> to(:sink, SomeSink)]
+ children = [child(:source, SomeSource), child(:filter, SomeFilter)]
+ links = [get_child(:source) |> child(:another_filter, SomeFilter) |> get_child(:filter) |> child(:sink, SomeSink)]
```

### Substitute the `Membrane.ParentSpec` structure with a tuple 
`%Membrane.ParentSpec{children: children, links: links, options...}` should be changed into `{structure, options...}` with the `children` and `links` defined as
described in the step above. Note, that there is no distinguishement between `children` and `links` - 
the children and links can be concatenated, so in case you have a separate `children` and `links` lists, simply merge them.

```diff
children = ...
links = ...
+ structure = children ++ links
- spec = %Membrane.ParentSpec{children: children, links: links, node: another_node, log_metadata: metadata}
+ spec = {structure, node: another_node, log_metadata: metadata}
```



### Update the crash group definition
Crash groups has become inextricably connected with a new concept - `children groups`. The name of a crash group is now the name of a children group.
Update the following:
* remove the `crash_group: {crash_group_name, crash_group_mode}` option from the specification options 
* add the `children_group_id` option to the specification options, with the value being the name of the former crash group: `children_group_id: crash_group_name`
* add the `crash_group_mode` option to the specification options, with the value being the mode of the former crash group: `crash_group_mode: crash_group_mode`

```diff
- options = [crash_group: {:first, :temporary}]
+ options = [children_group_id: :first, crash_group_mode: :temporary]
```



Below there is an example that aggregates the changes that need to be done to concerning the `:spec` action preparation: 
```diff
- children = %{source: SomeSource, filter: SomeFilter}
- links = [link(:source) |> to(:another_filter, SomeFilter) |> to(:filter) |> to(:sink, SomeSink)]
- spec = Membrane.ParentSpec{children: children, links: links, crash_group: {:first_group, :temporary}, node: another_node}
+ children = [child(:source, SomeSource), child(:filter, SomeFilter)]
+ links = [get_child(:source) |> child(:another_filter, SomeFilter) |> get_child(:filter) |> child(:sink, SomeSink)]
+ spec = {children ++ links, children_group_id: :first_group, crash_group_mode: :temporary, node: another_node}
- {{:ok, spec: spec}, %{}}
+ {[spec: spec], %{}}
```