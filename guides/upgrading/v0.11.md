# Upgrading to v0.11

v0.11 is a release with a lot of improvements and breaking changes, that haven't been introduced during earlier releases, so we decided to create this guide, to let you know, what changes will be introduced, and how to modify your existing code, to adjust to them.

## Deps ugrade

Update `membrane_core` to `v0.11`
```elixir 
defp deps do
   [
     {:membrane_core, "~> 0.11.0"},
     ...
   ]
end
```

## Update callbacks

To update callbacks
  * rename `handle_caps/4` into `handle_stream_format/4`
  * change arguments in  `Membrane.Bin.handle_element_start_of_stream`, `Membrane.Bin.handle_element_end_of_stream`, `Membrane.Pipeline.handle_element_start_of_stream` and `Membrane.Pipeline.handle_element_end_of_stream` since till now on they accept children name and pad reference as two separate arguments instead of storing them as tuple in the first argument.
  * rename `Membrane.Bin.handle_notification/4` into `Membrane.Bin.handle_child_notification/4`
  * rename `Membrane.Pipeline.handle_notification/4` into `Membrane.Pipeline.handle_child_notification/4`
  * add an implementation of the `Membrane.Bin.handle_parent_notification/3` and `Membrane.Element.handle_parent_notification/3` in place of the `Membrane.Bin.handle_other/3` and `Membrane.Pipeline.handle_other/3` that
were responsible for receiving messages from the parents.

```diff
- def handle_caps(pad_ref, caps, ctx, state) do
+ def handle_stream_format(pad_ref, stream_format, ctx, state) do
```

```diff
use Membrane.Pipeline
...
@impl true
- def handle_element_end_of_stream({child_name, pad_ref}, context, state)
+ def handle_element_end_of_stream(child_name, pad_ref, context, state)
```

```diff
use Membrane.Bin
,,,
@impl true
- def handle_notification(notification, child, context, state) do
+ def handle_child_notification(notification, child, context, state) do
```

```diff

@impl true
- def handle_other(parent_notification, context, state) do
+ def handle_parent_notification(parent_notification, context, state) do
```

## Update actions returned from callbacks

To update actions, rename:
  * `:caps` -> `:stream_format`
  * `Membrane.Bin.notify_t` -> `Membrane.Bin.notify_parent_t`
  * `Membrane.Element.notify_t` -> `Membrane.Element.notify_parent_t`
  * `Membrane.Pipeline.forward_t` -> `Membrane.Pipeline.notify_child_t`
  * `Membrane.Bin.forward_t` -> `Membrane.Bin.notify_child_t`

```diff
- {{:ok, caps: %My.Format{freq: 1}}, state}
+ {{:ok, stream_format: %My.Format{freq: 1}}, state}
```


```diff
use Membrane.Bin
...
- {{:ok, [forward: {child, :response}]}, state}
+ {[notify_child: {child, :response}], state}
```

## Update pads definitions

Instead of using `:caps`, use `:accepted_format` option.
Option `:accepted_format` is able to receive:

 * Module name

```diff
- caps: My.Format
+ accepted_format: My.Format 
```

 * Elixir pattern

```diff
- caps: {My.Format, field: one_of([:some, :enumeration])}
+ accepted_format: %My.Format{field: value} when value in [:some, :enumeration]
```

```diff
- caps: :any
+ accepted_format: _any
```

 * Call to `any_of` function. You can pass there as many arguments, as you want. Each argment should be Elixir pattern or a module name

```diff
- caps: [My.Format, My.Another.Format]
+ accepted_format: any_of(My.Format, My.Another.Format)
```

```diff
- caps: [My.Format, {My.Another.Format, field: :strict_value}, My.Yet.Another.Format]
+ accepted_format: any_of(My.Format, %My.Another.Format{field: :strict_value}, My.Yet.Another.Format)
```

## Update options definitions

Remove `:type` key and related value from defined options. Add `:spec` instead, if it haven't been added before, and proper `:inspector`, if option has default value, that shouldn't be inspected by `inspect/1` during generating docs.

```diff 
- def_options tick_interval: [
-                 type: :time, 
-                 default: Membrane.Time.seconds(1)
-             ],
-             process: [
-                 type: :pid
-             ]
+ def_options tick_interval: [
+                 spec: Membrane.Time.t(),
+                 default: Membrane.Time.seconds(1),
+                 inspector: &Membrane.Time.inspect/1
+             ],
+             process: [
+                 spec: pid()
+             ] 
```

## Membrane.Time functions

Rename `Membrane.Time.to_<unit name>/1` into `Membrane.Time.round_to_<unit name>/1`:
```diff
- rounded_time = Membrane.Time.to_seconds(time)
+ rounded_time = Membrane.Time.round_to_seconds(time)
```

## Update the children definitions
Children defintions syntax (previously known as `ParentSpec`, after the name of a structure used to define children), that was used in `Membrane.Pipeline.Action.spec_t` and `Membrane.Bin.Action.spec_t` actions, has changed.
Since there are quite a few changes concerning children definition, we have decided to present them in the subsections below.

### Update children names
We have restricted the available names for the children. Previously, the children name could be of `any()` type, now it is specified as follows: `tuple() | atom()`.
In case you have used a child name that does not match the new children names specification, you can wrap that name into a tuple, i.e.:
```diff
- child_name = [:why_would, :i_use, :a_list, :as_a, :child_name?]
+ child_name = {:child_name, [:why_would, :i_use, :a_list, :as_a, :child_name?]}
```

### Update the children and links definition
Update the following:
* `Membrane.ParentSpec.link/1` into `Membrane.ChildrenSpec.get_child/1`
* `Membrane.ParentSpec.link/2` into `Membrane.ChildrenSpec.child/2`
* `Membrane.ParentSpec.to/2` into `Membrane.ChildrenSpec.get_child/3`
* `Membane.ParentSpec.to/3` into `Membrane.ChildrenSpec.child/4`

```diff
- children = %{source: SomeSource, filter: SomeFilter}
- links = [link(:source) |> to(:another_filter, SomeFilter) |> to(:filter) |> to(:sink, SomeSink)]
+ structure = [
+   child(:source, SomeSource),
+   child(:filter, SomeFilter),
+   get_child(:source) |> child(:another_filter, SomeFilter) |> get_child(:filter) |> child(:sink, SomeSink)
+ ]
```

### Substitute the `Membrane.ParentSpec` structure with a tuple 
`%Membrane.ParentSpec{children: children, links: links, options...}` should be changed into `{structure, options...}` with the `children` and `links` defined as
described in the step above. Note, that there is no distinguishement between `children` and `links` - 
the children and links can be concatenated, so in case you have a separate `children` and `links` lists, simply merge them.

```diff
- spec = %Membrane.ParentSpec{children: children, links: links, node: another_node, log_metadata: metadata}
+ spec = {structure, node: another_node, log_metadata: metadata}
```


Below there is an example that aggregates the changes that need to be done to concerning the `:spec` action preparation: 
```diff
- children = %{source: SomeSource, filter: SomeFilter}
- links = [link(:source) |> to(:another_filter, SomeFilter) |> to(:filter) |> to(:sink, SomeSink)]
- spec = Membrane.ParentSpec{children: children, links: links, crash_group: {:first_group, :temporary}, node: another_node}
+ structure = [
+   child(:source, SomeSource),
+   child(:filter, SomeFilter),
+   get_child(:source) |> child(:another_filter, SomeFilter) |> get_child(:filter) |> child(:sink, SomeSink)
  ]
+ spec = {structure, children_group_id: :first_group, crash_group_mode: :temporary, node: another_node}
- {{:ok, spec: spec}, %{}}
+ {[spec: spec], %{}}
```