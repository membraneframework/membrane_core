# A script providing a functionality to test performance of Membrane Core.

# Performance test is done with the following command:
# `mix run benchmark/run.exs <result file path>`
# Once performed, the results of the test will be saved as a binary file in the desired location.
# The benchmark consists of multiple test cases. Each test case can be of two types:
# * `:linear` - with a linear pipeline (consisting of a given number of filters, each of which has a single :input and a single :output pad)
# * `:with_branches` - with a pipeline having a single source, single sink and filters forming branches inbetween.
#
# `:linear` test case is parametrized with the following parameters:
# * `reductions` - number of reductions that will be performed in each `handle_buffer` invocation of each filter
# (it's a way to simulate the workload of the element)
# * `max_random` - an upper limit of the range of integers that can be randomly chosen.
# That parameters allows to simulate the stochastic nature of multimedia processing.
# * `number_of_filters` - number of lineary linked filters that the pipeline will consist of
# * `number_of_buffers` - number of buffers that will be generated by the source element before sending
# `:end_of_stream` event
# * `buffer_size` - size of each buffer, in bytes
#
# `:with_branches` test case is parametrized with the following parameters:
# `struct` - a list of tuples of form `{input_pads, output_pads}`, where `input_pads` and `output_pads` describe
# how many input pads and output pads, respectively, should filter at given level have.
# I.e. [{1, 3}, {1, 2}, {6, 1}] describes the following pipeline:
#
#                                                |---Filter_2_0 ---|
#                             |--- Filter_1_0 ---|                 |
#                             |                  |---Filter_2_1 ---|
#                             |                                    |
#                             |                  |---Filter_2_2 ---|
# Source ------ Filter_0_0 ---|--- Filter_1_1 ---|                 |---Filter_3_0 ------ Sink
#                             |                  |---Filter_2_3 ---|
#                             |                                    |
#                             |                  |---Filter_2_4 ---|
#                             |--- Filter_1_2 ---|                 |
#                                                |---Filter_2_5 ---|
#
#
# * `reductions` - number of reductions that will be performed in each `handle_buffer` invocation of each filter
# (it's a way to simulate the workload of the element)
# * `number_of_buffers` - number of buffers that will be generated by the source element before sending
# `:end_of_stream` event
# * `buffer_size` - size of each buffer, in bytes
#
# Test cases are specified with the @test_cases module attribute of the `Benchmark.Run` module.
# Each test case is performed multiple times - the number of repetitions is specified with the
# @how_many_tries attribute of the `Benchmark.Run` module.
# As a result of a test, a binary result file with an avaraged duration of each test case and memory samples
# performed with @memory_sampling_period [ms] intervals is produced.
# `benchmark/comparse.exs` script can be used to compare result files.


defmodule Benchmark.Run do
  import Membrane.ChildrenSpec

  alias Membrane.Pad
  alias Benchmark.Run.BranchedFilter
  alias Benchmark.Run.LinearFilter

  require Logger
  require Membrane.RCPipeline
  require Membrane.Pad

  @test_cases [
    linear: [
      reductions: 10_000,
      max_random: 1,
      number_of_filters: 10,
      number_of_buffers: 50000,
      buffer_size: 1
    ],
    linear: [
      reductions: 10_000,
      max_random: 1,
      number_of_filters: 100,
      number_of_buffers: 50000,
      buffer_size: 1
    ],
    linear: [
      reductions: 10_000_000,
      max_random: 1,
      number_of_filters: 10,
      number_of_buffers: 50,
      buffer_size: 100_000
    ],
    linear: [
      reductions: 10_000,
      max_random: 5,
      number_of_filters: 10,
      number_of_buffers: 50000,
      buffer_size: 1
    ],
    with_branches: [
      struct: [{1, 3}, {3, 2}, {2, 1}],
      reductions: 10_000,
      number_of_buffers: 50000,
      buffer_size: 1
    ],
    with_branches: [
      struct: [{1, 3}, {1, 3}, {3, 1}, {3, 1}],
      reductions: 10_000,
      number_of_buffers: 50000,
      buffer_size: 1
    ]
  ]
  @how_many_tries 3
  @memory_sampling_period 100


  defp prepare_pipeline(:linear, params) do
    Enum.reduce(
      1..params[:number_of_filters],
      child(%Membrane.Testing.Source{
        output:
          {1,
           fn state, _size ->
             if state < params[:number_of_buffers] do
               {[
                  buffer:
                    {:output,
                     %Membrane.Buffer{payload: :crypto.strong_rand_bytes(params[:buffer_size])}},
                  redemand: :output
                ], state + 1}
             else
               {[end_of_stream: :output], state}
             end
           end}
      }),
      fn n, acc ->
        child(acc, String.to_atom("filter_#{n}"), %LinearFilter{
          number_of_reductions: params[:reductions],
          generator: fn number_of_buffers ->
            how_many_needed = Enum.random(1..params[:max_random])

            if number_of_buffers >= how_many_needed do
              how_many_to_output = Enum.random(1..params[:max_random])
              min(number_of_buffers, how_many_to_output)
            else
              0
            end
          end
        })
      end
    )
    |> child(:sink, %Membrane.Testing.Sink{autodemand: true})
  end

  defp prepare_pipeline(:with_branches, params) do
    struct = params[:struct]
    reductions = params[:reductions]

    source = %Membrane.Testing.Source{
      output:
        {1,
         fn state, _size ->
           if state < params[:number_of_buffers] do
             {[
                buffer:
                  {:output,
                   %Membrane.Buffer{payload: :crypto.strong_rand_bytes(params[:buffer_size])}},
                redemand: :output
              ], state + 1}
           else
             {[end_of_stream: :output], state}
           end
         end}
    }

    initial_level = %{level: 1, spec: [child(:source, source)]}
    final_level = Enum.reduce(struct, initial_level, fn {input_pads, output_pads}, current_level ->
      how_many_output_pads = length(current_level.spec)
      if rem(how_many_output_pads, input_pads) != 0, do: raise "Wrong branched pipeline specification!"

      pads_per_filter = div(how_many_output_pads, input_pads)
      spec = Enum.chunk_every(current_level.spec, pads_per_filter) |> Enum.with_index() |>
        Enum.flat_map(fn {group_of_branches, filter_no} ->
          Enum.with_index(group_of_branches) |> Enum.map(fn {branch, branch_index_in_group} ->
            pad_no = filter_no*pads_per_filter+branch_index_in_group
            branch |> via_in(Pad.ref(:input, pad_no)) |> child("filter_#{current_level.level}_#{filter_no}", %BranchedFilter{number_of_reductions: reductions}, get_if_exists: true)
          end)
        end)

      spec = Enum.flat_map(spec, fn branch ->
        Enum.map(1..output_pads, fn output_pad_no ->
          branch |> via_out(Pad.ref(:output, output_pad_no))
        end)
      end)

      %{level: current_level.level+1, spec: spec}
    end)
    Enum.at(final_level.spec, 0) |> child(:sink, Membrane.Testing.Sink)
  end

  defp meassure_memory(mode \\ :fast)
  defp meassure_memory(:fast), do: :erlang.memory(:total)

  defp do_loop(pid, initial_memory, loop_counter \\ 0, memory_samples \\ []) do
    memory = meassure_memory() - initial_memory
    memory_samples = memory_samples ++ [memory]
    next_action = receive do
      :sink_eos ->
         :stop
      after @memory_sampling_period -> :continue
    end
    if next_action == :continue, do: do_loop(pid, initial_memory, loop_counter+1, memory_samples), else: memory_samples
  end

  defp perform_test({test_type, params}) when test_type in [:linear, :with_branches] do
    initial_time = :os.system_time(:milli_seconds)
    initial_memory = meassure_memory()

    {:ok, _supervisor_pid, pipeline_pid} = Benchmark.Run.Pipeline.start(monitoring_process: self(),
     spec: prepare_pipeline(test_type, params))

    memory_samples = do_loop(pipeline_pid, initial_memory)

    final_memory = meassure_memory() - initial_memory
    memory_samples = memory_samples++[final_memory]
    time = :os.system_time(:milli_seconds) - initial_time

    Membrane.Pipeline.terminate(pipeline_pid, blocking?: true)
    {time, memory_samples}
  end

  def start() do
      Enum.reduce(@test_cases, %{}, fn test_case, results_map ->
        results =
          for _try_number <- 1..@how_many_tries do
            perform_test(test_case)
          end

        avg_time = (Enum.unzip(results) |> elem(0) |> Enum.sum()) / length(results)
        avarage_memory_samples_in_mb = Enum.unzip(results) |> elem(1) |> Enum.zip() |> Enum.map(&Tuple.to_list(&1))|> Enum.map(&Enum.sum(&1)/(length(&1)*1_000_000))
        Map.put(results_map, test_case, {avg_time, avarage_memory_samples_in_mb})
      end)
  end
end
output_filename = System.argv() |> Enum.at(0)
result_map = Benchmark.Run.start()
File.write!(output_filename, :erlang.term_to_binary(result_map))
