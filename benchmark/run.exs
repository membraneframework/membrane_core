# A script providing a functionality to test performance of Membrane Core.

# Performance test is done with the following command:
# `mix run benchmark/run.exs <result file path>`
# Once performed, the results of the test will be saved as a binary file in the desired location.
# The benchmark consists of multiple test cases. Each test case is parametrized with
# the following parameters:
# * `reductions` - number of reductions that will be performed in each `handle_buffer` invocation of each filter
# (it's a way to simulate the workload of the element)
# * `max_random` - an upper limit of the range of integers that can be randomly chosen.
# That parameters allows to simulate the stochastic nature of multimedia processing.
# * `number_of_filters` - number of lineary linked filters that the pipeline will consist of
# * `number_of_buffers` - number of buffers that will be generated by the source element before sending
# `:end_of_stream` event
# * `buffer_size` - size of each buffer, in bytes

# Test cases are specified with the @params_grid module attribute of the `Benchmark.Run` module.
# Each test case is performed multiple times - the number of repetitions is specified with the
# @how_many_tries attribute of the `Benchmark.Run` module.


defmodule Benchmark.Run do
  use Mix.Task

  import Membrane.ChildrenSpec

  alias Membrane.RCPipeline
  alias Membrane.RCMessage

  require Logger
  require Membrane.RCPipeline

  @params_grid [
    [
      reductions: 10_000,
      max_random: 1,
      number_of_filters: 10,
      number_of_buffers: 50000,
      buffer_size: 1
    ],
    # [
    #   reductions: 10_000,
    #   max_random: 1,
    #   number_of_filters: 100,
    #   number_of_buffers: 50000,
    #   buffer_size: 1
    # ],
    # [
    #   reductions: 10_000_000,
    #   max_random: 1,
    #   number_of_filters: 10,
    #   number_of_buffers: 50,
    #   buffer_size: 100_000
    # ],
    # [
    #   reductions: 10_000,
    #   max_random: 5,
    #   number_of_filters: 10,
    #   number_of_buffers: 50000,
    #   buffer_size: 1
    # ]
  ]
  @how_many_tries 3
  @memory_sampling_period 100

  defmodule Reductions do
    @moduledoc false

    @function :erlang.date()
    @n1 100
    @n2 1_000_000
    defp setup_process(n) do
      parent = self()

      spawn(fn ->
        Enum.each(1..n, fn _x -> @function end)
        send(parent, :erlang.process_info(self())[:reductions])
      end)
    end

    defp calculate do
      setup_process(@n1)

      r1 =
        receive do
          value -> value
        end

      setup_process(@n2)

      r2 =
        receive do
          value -> value
        end

      {r1, r2}
    end

    @spec prepare_desired_function(non_neg_integer()) :: (() -> any())
    def prepare_desired_function(how_many_reductions) do
      {r1, r2} = calculate()
      n = trunc((how_many_reductions - r2) / (r2 - r1) * (@n2 - @n1) + @n2)
      fn -> Enum.each(1..n, fn _x -> @function end) end
    end
  end

  defmodule Filter do
    @moduledoc false
    use Membrane.Filter

    def_input_pad :input, accepted_format: _any
    def_output_pad :output, accepted_format: _any

    def_options number_of_reductions: [spec: integer()],
                generator: [spec: (integer() -> integer())]

    @impl true
    def handle_init(_ctx, opts) do
      workload_simulation = Reductions.prepare_desired_function(opts.number_of_reductions)
      Process.send_after(self(), :collect, 10_000)
      state = %{buffers: [], workload_simulation: workload_simulation, generator: opts.generator}
      {[], state}
    end

    @impl true
    def handle_buffer(_pad, buffer, _ctx, state) do
      state.workload_simulation.()
      state = %{state | buffers: state.buffers ++ [buffer]}
      how_many_buffers_to_output = state.generator.(length(state.buffers))

      if how_many_buffers_to_output > 0 do
        [buffers_to_output | list_of_rest_buffers_lists] =
          Enum.chunk_every(state.buffers, how_many_buffers_to_output)

        buffers_to_output = Enum.map(buffers_to_output, &%Membrane.Buffer{payload: &1})
        rest_buffers = List.flatten(list_of_rest_buffers_lists)
        state = %{state | buffers: rest_buffers}
        {[buffer: {:output, buffers_to_output}], state}
      else
        {[], state}
      end
    end
  end

  defp prepare_spec(params) do
    Enum.reduce(
      1..params[:number_of_filters],
      child(%Membrane.Testing.Source{
        output:
          {1,
           fn state, _size ->
             if state < params[:number_of_buffers] do
               {[
                  buffer:
                    {:output,
                     %Membrane.Buffer{payload: :crypto.strong_rand_bytes(params[:buffer_size])}},
                  redemand: :output
                ], state + 1}
             else
               {[end_of_stream: :output], state}
             end
           end}
      }),
      fn n, acc ->
        child(acc, String.to_atom("filter_#{n}"), %Filter{
          number_of_reductions: params[:reductions],
          generator: fn number_of_buffers ->
            how_many_needed = Enum.random(1..params[:max_random])

            if number_of_buffers >= how_many_needed do
              how_many_to_output = Enum.random(1..params[:max_random])
              min(number_of_buffers, how_many_to_output)
            else
              0
            end
          end
        })
      end
    )
    |> child(:sink, %Membrane.Testing.Sink{autodemand: true})
  end

  defp meassure_memory(), do: :erlang.memory(:total)

  defp do_loop(pid, initial_memory, loop_counter \\ 0, memory_samples \\ []) do
    memory = meassure_memory() - initial_memory
    memory_samples = memory_samples ++ [memory]
    next_action = receive do
      %Membrane.RCMessage.EndOfStream{element: :sink}->
         :stop
      after @memory_sampling_period -> :continue
    end
    if next_action == :continue, do: do_loop(pid, initial_memory, loop_counter+1, memory_samples), else: memory_samples
  end

  defp perform_test(params) do
    initial_time = :os.system_time(:milli_seconds)
    initial_memory = meassure_memory()

    pipeline_pid = Membrane.RCPipeline.start!()
    RCPipeline.exec_actions(pipeline_pid, spec: prepare_spec(params))

    RCPipeline.subscribe(pipeline_pid, %RCMessage.EndOfStream{element: :sink, pad: _, from: _})

    memory_samples = do_loop(pipeline_pid, initial_memory)

    time = :os.system_time(:milli_seconds) - initial_time

    Membrane.Pipeline.terminate(pipeline_pid, blocking?: true)
    {time, memory_samples}
  end

  def start() do
      Enum.reduce(@params_grid, %{}, fn params, results_map ->
        results =
          for _try_number <- 1..@how_many_tries do
            perform_test(params)
          end

        avg_time = (Enum.unzip(results) |> elem(0) |> Enum.sum()) / length(results)
        avarage_memory_samples_in_mb = Enum.unzip(results) |> elem(1) |> Enum.zip() |> Enum.map(&Tuple.to_list(&1))|> Enum.map(&Enum.sum(&1)/(length(&1)*1_000_000))
        Map.put(results_map, params, {avg_time, avarage_memory_samples_in_mb})
      end)
  end
end
output_filename = System.argv() |> Enum.at(0)
result_map = Benchmark.Run.start()
File.write!(output_filename, :erlang.term_to_binary(result_map))
